<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ness</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nessoffice.github.io/"/>
  <updated>2019-07-23T08:16:04.091Z</updated>
  <id>https://nessoffice.github.io/</id>
  
  <author>
    <name>Ness</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【围炉夜话】神游天外的典型场景，及天外的风景</title>
    <link href="https://nessoffice.github.io/2019/07/23/Toughts-On_Wondering/"/>
    <id>https://nessoffice.github.io/2019/07/23/Toughts-On_Wondering/</id>
    <published>2019-07-23T11:50:59.000Z</published>
    <updated>2019-07-23T08:16:04.091Z</updated>
    
    <content type="html"><![CDATA[<p>总觉得自己不是个心静的人，学习新知识的时候倒是能集中精神一些，但写作业，复习的时候就经常分神，感觉好无聊，宁愿发呆也不想学习。除了复习还有什么时候会分神呢？分神的时候会想些什么呢？这好像也是个有意思的话题。</p><a id="more"></a><p>总觉得自己不是个心静的人，学习新知识的时候倒是能集中精神一些，但写作业，复习的时候就经常分神，感觉好无聊，宁愿发呆也不想学习。除了复习还有什么时候会分神呢？分神的时候会想些什么呢？这好像也是个有意思的话题。</p><p>（我脏话说得越来越多了……不过这篇主要是娱乐向的，可能有些粗糙？但也挺好玩的）</p><p><strong>听听力</strong>：听力好多呀（几十篇），发怵。不行我不能怂我要锻炼自己提升英语水品。点开这篇听力，嗯，我要好好听！（30s后）？？？他在说什么？我天哪这个话题好无聊不想听停停停刚才那句话是什么唉我又想上网冲浪了查单词的时候水一水好了嗯我刚才到底在干嘛呀！我不是在听听力吗！不行不行，静心，静心……我天哪我到底听了什么东西这个部分有提到吗……倒放倒放……诶我怎么又在摸鱼……</p><p><strong>英语阅读</strong>：（看不懂的时候）这鬼文章在写什么？？？这个部分是干嘛用的？？？天哪上一句又在讲什么这篇文章好搓啊越看越恶心我去喝口水冷静一下……嗯刚才看到哪了……我刚才有看吗？？？不行不能这样瞎看，我要认真分析文章结构把这篇狗屎东西做掉。第一段它讲了……我怎么在看第二段？</p><p><strong>做水题</strong>：可持续化是什么东西？什么是权值线段树？今天晚上要吃什么？好饿我想吃零食。这个人博客怎么写成这样啊差评。我去越看说明越看不下去算算算看代码得了。？？？这什么码风呀，o是什么东西k是什么东西你tm变量名也不解释一下搞毛线啊。模拟一下样例好了，先进入这个函数，再来是……？？？不行这个人写的太差了，下一篇。omg怎么又是这种风格……</p><p><strong>做项目</strong>：哇这个功能还能这样实现，太棒了吧！哇这个库这么好的吗！我得用它来重构一遍……舒服……漂亮……（5h过后）我今天都在干嘛啊啊啊啊啊！</p><p><strong>睡觉</strong>：想第一类事情-&gt;想第三类事情-&gt;想第七类事情-&gt;想第二类事情……我怎么还没睡着……热热热热热热死了……哇我怎么还没睡着……</p><hr><p>完稿于2019-07-23</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总觉得自己不是个心静的人，学习新知识的时候倒是能集中精神一些，但写作业，复习的时候就经常分神，感觉好无聊，宁愿发呆也不想学习。除了复习还有什么时候会分神呢？分神的时候会想些什么呢？这好像也是个有意思的话题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随想" scheme="https://nessoffice.github.io/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>【围炉夜话】吉静关于朋友的一些胡思乱想，及友链</title>
    <link href="https://nessoffice.github.io/2019/07/22/Toughts-On_Friends/"/>
    <id>https://nessoffice.github.io/2019/07/22/Toughts-On_Friends/</id>
    <published>2019-07-22T11:50:59.000Z</published>
    <updated>2019-07-23T07:37:05.071Z</updated>
    
    <content type="html"><![CDATA[<p>海水退去 露出了漫漫的旷野</p><a id="more"></a><h1 id="高中"><a href="#高中" class="headerlink" title="高中"></a>高中</h1><p>先讲朋友。ljq叫我广交朋友，但我不是很喜欢这样的建议。不是很愿意主动和别人结交。高中时候班主任也经常给我提这样的建议，我也都是“哦哦哦”过去的。你们不是我，也不了解我的平凡的普通的真实的我也不清楚为什么会感到的尴尬。</p><p>我没什么朋友，独来独往了若干年，没觉得这样有什么不好。自己学习，自己探索，自己难过。自己难过比较难受。可能和他人分享会好受些？不觉得。人真的能够理解他人吗？真正地，理解他人的痛苦，彷徨，徘徊与失落？我相信每个人都会有这样的感受，但不相信人能够<strong>理解</strong>他人的这番折磨。没有原因，仅是不相信而已。</p><p>有时候和同学走在一起，会有貌合神离的感觉。感觉大家都不喜欢我。和蒋哥们走一起时都是他们在聊天。感觉自己可有可无。好像是高二的时候吧，因为相关的原因不想吃饭，包括中饭，包括晚饭。饥饿很好，能把我的想法从那些乱七八糟的很烦很不爽的事情上转移到对饥饿本身的体味上。当然饿多了身体也吃不消，白天头会很晕，晚上会睡不着想着想吃东西想吃东西。于是就只能夜自修后去吃夜宵了。吃夜宵的时候，有时翔中会坐过来，这时候往往会感到一种莫名的感动。</p><p>感觉自己比较黏，谁都黏。大家似乎不喜欢这样的我？那我就只黏着自己好了。很多时候会很封闭，不愿意和人来往。宁愿盯着题目毫无思绪地发呆，宁愿一直一直生闷气，也不想去打扰别人。并不是没有尝试过，只是试的次数太多我厌倦了。错的似乎总是自己。我没有道理，我比较偏执。难过的也是自己，虽然别人也不好受？但我体味不到，理解不了。讨厌将心比心，当且仅当我很不很不开心。</p><p>高三时候心理可能正常了一些吧，虽然不是所有时候。晚上喜欢和阿彪聊天，虽然人家经常不理我。”睡觉。“但也不总是不理我。印象比较深的是四月选考结束后的晚上，我因为网络太崩成绩还没查出来，心还悬得很，完全睡不着。聊未来，聊选择，不知聊些什么，不知聊到几点。虽然我们基本都是自说自话，自问自答，但就是能沉浸在这样没有逻辑的对话中，在充满不确定的前方中感到一丝安定（当然，如果之后发现考试崩了，想必我的回味也不会是这个样子吧）。</p><h1 id="大学"><a href="#大学" class="headerlink" title="大学"></a>大学</h1><p>大学里朋友有很多划分：室友、课友、队友……反倒是“同学”用的少了。我用同学指代课友，同学还以为是高中同学。</p><p>这样的划分在“友”字之前更强调对方在己生活中的具体哪一部分（虽然说者不尽都这么想），更强调双方的共同点（或者说共同利益？），更社会了些，没有象牙塔里那么纯真（去他娘的纯真）。虽说是”友“，但终归只是个称谓而已，这很礼也很文明，但似乎也造成了成年人之间的一丝微妙的隔阂。</p><p>虽然结识很多厉害的人也是上大学的一个作用，但真的不喜欢主动。讨厌经营人脉。无聊。一般不会约别人出来。我对未来没什么想法也不想有什么想法。我只想过上平静的生活。</p><p>有时也会被认识，但并不是所有时候都想认识别人，也不是所有人都想认识。至于想认识和不想认识之间的区别，我也不清楚。私以为能力并不是重要因素。或许和开朗的同学更能聊得来吧。</p><p>有时看着大家都成双入对的会有一丝羡慕，但觉得自己并不是个能始终对女孩子负责的人。无意伤害他人，所以还是把可能的悲哀扼杀掉好了。</p><p>生活本就很拧巴。所以有一些隔阂，保持些距离似乎也不错。进了浙大以来心理状况比以前要健康地多了。庆幸自己能觉得自己是个正常人。这和所处的环境必然是有一定关联的。大家有了距离可以不相互打扰，我可以happy coding而不必在高考之外不自觉地考虑班级里年级里的partition问题，这很棒，对我而言。（当然大学的生活境况必然对每个人心理状况的影响是不一样的，起码我觉得自己的室友，碰到的同学，都很nice）</p><p>但下了雨还是希望能有人来给自己送伞呀。</p><h1 id="Cyber"><a href="#Cyber" class="headerlink" title="Cyber"></a>Cyber</h1><p>或许于我而言，朋友并不是个日常性的词汇吧。所谓“朋友圈”，里面却大都是陌生人的生活，真奇怪呀。</p><p>谈及朋友圈，及与之相关的social media，引一段卢昌海的相当有趣的思考：</p><blockquote><p>性格使然， 我较少与人互动， 微博微信都如此。 有时会想， 微信因为是朋友圈， 相互点赞比较频繁， 那里的点赞会不会无形中成为一种类似 “表忠心” 的行为？ 当一条微信被 N - n 个朋友点赞， 那没点赞的 n 个朋友会不会引起微信主人的留意 (尤其在 N ≫ n 时)？ 如果用 Ai 表示没给微信主人的第 i 条微信点赞的人的集合， 则 ∩Ai 会不会被当成 “叛徒” 集合， 那里的人会不会像《古拉格群岛》里那个在需要鼓掌的场合第一个停止鼓掌的人那样， 引起最高级别的留意？</p></blockquote><p>在信息流通渠道更加多样的今日，诚然人们能更加便捷地获取彼此的相关信息，但对于彼此的<strong>理解</strong>却并不较昔日有了同步的加深。相反，对于“友谊”的经营却更便捷，更快速，更细微化了，因为通信方式的变迁。看上去每个人的通信量都增加了故而朋友也更多了？但是人性并没有随之进化呀。表面稠密的friendship graph，实际上，各个edge的weight也并不像看上去的那么大。无往不在的枷锁呀。</p><h1 id="自己"><a href="#自己" class="headerlink" title="自己"></a>自己</h1><p>不怎么打游戏，不怎么看番。</p><p>不怎么关注热点，包括科技，包括社会。</p><p>不敢在social media上说话，不敢水群，没有点赞的习惯。</p><p>不喜欢关于自己的照片。</p><p>不喜欢在所有人面前暴露自己。</p><p>不喜欢大的组织，不喜欢多人小组的退化，不喜欢不被搭理。</p><p>不喜欢碰到认识但是不熟悉的同学的时候被无视的感觉。</p><p>不喜欢应酬，不喜欢恭维与被恭维。</p><p>不喜欢从他人的身上看到自己的镜像。</p><p>等等。</p><p>喜欢刘震云的小说。</p><p>喜欢汤浅政明的动画。</p><p>喜欢《梦日记》。</p><p>喜欢马蒂斯的绘画，《舞》尤其。</p><p>喜欢巴赫的音乐。</p><p>崇尚计算机科学家、数学家，希望对他们有更深一步的了解。</p><h1 id="友链"><a href="#友链" class="headerlink" title="友链"></a>友链</h1><p>以文会友（可不是言在此而意在彼），是个人简单的希冀。当然以下很多都只是单向边……</p><h2 id="自己-1"><a href="#自己-1" class="headerlink" title="自己"></a>自己</h2><p>如果你能看到这个blog这篇随笔，你或许对一些文章的一些部分有一些想法？或许想交流？一种联系方式是与blog相关联的github账号，虽然通过github来交流感觉有一点点的奇怪……但是github是个交友网站不是吗（<del>划掉</del>）。</p><p>抑或，可以用更普遍也更俗套一点的交流方式，social media。鄙人的QQ号是第648647743个evil number（第一个是evil number是0）。邮箱的话也是账号，因为并没有开其他邮箱。</p><p>我的称谓有很多（<del>因为喜欢胡乱取名字</del>），不过现在基本也固定下来只用几个了。作为successors of Alan Turing的我，作为艺术家与诗人的我，日常中的我，你们眼中的我，在不同维度下的同一个体。</p><h2 id="同期"><a href="#同期" class="headerlink" title="同期"></a>同期</h2><p>（排名，自然是不分先后的）</p><p>NCJ：<a href="https://ncj.wiki/" target="_blank" rel="noopener">https://ncj.wiki/</a></p><p>XTXTMTXTX：<a href="https://www.xtxtmtxtx.xyz/" target="_blank" rel="noopener">https://www.xtxtmtxtx.xyz/</a></p><p>chty_syq：<a href="https://chty.coding.me/" target="_blank" rel="noopener">https://chty.coding.me/</a> （那个nerds.pub好像是合作性质的，管理员还有logining等，不过其他我不认识/捂脸）</p><p>zkx06111：<a href="https://zkx06111.github.io/" target="_blank" rel="noopener">https://zkx06111.github.io/</a></p><p>知名退役选手jsb：<a href="https://www.cnblogs.com/jiangshibiao/" target="_blank" rel="noopener">https://www.cnblogs.com/jiangshibiao/</a> （其实只看学长的游记和好番推荐/捂脸）</p><h2 id="先辈"><a href="#先辈" class="headerlink" title="先辈"></a>先辈</h2><p>卢昌海（知名科普作家，偏物理/人文）：<a href="https://www.changhai.org/" target="_blank" rel="noopener">https://www.changhai.org/</a></p><p>matrix67（知名科普作家，数学，曾为OI选手）：<a href="http://www.matrix67.com/blog/" target="_blank" rel="noopener">http://www.matrix67.com/blog/</a></p><hr><p>初稿写于2019-07-21，夜</p><p>终稿改于2019-07-23，昼</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;海水退去 露出了漫漫的旷野&lt;/p&gt;
    
    </summary>
    
    
      <category term="随想" scheme="https://nessoffice.github.io/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>【朝花夕拾】吉静文选 告别</title>
    <link href="https://nessoffice.github.io/2019/07/18/History-My_Essays-Farewell/"/>
    <id>https://nessoffice.github.io/2019/07/18/History-My_Essays-Farewell/</id>
    <published>2019-07-18T11:53:52.000Z</published>
    <updated>2019-07-22T15:15:41.450Z</updated>
    
    <content type="html"><![CDATA[<p>往事如烟。整理昔日的文稿，总会感到一阵时空错位，和悲凉的感觉。</p><a id="more"></a><p>（版权所有，严禁转载。违者自行承担相应法律责任）</p><p>这个集子名《告别》。</p><p>虽然是随笔，但有些偏向于《残垣》那种风格，但色彩基调明显不一样，也更具现实感。</p><h1 id="教室，在夕阳下"><a href="#教室，在夕阳下" class="headerlink" title="教室，在夕阳下"></a>教室，在夕阳下</h1><p>初中的课本皱巴巴的，好多课文感觉都没学过，仔细一看它们又熟悉起来了。书中有蝈蝈和蛐蛐，有星星的变奏曲，它们提醒了我某段早已被遗忘但仍旧温馨的时光。于是彼时的我住进了此时的我的身体里，时间停止了。 </p><h1 id="竞赛时期标准日程"><a href="#竞赛时期标准日程" class="headerlink" title="竞赛时期标准日程"></a>竞赛时期标准日程</h1><p>起床，清醒，吃饭，待命，上课，能懂，不懂，课间，上课，下课，买饭，回寝，玩乐，午睡，起床，清醒……</p><p>这就是我们的一天，这就是我们的一生。</p><h1 id="最后一次春游"><a href="#最后一次春游" class="headerlink" title="最后一次春游"></a>最后一次春游</h1><p>还在路上，就闻到了前方传出浓郁的烤肉的芳香。烟雾那边我们手忙脚乱。烤架咝咝，送下了喷香的羊肉灼口，还有鲜嫩的青菜淌油。椅子上的自来水逐渐泛开了油滴与黑水。酥而脆的五花肉，韧而耐嚼的鸡心，弹来弹去的面筋，不肯抬头的里脊，以及大红的虾与白里透紫的鱿鱼，都发着小泡，点缀着若干孜然、椒盐，跃入食客们的口中，使得香留唇齿。大饮料瓶中的冰可乐不久就被抢灌一空，留下横七竖八的塑料杯狼藉地躺在桌子上。邻桌娴熟的新疆小伙已和一帮人出去开观光车了，余下一个新人懒懒地经营着几串豆腐，收获着数片扇贝。鼓鼓的肚子坐在长椅上悠闲地沉浸于自己的世界，胖胖的老师则在收拾罢餐桌后拉住路过的同学，来来来，再吃一点。烟雾渐渐散去，人群也变得三三两两，时间在这里走向静止。</p><p>我是在返程的大巴上想起这一切的，那时我因过度尽兴而感到有些疲倦。车里不少人睡着了，很安静，静得仿佛一切都在离我而去，包括三年来所有的好奇所有的不甘所有的恼怒所有的欣喜。</p><h1 id="旧照片"><a href="#旧照片" class="headerlink" title="旧照片"></a>旧照片</h1><p>画面上那个肥嘟嘟圆圆脸的表情呆呆的小孩子，穿着肥大的暖暖的棉衣，被高高抱起，在自己的农村老家门前。那是我。</p><p>这组照片包含了很多景点，看得出是全国各地的大好河山。美丽景色的前边只站了一个人，就那么直直地站着，带着说不好是什么的表情，或许是平静吧。那是妈妈，没有皱纹。</p><p>这张照片是在“温州乐园”拍的，那儿我只去过一次。我不记得那次自己玩得如何，但能从照片上明显地看出奇怪的飞行器上大笑着的那位，铁定是玩得很开心的。他眼睛睁得那么大，可以说有些夸张，不过他平日表现高兴也是这样的。那是我爸，我没法和他交流我现在的感受了。</p><p>不知是我几岁时的家庭聚会，标题写着奶奶的生日。这桌布、这光线，看上去都明亮亮的，很舒服。我穿着某件看上去挺漂亮的毛衣，妈妈有些朴实地目视前方，奶奶则略显笨拙地做着这会儿的主人。很温暖啊。</p><p>我不喜欢拍照，爱拍照的人是爷爷，相册弄了一大摞，不过我还没怎么看。我只在题目写不来时把题目拍下来问我爸，或偶尔想拍了拍两张。手机里的相册，如今仍忠实地提醒着我2017年9月的、2017年6月的往事，当时的情景历历在目，我还能感受照片中自己手指的温度。</p><p>照片还有很多，一一说来不免无趣。随意翻略它们，我看到记下了那只我曾爱不释手的恐龙、从前老家暗淡的光线以及其他许多触动心灵的细节。百味杂陈，我无力诉诸语言，也无意借助语言。</p><p>有时想想，世界还是挺残酷的。隔了一层纸的距离，时间就能永驻，任凭纸外的人感伤流涕也毫不改变。当然“永驻”不大可能，原子衰变或是其他物理化学因素可以轻松摧毁那个世界，只是这和我们正常人类不大相干罢了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;往事如烟。整理昔日的文稿，总会感到一阵时空错位，和悲凉的感觉。&lt;/p&gt;
    
    </summary>
    
    
      <category term="创作" scheme="https://nessoffice.github.io/tags/%E5%88%9B%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>【朝花夕拾】吉静文选 游戏笔墨</title>
    <link href="https://nessoffice.github.io/2019/07/18/History-My_Essays-Collection_Of_Jokes/"/>
    <id>https://nessoffice.github.io/2019/07/18/History-My_Essays-Collection_Of_Jokes/</id>
    <published>2019-07-18T11:53:51.000Z</published>
    <updated>2019-07-22T15:16:42.225Z</updated>
    
    <content type="html"><![CDATA[<p>不开心的大背景下难得真正开心的一些时刻。</p><a id="more"></a><p>（版权所有，严禁转载。违者自行承担相应法律责任）</p><p>难得的开心的文字呀。</p><p>（有几篇太羞耻了，不能放上来）</p><h1 id="徐立海讲水浒故事"><a href="#徐立海讲水浒故事" class="headerlink" title="徐立海讲水浒故事"></a>徐立海讲水浒故事</h1><p>话说鲁提辖在街上买了十斤肉，他乘电梯回公寓时，这个肉呢，放在秤上重量变重了，这是为什么呢？因为它受到了一个向上的加速度！所以超重啦！他快到家的时候，又发现这个肉，又变轻了。他就想回去揍镇关西。他快到电梯门口的，肉又变重啦！哎他就觉得，这个肉有鬼，还是不爽，就去把镇关西给打啦！这就是“拳打镇关西”这个故事的由来。</p><h1 id="某活动课"><a href="#某活动课" class="headerlink" title="某活动课"></a>某活动课</h1><p>一对阴鸷的眼睛在里面四处摇头晃脑地打量着，伴随着牛皮男鞋的“哒哒”声空谷回响。发牌的手冷了下来，目光黯淡地看着前方这无尽深渊。校服以外的蓝色在几秒前还欢快嬉笑的身影后停了下来。“玩什么呀？”</p><p>但什么也没发生，那个男人用同样阴冷的语调说道：“玩吧玩吧，放松一下。”然后他走开了。</p><h1 id="三重奏鸣曲"><a href="#三重奏鸣曲" class="headerlink" title="三重奏鸣曲"></a>三重奏鸣曲</h1><p>平静如水的黑夜里，那个角落传出了不安分的声音。声音起初还只是微弱的鼻息，到了某个节点突然被添了过量的燃料一般，变得雄浑有力，宛若有一辆铁皮火车在喉咙间艰难地前行。它先是爬山坡，音调循序渐进升高，余音袅袅；到了山顶稍作停留，便马上坠下，准备一段时间后东山再起。如此往复，经久不息。对床的低音炮听闻火车隆隆，仿佛找到了知己，与之共鸣起来，时而高亢，巍巍乎若山峦；时而低沉，洋洋乎如流水，变化多端，响亮非凡，嗓子好似海绵被压榨般拼命地挤出声音。那边的重感冒也不曾闲着，这小子还宣称自己从不打呼噜的。三个喉咙不分你我不分轩轾不分高下，你方唱罢我登场，欲与天公试比响，共就三重奏鸣之曲，共成三足鼎立之势。哪怕人间至乐，动听不过如此。只是天下没有不散的宴席，不久便只剩下一辆孤独的小火车寂寞而坚毅地爬着山坡。然而这仙乐倒越发至臻至善了：头一秒还是火车蹒跚步，下一秒竟成了瀑布下高山。只是这样的境界不可久驻，它重复了两三回后，嘟嘟，没燃料了。</p><h1 id="灵魂宝石"><a href="#灵魂宝石" class="headerlink" title="灵魂宝石"></a>灵魂宝石</h1><p>阿狼（化名）此刻正在竞赛教室兴致勃勃地玩着手机，此前他正彻夜不眠地目不转睛于那个发光小长方体，而往常这个时间他都在垂下高贵的头颅以补充能量。</p><p>“阿狼，手机还我。”</p><p>就在中翔（化名）夺过他手机的那一刻，阿狼的眼中光芒尽失，他的身体轰然倒塌，他的灵魂仿佛在一瞬间被抽走了，只留下那具面对桌面沉思的躯体。</p><p><strong>续</strong></p><p>阿狼（化名）此刻正在竞赛教室沉睡仿佛与世长辞。娇男（化名）为不打扰他休息，轻轻地把手机放在他桌子上。听闻这手机碰桌的微小声息，不为任何大吵大闹所动的阿狼竟还魂一般立了起来，夺过那手机稳稳地玩了起来。</p><p><strong>续二</strong></p><p>阿狼（化名）此刻正在睡觉，这是因为手机被玩没电了。幸而它正在充电。随着手机电量越来越高，阿狼的眼睛越来越亮。在手机充满电的那一刻，阿狼自然地将手机拿起，解锁密码，玩了起来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不开心的大背景下难得真正开心的一些时刻。&lt;/p&gt;
    
    </summary>
    
    
      <category term="创作" scheme="https://nessoffice.github.io/tags/%E5%88%9B%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>【朝花夕拾】吉静文选 桃园</title>
    <link href="https://nessoffice.github.io/2019/07/18/History-My_Essays-The_Utopia/"/>
    <id>https://nessoffice.github.io/2019/07/18/History-My_Essays-The_Utopia/</id>
    <published>2019-07-18T11:53:50.000Z</published>
    <updated>2019-07-23T07:00:59.419Z</updated>
    
    <content type="html"><![CDATA[<p>最后一段是借鉴的《兽爪》中的某段剧情：第八集的大战之后，一个服用了“药”的社员拖着半截身子在等死，他请求路过的男主给他一把枪自杀，但他接过枪后却企图射杀男主女主。他们跑掉之后，他想要自杀，却没有子弹了。</p><a id="more"></a><p>（版权所有，严禁转载。违者自行承担相应法律责任）</p><p>最后一段是借鉴的《兽爪》中的某段剧情：第八集的大战之后，一个服用了“药”的社员拖着半截身子在等死，他请求路过的男主给他一把枪自杀，但他接过枪后却企图射杀男主女主。他们跑掉之后，他想要自杀，却没有子弹了。</p><p>Cthulhu风格的科幻小说。</p><h1 id="桃园"><a href="#桃园" class="headerlink" title="桃园"></a>桃园</h1><p>这里是桃园，我是根据祖上流传下的地图来的。老人们说此图非关键时刻不得启封。就连我在厕所中郁郁而死的高祖父、死在五十个女人手上的伯父和用两把手枪终结自己生命的父亲都没有打开过这张地图。如今它在我手上，我在桃园，以一个社会调查员的身份。我想知道这颗黄色星球上的最后一片净土是怎么样的。</p><p>岛的外貌和记载的一样，“芳草腥美，落英缤纷”，外沿是桃花盛开。“林尽水源，便得一山……”我沿小孔进入。光在聚集，就像世界在创立，我感到那边是一个美好的新世界。</p><p>这里的确和我们那不同，偌大的村庄内空无一人。古建筑鳞次栉比，这引起了我调查的兴趣。我走入村庄的内部，打算从房子开始调查。</p><p>每所房屋都不是空的，我在屋外能清楚地感受到。然而门窗紧掩、窗帘遮蔽，里头时不时发出大型食肉动物的进食声、婴儿的尖利笑声以及一些不可名状的声音，大脑产生了本能的畏惧感。窗帘、墙壁或是门楣上不时会冒出或消失些圆睁的眼睛注视着我不断移动。我无法想象里面是怎样一种压抑的恐怖，故而我完全没胆敲门。</p><p>这里是北温带，空气中却一直蒸发着一种浓厚的热气，人待久了足以窒息。</p><p>这里的房屋毫无特点，这是我长久观察后惊惶得出的结论。尽管第一眼看上去是第一航道的古代庭市，它们事实上有种蜡似的虚伪感。房屋的材质并非地球上的任何一种已知材料，性质奇特又恶心。它们的反应甚至让我感觉他们具有生命。</p><p>我终于看见人了，那是一个蘑菇头圆圆脸的小孩和一个胖胖的小孩。他们很欢快地跑着跳着，似乎在进行历史书中提到的“婴孩的游戏”。他们靠近了，脸上洋溢的欢快就像太阳驱散乌云，我感到一种无名的快乐自外界涌入身体。他们靠得越来越近了，我能够听到他们玲珑的小嘴里蹦跳着的欢快的音符，那是：</p><p>“肏你妈…肏你妈…”蘑菇头咧着笑脸，拍打着前面的小胖子，用童稚的声音低声笑骂。</p><p>突然小胖子被路上的石头绊倒了。他的表情即刻突变，它的面具好像裂开了一点。它迅速站起，朝着那石头破口大骂：“肏你妈——的屄！”但随后又仿佛自豪于自己刚才所能说出的最后两字，心满意足地拐进一条小巷，不见了。</p><p>天更热了。</p><p>我突然想到卡夫卡的一篇小说，想到那个被父亲一句判决就马上投河了的孩子，从地上捡了把枪。我想找真正的桃园。</p><p>然而尽是这样的劣等枪。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最后一段是借鉴的《兽爪》中的某段剧情：第八集的大战之后，一个服用了“药”的社员拖着半截身子在等死，他请求路过的男主给他一把枪自杀，但他接过枪后却企图射杀男主女主。他们跑掉之后，他想要自杀，却没有子弹了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="创作" scheme="https://nessoffice.github.io/tags/%E5%88%9B%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>【朝花夕拾】吉静文选 残垣</title>
    <link href="https://nessoffice.github.io/2019/07/18/History-My_Essays-The_Ruins/"/>
    <id>https://nessoffice.github.io/2019/07/18/History-My_Essays-The_Ruins/</id>
    <published>2019-07-18T11:53:49.000Z</published>
    <updated>2019-07-22T15:14:00.242Z</updated>
    
    <content type="html"><![CDATA[<p>小说或者寓言。</p><a id="more"></a><p>（版权所有，严禁转载。违者自行承担相应法律责任）</p><p>这个集子名《残垣》。</p><p>我并不知道这样的文章应当归到哪种文体。自认是小说，或者寓言。</p><p>戏谑为少，幽怨为多。</p><p>完全不美好的，过去。</p><h1 id="狼"><a href="#狼" class="headerlink" title="狼"></a>狼</h1><p>“狼来了，狼来了。”我说。</p><p>他们没理我，他们照常工作。</p><p>之后，我把他们吃了。</p><h1 id="鱼"><a href="#鱼" class="headerlink" title="鱼"></a>鱼</h1><p>“子非我，安知我不知鱼之乐？”庄周言毕，跃而入水，曳尾于涂。</p><h1 id="哈姆雷特"><a href="#哈姆雷特" class="headerlink" title="哈姆雷特"></a>哈姆雷特</h1><p>无穷大的图书馆中一只猴子在如山的稿纸中昏昏欲睡地打字直到它滑下椅去在散落的稿纸中留下了串脏脚印。</p><h1 id="君子之风"><a href="#君子之风" class="headerlink" title="君子之风"></a>君子之风</h1><p>你说他说你说你他妈的分明已经纯乎就是个傻逼傻缺傻狗就是个白痴就是个人渣你拉屎吧你去死吧你你你就是个……</p><p>多讽刺啊，这是相互否定吗？其实这是平等。</p><p>一切冲突均同理，即便你以为故作不争就是君子。</p><h1 id="朋友"><a href="#朋友" class="headerlink" title="朋友"></a>朋友</h1><p>我生活在壳里。</p><h1 id="天堂之门"><a href="#天堂之门" class="headerlink" title="天堂之门"></a>天堂之门</h1><p>从未有人从里面出来过。</p><h1 id="海底两万里的风景"><a href="#海底两万里的风景" class="headerlink" title="海底两万里的风景"></a>海底两万里的风景</h1><p>一只塑料袋悠然飘过。</p><h1 id="蟋蟀和蚂蚁"><a href="#蟋蟀和蚂蚁" class="headerlink" title="蟋蟀和蚂蚁"></a>蟋蟀和蚂蚁</h1><p>艺术家飞往天堂，劳动者驻留于大地。</p><h1 id="善之花"><a href="#善之花" class="headerlink" title="善之花"></a>善之花</h1><p>裸露的大地一旷无垠。地上的我看到地缝中的花朵和远处的石像。石像的表情如它复活节岛上的同胞那样复杂。石像或许等了我千年，或许因我的出现而出现。我未可知。</p><p>我朝花朵走去，石像为我流泪。</p><p>我摘起花朵，石像顷之倒塌。</p><p>不详姓字的花，在被摘起时就枯萎了。</p><h1 id="远方"><a href="#远方" class="headerlink" title="远方"></a>远方</h1><p>我是自己醒的，没有人来叫我，这说明火车还没有修好。火车外的男人们咒骂着火车、行程以及世界上的一切，车厢里则堆积着絮絮叨叨的家常女。我想起城市，打着虚假的暖气，烙上了工业文明的钢印，面无表情的机器公民横行其间。雪花落在我的脸上，打断了我的想象。空中仍摇曳着数片晶莹雪花，但它们不属于我，我也不属于它们，我的归属在火车本会到达的那片地方。在轻微而持续的寒冷中，我还能做什么呢？我睡着的时候尚早，以至那提醒乘客火车故障让他们转回巴士的电子音要过一会儿才响起。其间雪下得越来越大了。</p><h1 id="三只小猪"><a href="#三只小猪" class="headerlink" title="三只小猪"></a>三只小猪</h1><p>猪A在把猪B卖给灰狼后长吁了一口气：终于除掉这个心腹之患了。他却未料自己被猪B反咬了一口，在他之前被那匹狼捅了一刀进了酒肆。酒场中猪C与灰狼划拳碰杯，共啖猪肉，谈天说地。</p><h1 id="心之刃"><a href="#心之刃" class="headerlink" title="心之刃"></a>心之刃</h1><p>历史的事实是不明朗的，没有人真正理解一切的细节，而那在一定程度上会导致不可预测的结果。</p><p>我回到班级。有的人回头看我，有的人没有。她像只花蝴蝶一样仍旧谈笑风生对开门两耳不闻，声音尖锐刺耳。一股无名火起，我径自走去，手上握着把刀，它好像一直就在那里。我用力一刺，然后就没声响了。</p><p>有人来劝架，我一一把他们杀了。</p><p>血干得很快，刀像崭新的一样，锃锃发亮。他们的皮肉和骨头马上腐烂了。</p><p>其他学生也消失了。夕阳照进了干净的教室。</p><p>然后，外面飞来了一只蓝蝴蝶，眨巴着翅膀上的一对眼睛。</p><h1 id="食人症"><a href="#食人症" class="headerlink" title="食人症"></a>食人症</h1><p>我住在房子外面，他们在房子里面。平时我们相安无事，但他们时常莺歌燕舞欢笑不断，而我一个朋友什么房间也没有，常常感到很悲哀。他们是如此的冷漠，却又无比热情地对待同间的房客。他们看见我了，他们的目光满是怜悯，他们的脚扎根于水泥地，他们的表情仍旧愉悦。我好悲哀，我好悲哀；每每这种时候我就想吃东西。人类在休息的时候大脑会消耗20%的能量，为什么要这么多呢？有什么用呢？但外面没有什么可吃的东西，随着我越来越沮丧周围的事物越来越奇怪越来越不可名状。我只能吃掉自己了，它们也是这么认为的，至于他们的观点我不知道我也没有感情顾及。先是手指，是没有味道的鸡爪；再是手掌、手臂、双脚、双腿、躯干还有内脏——人类为什么要思想，为什么要接受一切痛苦的根源——我的头部、我的脑浆、我的思想、我的心。最终我被吃得一干二净。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小说或者寓言。&lt;/p&gt;
    
    </summary>
    
    
      <category term="创作" scheme="https://nessoffice.github.io/tags/%E5%88%9B%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>【朝花夕拾】【转载】听雨轩文选 我的罗曼史</title>
    <link href="https://nessoffice.github.io/2019/07/18/History-Essays_Of_Classmates-My_Romance/"/>
    <id>https://nessoffice.github.io/2019/07/18/History-Essays_Of_Classmates-My_Romance/</id>
    <published>2019-07-18T11:53:48.000Z</published>
    <updated>2019-07-22T15:25:46.394Z</updated>
    
    <content type="html"><![CDATA[<p>非常非常有趣的写法。我也想写这样的内容，不过写的肯定没人家有意趣啦。</p><a id="more"></a><p>（如有侵权，请联系博主。将于第一时间予以删除）</p><h1 id="我的罗曼史"><a href="#我的罗曼史" class="headerlink" title="我的罗曼史"></a>我的罗曼史</h1><p>作者：王敏洁</p><p>月光在墨色的涟漪里晕染开来，满塘浮动的青雾，白衣赤足，衣袂飘飞，跨过万水千山、时光苍茫，她向我走来。一卷楚辞，满纸荒唐，千年哀愁从笔墨间流淌下来，凝成一滴，融入她清俊的眉眼。一见钟情，我和语文的邂逅，是一场宿命的相会。</p><p>人说初恋难忘，果真如此。语文亦师亦友，见识广，有百面之性格，千般之故事。她可以是不谙世事的翠翠，也可以是精明世故的熙凤：可以是赤壁怀古、寻想人生哲理之东坡，也可以是月下荷塘、体悟理想境界之配弦。无论如何，她总携着华丽、朴素、热烈、淡泊之美向我走近，她总带着一种诗意的人生向我走来。喜欢在午后的阳光里修文，铺开一张纸，让每一个坎坷都被照得灿亮，然后开始百般打磨，千般润饰，直至笔墨间蜿蜒出精金美玉般的光华。我从不可惜这样一个下午，也许它本有他用，但我觉得值得。语文值得被一个人认真对待，认真去爱。我们的爱，已渐入佳境。</p><p>至于后来与英语坠入爱河，却又是他话了。金发碧眼，身长九尺，英语虽形貌妍丽，望之而令人生畏。然英雄过不了美人关，终究还是深陷温柔乡。英语为我打开了世界之窗，浩淼的遥远的大西洋上，有一片大陆从海雾后隐现了它的真容。繁荣都市，寂静土地，宏伟繁复的西式建筑，艰涩深邃的文学著作……一群深眉邃眼、高鼻鹰目的外族人，在地球的另一端，同样日出而作，日落而息。细水长流，日久生情，越是深入地了解，越助人抵达一个顿悟的境界：每一个民族，都在经历着同样的喜怒哀乐、兴衰荣辱，都在共享同一片苍穹，同一颗太阳，同一片土地。每一个民族的语言和文化，都同一棵树上不同的花朵。我们同根，我们同生。</p><p>与数学的相爱可谓是回肠九转，异常艰辛。一张空白的试卷，两幅极简的几何，三根愁白的头发，满室弥漫的寂静。不是我不想爱他，而是我不敢爱他。数学长得未免太过生人勿进，白衬衫，黑西裤，纽扣一直系到领口，一副泛着蓝光的深度眼镜，目光让人不寒而栗。数学似乎一辈子都不会对我感兴趣。可是你无法否定，数学的魅力浑然天成，令人无法抗拒。冬夜寂静，一灯如豆，你披衣在桌前与数学对视，感觉一种独属于人类的理性和热情在脑海里冷却，在胸膛里燃烧。于是你开始翻山越岭，千里跋涉，一意孤行，只为寻找一个不为人知的答案。思维的火花在黑夜里闪现出雷电般摄人的光彩。你到达了，或者你倒下了，飞蛾扑火的热情还在胸膛里寂静地燃烧。这是人类至高的理性，他的名字叫数学。</p><p>后来又在倾城日光下邂逅化学，在车水马龙的街道偶遇政治，与胸怀大略、满面沧桑的历史有了交集……学科是有生命的，能在今生今世和他们相知、相爱、相守，是一种莫大的荣幸。</p><p>我不是不在乎外在的东西，只是更重要的是爱，不是结晶；是过程，不是结果；是学习，不是收获。真正热爱的人，将它们所有的爱和生命都注入自己的一片田地，他们将汗水滴入土壤，而不去想耕耘是否会有收货。而他们坐拥的，不只是一个秋天的金黄，还有整个精神世界的富甲一方。</p><p>爱你所学，学你所爱。</p><p>“我在生活里不需要更深地思索，从书卷里获取粮食，在野花盛开的文字中获取爱情，我的世界宁静有序，痛很清晰，爱恨简单存粹。”</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;非常非常有趣的写法。我也想写这样的内容，不过写的肯定没人家有意趣啦。&lt;/p&gt;
    
    </summary>
    
    
      <category term="创作" scheme="https://nessoffice.github.io/tags/%E5%88%9B%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>【朝花夕拾】【转载】听雨轩文选 创世纪</title>
    <link href="https://nessoffice.github.io/2019/07/18/History-Essays_Of_Classmates-Genesis/"/>
    <id>https://nessoffice.github.io/2019/07/18/History-Essays_Of_Classmates-Genesis/</id>
    <published>2019-07-18T11:53:45.000Z</published>
    <updated>2019-07-22T15:23:49.136Z</updated>
    
    <content type="html"><![CDATA[<p>私以为这样的科幻是真正诗意的，文学的，而非仅是“文化的“。</p><a id="more"></a><p>（如有侵权，请联系博主。将于第一时间予以删除）</p><h1 id="创世纪"><a href="#创世纪" class="headerlink" title="创世纪"></a>创世纪</h1><p>作者：孔炳翔</p><p>熵值已经接近了最高点。</p><p>所有文明都停止了战争，在不断临近的热寂面前苟延残喘。</p><p>宇宙已经黯淡无光，唯有深处有几点火光，那是低等生物在用仅存的物质合成恒星。这像是一片涸辙，大鱼们早早地感觉到了干涸的恐惧，潜在水底。而小鱼们还浅浅地浮在水面附近，浑然不知这即将到来的，光明的黯淡。</p><p>此外还有不少的暗点，那是高等文明，它们已经能够完全的使用恒星的光和热或是正反物质湮灭所释放出的能量，包裹它们母星的是一类类似黑体的物质，完全吸收外来的和内在的光线并储存。</p><p>更深处，还有一个暗点和一个光点，在互为中心相互旋转。</p><p>暗问：“你怎么让能量外溢了？你能制造逆熵场了？”</p><p>光：“我不能，但我愿意。”</p><p>“愿闻其详。”</p><p>光：“这是一个故事，或一首史诗，绝非一条物理定则。”</p><p>光的诗：</p><p>“只要我一息尚存，我就称你为我的一切。</p><p>只要我一成不变，你就感觉你在我的四周。任何事情我都来请教你，任何时候我都把我的爱献上给你。</p><p>只要我一息尚存，我就永不把你藏匿起来。</p><p>只要把我和你的意旨锁在一起的脚镣还留一小段，你的意旨就在我的生命中实现——这脚镣就是你的爱。”</p><p>超弦的震动传导着这首诗。暗点们隐藏在黑暗中，揣度着这宇宙的最高解读者之一的隐晦的诗句。</p><p>良久，暗问：“如果答案为爱，那么问题为何？”</p><p>……</p><p>光点挨个地黯淡，熄灭。不少暗点也无声无息地冷却。</p><p>光的光芒同样愈发地不稳定。</p><p>……</p><p>沉寂了许久的超弦再一次地抖动起来，不过这次应该没有听众了。</p><p>光：“你感觉到了吗，这个空间只剩下这里存在塌陷了。他们都熄灭了。我们是热寂屠刀下最后的生还者。”</p><p>“嗯”</p><p>“你想到什么了吗。”</p><p>“有点思路。就是从一个平行宇宙中窃取能量，先躲过热寂。再试试能不能躲到另一个宇宙里去。”</p><p>“那躲过热寂是有办法了，只是大坍塌不一定有办法。”</p><p>“你的光强越来越不稳定了。这就是你那首史诗的意义，你真能逆转熵了？”</p><p>“那我们打个赌吧。”</p><p>“好。”</p><p>“如果你能够在大坍塌前制造出让物质在两个宇宙间流通的通道，这就是你的胜利。而我，如果我的方法能成功，我会重新出现在下一次大爆炸中，继续我的文明。其他文明也会有尝试我的方法，从大坍塌中跳出来，我将这个方法命名为洗礼或是圣餐。”</p><p>“那这样宇宙的能量就会不断减少，宇宙就不稳定了。”</p><p>“不会的，这就是我从很早之前就一直在外放能量的原因。”</p><p>……</p><p>最后的最后。</p><p>……</p><p>光在一片耀眼的光芒中塌陷了，像是大坍塌的序曲。在灼目的闪光中隐约可以看到一块十字形的晶体在挥发。从最重的钚碎裂到了最轻的氢，氢则直接碎裂成中子、质子和电子。电子在高速运动中轰击在质子上中和成中子。中子碎裂成夸克，夸克碎裂成基本粒子，这片空间的普朗克长度。引力场、电磁场融入时间。</p><p>超弦也因这场序曲而沸腾。</p><p>“要是干了以后就完了，那么还是快点干。”</p><p>“Cogito， ergo sum.”</p><p>最后一切都归于沉寂。</p><p>暗细细地感受着引力场，除了她所压迫地这片空间，其他的各处均平坦而光滑。</p><p>全宇宙统一了温度、密度和时间。</p><p>未来的世界是银子的。</p><p>热寂。</p><p>白银时代。</p><p>超弦也沉寂了下来。</p><p>暗试着拨动了一下，一道细细地波传向了宇宙深处。她想了想，拨出一道旋律。</p><p>“就这样，让我独自面对这孤独的死亡。让大坍塌——这场没有客人的最后的晚餐见鬼去吧！”</p><p>在大坍塌前，它都回不来了。她想。</p><p>的确，这道波以超越光速的速度没入黑暗中，像是一位开拓者进入荒野，亦或是一头鲸潜入深海。</p><p>……</p><p>这无边的黑暗像是一个漫长而无月的夜晚在期待着一个黎明。</p><p>它期待着一句话。</p><p>“要有光。”</p><p>……</p><p>大坍塌后的那一刹那，时间终结。</p><p>“又有新成员了，老规矩。你的创世纪。”</p><p>这像是一个沙龙，黑暗中藏着很多身影。</p><p>“那好吧。”</p><p>“要有光！”</p><p>这个奇点便开始发光发热。它极欲爆炸，却听从于这黑暗中的意志。</p><p>“这个世界被光明笼罩，它限制了我不能同时是我却又同时不是我，那我就得有自己的身体。”</p><p>虚空中出现了一块球形的全反射体。</p><p>“这个宇宙不能没有物质，他本将依托于基本粒子而存在。并且它活着。”</p><p>宇宙膨胀了一点，能量迅速形成基本粒子，高速地在局促的空间里移动着。两者的转化达到了平衡。</p><p>“它不能是十维的，它是三维的。那这样我也得是三维的。”</p><p>随着长度、数目、温度这三个维度的建立，它也从球形转化为了十字形晶体。</p><p>“所有粒子都要保有量子纠缠，这样在大坍塌来临时，它们能重新聚拢成一点而这将通过超弦相作用。”它像是叹息了一声。“那这样，速度和空间位置就是相矛盾的了。与此同时，基本粒子就成为超弦在长度维上的震颤。”</p><p>无数冰冷的超弦穿透了它的身体。</p><p>“既然基本粒子是超弦的震颤，那么第一，它不会停止运动，第二，震颤又两个方向。这导致了两种完全相反的物质的存在，而我需要做的只有预定一个方向。”</p><p>它随意地朝一个方向拨动了一下，不同于它之前所做的，这次，它只是在长度维上，而不是在温度维上拨动。</p><p>“它得保障文明的出现。”</p><p>“它得有几种基本力来规定粒子的运动。”</p><p>他幻化出一个正N面体，一个在三维的长度维下就是球体的物体。这个物体最终定格在代表四的那个面上。</p><p>……</p><p>“它还需要一个能量源，和时间轴。”</p><p>“那就是我。”</p><p>“因为它因为我而存在。”</p><p>“我没有活着，也不曾死去。”</p><p>“Cogito， ergo sum.”</p><p>“它诞生之日，便是我消亡之时，它消亡之时，便是我归来之日。”</p><p>他率先成为一道能量流，融入这个奇点。</p><p>“那我们也该加入其中了。”</p><p>黑暗中的身影一一融入了这个奇点。</p><p>它像一颗心脏开始跳动。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;私以为这样的科幻是真正诗意的，文学的，而非仅是“文化的“。&lt;/p&gt;
    
    </summary>
    
    
      <category term="创作" scheme="https://nessoffice.github.io/tags/%E5%88%9B%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>【围炉夜话】对于国内计算机普及教育考核体系范式的简要批判</title>
    <link href="https://nessoffice.github.io/2019/07/18/Toughts-Exams_Of_Computer_Courses/"/>
    <id>https://nessoffice.github.io/2019/07/18/Toughts-Exams_Of_Computer_Courses/</id>
    <published>2019-07-18T11:50:59.000Z</published>
    <updated>2019-07-18T04:18:22.200Z</updated>
    
    <content type="html"><![CDATA[<p>日经，因为不开心。</p><a id="more"></a><p>（文章可能比较情绪化，一些观点会有失偏颇？欢迎批评）</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>咱不谈国内教材的风格问题，不谈谭浩强等经典教育家，不谈十年不更新的课件。咱就来看看现在高校中的计算机考核体系（考试制度、评分制度等等）中存在着哪些问题。</p><p>首先需要说明的是，此处涉及的计算机类课程是“计算机普及教育”性质的，是面向低年级学生的计算机基础课程，包括中学时的信息技术课程、大一的程序设计基础课程等，而非专业性较强的课程，后者因笔者尚未接触过故不作评价。</p><p>所谓考核体系中存在的问题，指的是计算机学科课程的考核无法客观全面地反映学生的能力，造成低能者高分，高能者低分的现象。当然，我并没有做统计，只能拿自己说事。个人看到这样的成绩比较不爽，写篇软文骂骂街，期盼一下更加让人（己）信服的计算机课程考核体系，仅此而已。</p><p>标题中所谓范式，指的是当前国内学校普遍采取的这种考核模式。不光浙大如此，大多数学校在计算机学科的考核模式上虽有差异，但总体而言还是如此的。个人比较不喜这样的考核模式，但也不了解其他的模式，对于墙外的教学也不甚了解，无法提出有指导性的教学改进意见。</p><p>对这种考核体系的厌恶是自中学时代开始的。从中学开始，我就不喜欢技术这门学科的考试，无论是信息技术，还是通用技术（这里不谈通用）。高一时候还能凭借着信息差稳拿信息技术的第一，但等到大家都明白这门课的套路后就发现它也就这样了。大家都满分，很没意思。（高中同学之前在寝室里吹水哪些课拿过第一的时候把信息拿出来吹，搞邪了你）倒是我会因为乱七八糟的问题满不了。难道分数不比别人高说明我不比别人强？怎么可能。难道每个分高于我的人都比我热爱计算机，都比我有程序设计的思想，都比我更理解算法？怎么可能。但分数就是摆在那里。很不爽。很不爽。高中的信息技术无法在思想深度上作拓展，只得在边边角角上挖坑，坑一坑考试技巧低的人。这到底有什么意思？设置这样一门考试是要考察什么？想不明白，于是我不选技术，选历史。</p><p>到了大学，本以为进了计院就不用再接触这些糟心的考试了，但还是事与愿违。</p><p>从浙江大学《C语言程序设计》《程序设计专题》课程的情况来看，这类计算机普及课程的考核一般会由project，平时参与情况，期中期末考三部分构成。其中后者为大头，占了50%~60%。我们便来谈谈这考试。不过在说考试之前，我们有必要关注，考试要考察什么。</p><h1 id="能力"><a href="#能力" class="headerlink" title="能力"></a>能力</h1><p>普及性的计算机学科，需要学生掌握哪些能力呢？中学课本中往往会有office、ps、flash（该换h5啦）的基础操作指南。这些好拿出来考试？有什么思维含量？通过简单的搜索就能掌握的记忆性的知识，完全没必要考察。让学生用文字描述具体的操作过程也挺蠢，有一种独到的滑稽感。说到底，我知道这些内容对中学生而言并非不重要，但感觉用传统的中学教学模式对待计算机课程就有种说不出的拧巴感。</p><p>还有呢？程序设计的能力，这实质上是对计算思维的培养，对逻辑思维以外一种独特而有效的解决问题的思维模式的培养，这是相当有价值的。教授一些简单的算法，一些常见的数据结构，足以打开低年级学生（尤其是中学生）的心智，让他们领略到计算机科学的魅力，而不是薪水的魅力。</p><p>把宏观的程序设计能力再细分，在具体的程序设计上，我们还需要具备对程序流程的理解能力，对意外事件的处理能力，对程序正确性与复杂度的分析能力，等等等等。虽然归纳地并不细，不过考试大抵也便是考察这些个能力。ok，那我们开始讲试卷，看看它能否较好地检验学生的综合能力。</p><h1 id="试卷"><a href="#试卷" class="headerlink" title="试卷"></a>试卷</h1><p>考试试卷会由多个部分组成：判断题（理论性较强），填空题（用大脑编译运行程序），程序填空题。这些部分分别能考察什么东西呢？首先是判断题，个人非常讨厌。有些理论书上没提看似值得深挖，但个人觉得真的没啥意思，举个例子：</p><blockquote><p>定义FILE  *fp; 则文件指针fp 指向的是（）。(1分)</p><p>A. 文件在磁盘上的读写位置</p><p>B. 文件在缓冲区上的读写位置</p><p>C. 整个磁盘文件</p><p>D. 文件类型结构体</p></blockquote><p>这种题目要考察什么？如果教师在课堂上对这一知识点有所强调，并能进行知识点的延伸，那这样的题目可作为检验听课情况的一枚试金石。可若是教师对此完全没有提，学生面对这样的题目要怎么办？虽然自学是重要的技能，但我们也应理清什么样的知识是好的，是值得我们投入时间的。计算机课程不是思想道德修养，它里头虽然也有理论，但切不可空谈理论而忽视实践。而在这样一类的题目中，实践的影子，何在呢？</p><p>虽然题库中存在许多这样无趣的题目，但无可否认的是，许多题目还是有一定价值的，能够帮助同学们检验知识漏洞。这是值得肯定的。</p><p>填空题最大的特点，就是没意思，和实际的工程比较脱节。它是在考察学生对于语法规则，简单的算法的理解能力，但笔者不认为这是一种合格的考核方式。且不谈优先级排序，++++++这种反人类题。填空题与工程的一大脱节便体现在考试的限制上，学生被要求不得打开编译器对程序进行调试。诚然，如果不这么做则填空题的区分度会大幅减少。但这样的规定也在很大程度上破坏了计算机课程可贵的实践性，这和程序填空题的弊端是一致的。本来一个编译运行，几个调试就能发现的低级错误，硬是成了所谓体现区分点的地方。这能区分个什么对语言特性的认识对编程范式的思索，只是停留在大众教育阶段的对于所谓“勤奋”“仔细”的筛选。想到大家在走出高考考场后仍要惦着曾经的那么一些无趣的行为模型，我比较无语。</p><p>至少我没有见到过有趣的填空题和程序填空题，虽然都会做，但做起来慌得不行，唯恐哪个细节又没注意到，感觉写下来的都是错的。事实也正是如此，总会因为trivial的错误错掉一些题（虽然中学老师教我们强调细节，不过在大学的context里，“仔细”的重要程度还是第一位吗？）。程序填空题的初衷是好的，希望考察学生对代码的阅读能力与对程序流程的认识。但不得不说这种形式实在不讨喜。码风的不一本应通过建立语言使用的共识（编码规范）来达到一定程度的消除，然而学校并未这么做。另外，对陌生代码细节的把控不当也是所谓“区分点”的一环，而这本应通过测试来消除的。</p><p>简言之，这三类题除了选择题尚可，对其他两类题鄙人均比较反感。虽然如此，我也不清楚什么样的题型是自己是大家所喜闻乐见的。感觉计算机学科就不适合笔试。加入一定量的编程题（不可以有码量巨大的模拟题）或许比较好吧，但浙大《程序设计专题》课程今年把编程题取消了，原因不明。</p><p>这里顺便吐槽一下PTA系统。死板的填空题检测机制不支持等价写法，程序填空题的评测系统简单粗暴连拼写都不帮你检查一下（变量名错了扣了一堆分，无语）。最让我不爽的是，编程题的题库里放了很多三流学校（浙大不知算不算）三流教师编写的牛逼题，什么答案输出4+-3i才能过，什么手动实现atof函数（还nm是残的，不支持指数写法），什么“题目主要是输入花费大量的时间，如查找出现超时，尝试多次提交。”我还能说什么呢？牛逼，真nmd牛逼。我不知道这样的题目能锻炼我什么能力，只知道我浪费了好多时间好多心情在这种没营养的东西上面。</p><h1 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h1><p>笔者眼中理想的计算机普及教育课程的评价体系相较于此前模式的改变，大抵如下：</p><p>提升project在评价中的占比，达到50%~60%。同时对project的拓展功能进行额外评分（拓展功能与正态分布不可得兼，不当让学生为了不被正太而将简单的project过分复杂化，加上许多“冗余”功能，使得恶性竞争的风气盛行。入门级的计算机课程是简单的，大家都能学得好，搞什么正态分布？猪头领导，不具体问题具体分析，不求是，当什么浙大校长），由教师、助教依据细则、个人判断进行评分。增加project的数目，包括小组project与个人project，两个短学期的课程中，前者一项（工作量较大），后者三项（工作量较小）为宜。互评作为签到性质的任务，在project的评分中只不占比重，只是平时参与情况的一部分，作为同学们相互学习的一环。同时恶意评分者当受到惩罚。</p><p>不取消期中期末考试因其还有一定价值，但应降低其比重至20%~30%。保证题库的质量，撤销同学们普遍认为没有价值的题目。教师当对所谓“考试技巧”进行强调，强调考试与工程的差异与考试本身的价值，本身的特点。考试要增加对伪代码的支持，简单粗暴的程序填空题当少，更能反映考生理解力和表达力（可用伪代码表达自己的想法）的简述题当有。添加一定量的编程题。</p><p>中学阶段的信息技术课程当向这样的模式看齐，尤其是浙江省的信息技术学科。</p><p>以上的方案不尽成熟，还是需要迭代优化的。（所以就鸽在这吧）</p><hr><p>开始于2019-07-03</p><p>完稿于2019-07-18</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日经，因为不开心。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随想" scheme="https://nessoffice.github.io/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>【围炉夜话】互膜与卖弱——黑暗森林中的生存法则</title>
    <link href="https://nessoffice.github.io/2019/07/18/Toughts-Wo_Laji_Nin_Niubi/"/>
    <id>https://nessoffice.github.io/2019/07/18/Toughts-Wo_Laji_Nin_Niubi/</id>
    <published>2019-07-18T11:50:50.000Z</published>
    <updated>2019-07-18T06:09:53.564Z</updated>
    
    <content type="html"><![CDATA[<p>“我最菜了，您最强啦。”金牌玩家如是说。</p><a id="more"></a><p>没有问卷，没有调查。全程瞎bb，欢迎指责本菜鸡哪里说的不对。</p><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>说到卖弱，大家很容易想到NOI，ACM（IMO怎么没人卖？），想到某几个或某几十个大佬间互夸互卖，“我要退学啦”“我是真的菜”，或者，“还是您更强”“您多厉害啊”。（定睛一看，我们能看到一张强连通图，没有自环的那种（夸夸图），还有一张非常神奇的仅由自环构成的图（卖卖图））</p><p>其中可能有历史原因：一开始某些毒瘤学长喜欢这样，于是后辈也都染上了这种风气。不过这样只能保证风气的开端而无法保证其生命力，真正要维持互夸互卖的风气，还是由互夸互卖这一行为本身的特点决定的。这一Meme的生命力为何得以那么顽强呢？首先，我们需要确定我们需要考虑的问题是否属实，在什么条件下属实。</p><p>互夸互卖的风气着实是存在的，但它存在在哪里呢？在别的学科，比如人文社科的学科上，大家也这样吗？在相对一般的大学中，大家也这样吗？这些先不管，虽然它们和我们要考虑的变量间也存在着一定的相关关系而可作为证据佐证我们的观点（因为懒得调查所以懒得管）。我们来yy一下，在工信学子中，在计院学子中，互夸互卖为何能成为一种历久弥新的风气。</p><h1 id="计院？"><a href="#计院？" class="headerlink" title="计院？"></a>计院？</h1><p>是否计算机专业的学生更能膜人呢？从专业，蔓延到其他领域，似乎是这样。</p><p>计算机课程较适合自学，其起点较低而终点难以估量。于是，同一年龄段的学生间往往差异较大。另外，计算机学科的实践性也使得其与数学物理这样的学科有明显的差异，在计算机学科上的领先能直接表现为可见的成果：动不动就能搞看上去很厉害的项目。这能给其他同学造成较大的冲击。</p><p>这套理论听上去很正确？但它能够解释OI选手间的互膜吗？另外，所谓“看上去很厉害的项目”实际上并不一定有难度。世界上有很多封装好的轮子和实现好的库，许多项目只是调库而已，很容易实现，但效果往往不错。</p><p>个人认为，互膜始于计算机课题的难以描述，还有难以把握，而非其难解性。对于同一个问题，或许大家都有些想法。但是要把它具体地实现，则要考虑许许多多的细节，其中许多并不好描述。于是在问题比较复杂的情况下，对这样的问题的解答有一定“玄学”的特质。一段程序，它为何是正确的呢？它这样不可名状，逻辑这般诡异，却又能得出正确的答案？在能够理解者与无法理解者之间，仿佛存在着语言上的隔阂，虽然处理的都是一样的作业，但二者对程序的理解是完全不同的。这层隔阂，或许是造成互膜风气的一个重要原因。开始这样的“膜”是敬畏性的，但逐渐地它演变为游戏性质的meme。</p><h1 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h1><p>单纯把这一行为视为一种游戏的话，它似乎也有可探讨的余地。</p><p>互夸与互卖似乎是一体两面的，表面上，前者是对他人的赞同，后者是对自身的否定。其目的也是相同的，这在之后讨论。但在操作的难易度上，二者并不相同，夸人可以因人而异，抓住对方的vulnerability猛夸猛奶；卖弱则要更深入的挖掘自己，挖到什么宝都能拿出来卖，以增强说服力。夸和卖也要有新意，有气势，这样效果才好。</p><p>夸人-被夸-夸人-被夸……简单的闭环系统，或者简单的博弈。当然，决策也可以是多样的，比如夸和卖可以结合在一起，这样博弈树的当前节点便能得到转换，其走向也能得以改变：“哎哟，我哪有您强啊，您看看您，①②③；您看我多菜啊，①②③”……</p><p>虽然作为调剂而言，偶尔互膜卖弱还是好玩的。但频率多了会感觉这样的对话真的很像小孩子吵架，只不过内容从“我是你爸爸”“我是你爷爷”变成了“您多强啊”“不不不还是您更强”。追求一个虚无缥缈的无法达到的共识，无法达成的认同，这从方向上来说就错了吧。网络上的辩论家们也沉浸在类似的行为中，不过他们争执的内容也不太一样。重复性强迫行为。自虐。Fort-Da。</p><p>是否我们永远长不大？</p><h1 id="认知"><a href="#认知" class="headerlink" title="认知"></a>认知</h1><p>我们为何而互膜而卖弱？因为我们关心自己在他人眼中的形象。</p><p>感到弱小倒是很稀松平常的状态。在庞大的知识体系面前，在生活的无字之书面前。学得越多，越能感到前人已经将弯路都走遍了，可探讨的问题也探讨个遍了，但自己还有很多细节没明白，对于宏观的知识架构也不甚清晰。面对这样的知识大厦，感到弱小，或者更确切些，敬畏，再自然不过的了。我不相信存在热爱数学而不敬畏她的人。</p><p>但是由热爱、信念、意志出发的作研究，与一般的考试，又是两种状态。既然是敬畏，何必要宣扬呢？对于考试，我们在题目之外，也相当看中排名，会自觉地不自觉地关注自己的，别人的位次。</p><p>惧怕形象在他人心目中跌落不起。无法在成绩上做补救，只得在其他方面上做努力。不去想关于考试的细节，假装看淡一切。拒绝交流，做些无关紧要的事情，划水，摸鱼。</p><p>当然，情况也不尽然，以上是我的情形。不过其他情形也就不讨论了吧，没什么好讨论的，大抵在行为上表现出“卖弱”的同学可以分为四五类，每类有不同的特征。但总归，我们当为自己的言行负责。即便是真的不满意，总是表现出来也不免会让他人不舒服，这是客观结果。在游戏的同时应兼顾他人的感受，尤其是因考试而心情不佳的同学，这并不容易，但我认为是必要的，至少自己要做到（似乎，并非人人这么想，这不是普适的价值观）。</p><h1 id="态度"><a href="#态度" class="headerlink" title="态度"></a>态度</h1><p>所以面对这样的风气，我们该怎么做呢？随意。</p><p>以下是笔者的态度：</p><blockquote><p>世人皆浊，何不淈其泥而扬其波？</p><p>众人皆醉，何不餔其糟而歠其醨？</p></blockquote><p>毕竟，主要是你的综合能力，而不是你的言论，决定了你到底是什么嘛。</p><hr><p>初稿写于2019-07-02</p><p>完稿写于2019-07-18</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;“我最菜了，您最强啦。”金牌玩家如是说。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随想" scheme="https://nessoffice.github.io/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>【围炉夜话】从设计的角度看《以撒的结合》</title>
    <link href="https://nessoffice.github.io/2019/07/18/Game-The_Binding_Of_Isaac/"/>
    <id>https://nessoffice.github.io/2019/07/18/Game-The_Binding_Of_Isaac/</id>
    <published>2019-07-18T02:05:59.000Z</published>
    <updated>2019-07-18T04:28:31.602Z</updated>
    
    <content type="html"><![CDATA[<p>并非严谨的考究，只是随便写写而已。</p><a id="more"></a><blockquote><p>以撒的结合是一款集合了推箱子、血统检验、少女换装、宠物养成等等元素的跨世代大作。——灰机wiki</p></blockquote><h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>游戏有多好玩，要素有多丰富就不讲了。初次对以撒感兴趣是因为它的名字，然后是游戏方式吧。在盗版游戏网站上下了羔羊，没玩多久，感觉不好玩，不太适应这种游戏模式，也不知道道具是干啥用的。于是就弃了。那时候大概是初一初二吧。</p><p>高中的时候班里流行元气骑士，我也跟风玩了一会，发现这种游戏模式和以撒很像，这时候能接受了。之后重新开始羔羊，打了几把，感觉不错，于是开始入正。</p><p>然后就是常规的入坑环节了。</p><h1 id="剧情"><a href="#剧情" class="headerlink" title="剧情"></a>剧情</h1><p>游戏究竟讲了一个怎样的故事？其实故事的逻辑并不重要。其中的一些细节也没必要深挖，如为什么天启只掉肉块/绷带，“afterbirth”是什么意思，为何又要设置“mega satan”。这些都是为游戏性，而非剧情服务的。拿hush来说，没有这个boss游戏在剧情上也是完整的，那它加进去的作用是什么呢？丰富boss的种类，给予玩家挑战。再如ultra greed，它不过是七宗罪之一的强化版，为何也是最终boss之一，有这样高的地位？因为游戏要加入greed mode，所以要加入跟这个模式相匹配的boss。从游戏性的角度考虑，这些困惑大都能迎刃而解。</p><p>而剧情也是开放的，没有真正的所谓结局。原版有十三个，重生又多了三个，胎衣又加了几个。那么故事究竟是如何的？无所谓，关键在于它能否打动你。</p><p>游戏中能打动我的点（重生版本），大致如下（<strong>严重剧透</strong>）：</p><font color="FFFFFF">①???结局，一些照片：全家福、带上妈妈的假发、独自一人不开心、愤怒的妈妈……祥和的音乐中，记忆远去，THE END。<br></font><font color="FFFFFF">②拿到cancer时，以撒会哭得更伤心。<br></font><font color="FFFFFF">③用眼泪和怪物对抗。<br></font><font color="FFFFFF">④“Are you sure you want me to die？”<br></font><font color="FFFFFF">⑤原版的海报中，光芒之下是绻缩的以撒，他的身边，是成千上万的腐烂血腥的觊觎的怪物。<br></font><font color="FFFFFF">⑥“子宫层”这个名字，以及其中噬咬的声音。<br></font><font color="FFFFFF">⑦妈心战斗背景音乐名为“Ventricide”，心之死；以撒战斗背景音乐名为“Infanticide”，弑婴。<br></font><font color="FFFFFF">⑧muligen的哭声，leech的叫声……Gurdling的表情与叫声<br></font><font color="FFFFFF">⑨“瘘管”“畸胎瘤”“枯萎卵”，它们的名称；“bloat”“the carrion queen”“枯萎卵”它们的形态。<br></font><h1 id="游戏性"><a href="#游戏性" class="headerlink" title="游戏性"></a>游戏性</h1><p>《以撒》中的元素有哪些呢？道具是为面板属性还有特殊能力服务的，故先来看属性吧。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>首先这个游戏要保障生存，所以要有血量和移速；为了生存还要杀怪，这需要射速和伤害。作为roguelike游戏需要引入更多要素，这先放在“其他”这一项中。简单划分一下，我们能得出基础属性大致能归到这几类中。</p><h3 id="玩家属性"><a href="#玩家属性" class="headerlink" title="玩家属性"></a>玩家属性</h3><p>（粗体字为可拓展可创新点）</p><p>①生存：血量、状态、<strong>受伤机制</strong></p><p>②攻击：伤害、距离、<strong>特效</strong></p><p>③速度：移速、射速、弹速</p><p>④其他：幸运等</p><h3 id="人物特性"><a href="#人物特性" class="headerlink" title="人物特性"></a>人物特性</h3><p>设计更多的可选人物更能激发玩家游戏的兴致，为使人物有特色，一方面要将不同人物的面板区别开来，但更要做的是给人物添加特点。《以撒》在这方面是通过人物初始道具及特性凸显人物的，比如Eve在一血时便能开启Whore of Babyron，???不可获取红心等。</p><p>这里还涉及了人物形象的塑造。总而言之，《以撒》中除Lazarus和Eden外的人物形象都较为独特而讨喜，个人尤其喜欢Eve、Azazel、Magdalene的形象，另外Magdalene和妈妈形象的相似及其恢复系特点则从侧面对剧情有所表现。</p><h3 id="眼泪属性"><a href="#眼泪属性" class="headerlink" title="眼泪属性"></a>眼泪属性</h3><p>除了基础的伤害、距离，特效就需要用到思维发散了。另外，伤害也能通过其他方式得到加成，如生成蓝苍蝇，烧伤或中毒效果。简单盘点一下，《以撒》中有这些个特效。</p><p>1.分裂（分击中分裂与直接分裂）：寄生虫或洛基的角、四眼蜘蛛</p><p>2.穿透（分穿透敌人与穿透地形两种）</p><p>3.击退：狗头</p><p>4.悬浮：反重力</p><p>5.状态变更(中毒/烧伤/迟缓/石化/恐惧）</p><p>6.追踪：弯勺者</p><p>7.蓄力：巧克力奶</p><p>8.爆炸：吐根</p><p>9.制造友军：猫套</p><p>10.变轨：除了各种worm外，还有镜像和妈刀，因为回程也算得上一种变轨</p><p>11.防御：隐形眼镜</p><p>12.吸引：奇异吸子</p><p>13.攻击方式变更：鲁多维科科技</p><p>……</p><p>这些并不好做归纳。但确实非常多样，非常给游戏性加分。</p><h2 id="地图与怪物"><a href="#地图与怪物" class="headerlink" title="地图与怪物"></a>地图与怪物</h2><h3 id="地形与地图结构"><a href="#地形与地图结构" class="headerlink" title="地形与地图结构"></a>地形与地图结构</h3><p>伤害类：刺、血</p><p>障碍：洞、石头</p><p>地图结构的总趋势是越下层地图越大目标房间越难找。而且越往下走，单个房间的难度一般也会更高。结合具体的地图说明或许更有说服力些。</p><h3 id="怪物"><a href="#怪物" class="headerlink" title="怪物"></a>怪物</h3><p>怪物的基础属性和玩家是类似的。所不同的是，怪物的攻击方式一般更加多样，除了“弹幕”，还可以以各种方式冲撞，放硫磺火（血束），招小怪等。</p><p>怪物的免疫方式也各有特色。The carrion queen就是个比较好的例子，虽然很蛋疼。</p><h2 id="道具"><a href="#道具" class="headerlink" title="道具"></a>道具</h2><h3 id="道具渊源"><a href="#道具渊源" class="headerlink" title="道具渊源"></a>道具渊源</h3><p>1.源自宗教：硫磺火、三位一体盾……分天使与恶魔两个方向</p><p>2.源自以撒的生活，包括很多腐烂的事物，如早餐中餐晚餐，Guppy相关的道具等</p><p>3.源自其他文化，包括其他游戏（魔法菇）、流行文化（十二星座）等</p><p>其中第三类看上去有些跟剧情不搭嘎，但也是合理的，不光是因为《以撒》并非剧情向的游戏。星座文化可能有些俗套，但在以撒的视角中，这也没什么问题——以撒作为一个既有普遍性又特殊的美国小男孩，了解这些文化，玩各式各样的游戏是很正常的。</p><h3 id="道具形象"><a href="#道具形象" class="headerlink" title="道具形象"></a>道具形象</h3><p>如果是我来设计这款游戏的话，我会先把道具的功能设计出来，再考虑形象。不过如果捡了道具而角色形象完全没改变，游戏性可能会有所下降。在这个意义上，《以撒》“换装”的特点将其roguelike的特性发挥得更深了一层，虽然这并非游戏的主要功能，但着实是一个很漂亮的bonus。（但是，后面的服装会覆盖前面的，我觉得这样不够好）</p><h2 id="探索性"><a href="#探索性" class="headerlink" title="探索性"></a>探索性</h2><p>《以撒》在游戏要素的展现尚做得还是可以的。一开始玩家只能start game。死亡。重开。死亡。重开。打完妈腿，游戏结束了？子宫解锁。妈心。每次都有不同的结局。黑暗层，教堂。再来是宝箱层，阴间。再之后呢？好像并没有个名义上的终点。虽然打完哪个boss都可能是the end。但相信玩家并不总是有the end的感觉。</p><p>但之后游戏的探索性便比较弱了。毕竟游戏的剧情并不清晰，可探索的元素在游戏后期相对较少了。之后，《以撒》更像是个日常打卡游戏。个人在玩了70h之后感觉游戏要素已经较少了，我也不是成就党，所以游戏基本就扔栈底了。这样看来，《以撒的》生命周期至少有40h，对一些核心玩家而言会较长。</p><h1 id="画面"><a href="#画面" class="headerlink" title="画面"></a>画面</h1><p>血腥、黏着、腐化的环境，却并不阴暗，而是非常明亮，真讽刺啊。</p><p>总体的画风还是比较萌的，但是有的道具，细细一想，好瘆人的。铁丝衣架还好了，眼球突出就比较引人不适了。用可爱的画风吸引玩家并使之适应，同时制造出反差，这也算是游戏的特色吧。</p><hr><p>初稿写于2019年5月4日</p><p>完稿写于2019年7月18日</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并非严谨的考究，只是随便写写而已。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计" scheme="https://nessoffice.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="游戏" scheme="https://nessoffice.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>【围炉夜话】七月集训自省书</title>
    <link href="https://nessoffice.github.io/2019/07/17/ICPC-Feeling-July/"/>
    <id>https://nessoffice.github.io/2019/07/17/ICPC-Feeling-July/</id>
    <published>2019-07-17T11:53:37.000Z</published>
    <updated>2019-07-22T15:18:24.952Z</updated>
    
    <content type="html"><![CDATA[<p>（虽然是写给颜学长的作业，但感觉还是写出了些东西的，就把这篇放上来了。dl们轻喷鸭qwq）</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记得之前颜学长在群里说集训队中有空余名额而鼓励同学们主动申报时，自己内心还是非常忐忑的。虽然知道自己能力尚不强，短期内也难有较大提升；但还是很想能以此催逼自己学算法，以收获一段不一样的体验。以下，是当时自己对“为何希望参加ICPC”的回答：</p><blockquote><p><strong>1.为何希望参加ICPC</strong></p><p>- 想要收获一段富足的，紧张刺激的体验；</p><p>- 想要结识其他厉害的同学，收获友谊；</p><p>- 想要在算法能力上有进一步的提升，拓宽拓深自身的知识面。</p></blockquote><p>当然，我知道自己的能力还很有限，所以参加集训的主要目的是学习，同时希望在比赛中收获经验，提升自我。不过从七月中我的所为来看，自己仍心有余而力不足，提升得还不够，能力上还是差了厉害的同学一大截。这有心态上的原因，有思维结构上的原因，还和具体的能力也有一定的关联。不论如何，总归是一段经历吧。</p><h1 id="个人赛总结"><a href="#个人赛总结" class="headerlink" title="个人赛总结"></a>个人赛总结</h1><h2 id="contest-1"><a href="#contest-1" class="headerlink" title="contest 1"></a>contest 1</h2><p>这场总体而言打得不好，爆零了。一方面题目不太容易，另一方面自己的知识点还太薄弱，A题将kmp稍作变式就不会了，hash也出锅了。写题策略也不是很得当，一直在纠结没有人做的D题，废了挺多时间的，导致到了挺后面才开始看B题（虽然即便能逃出WA的命运还是躲不过TLE啊）。知识点薄弱，于是在将E题的操作抽象出来后沮丧地发现自己的数据结构水平碰不动这题。</p><p>A题想了想发现可以用last数组记录上一个位置，然后就是字符串匹配了，但是要更新节点。自己之前写的kmp是迭代地算出来的，不支持更新的操作，于是改用hash：$map &lt; deque &lt; int &gt; , int &gt;$，但不知道哪里出了问题，WA了三发。之后换成自己写的hash就过了。STL有些靠不住？</p><p>B题一开始看到有点怕，但想了想发现还好，就是个树上的dp，状态的转移很自然，但还是WA了，原因不明。听讲题组说还要先bfs一遍确定顺序，要预处理逆元……虽然这些都做了但还是T了，不知为何，常数太大了？</p><p>D的话一直在推式子，看看这个CNF如何转化为full CNF，但越想越感到它不好描述，就弃了。</p><p>E看了看发现这就是个带修改的区间第k大值问题，不会做，还需要学习。</p><h2 id="contest-2"><a href="#contest-2" class="headerlink" title="contest 2"></a>contest 2</h2><p>第二场作为出题组所以没有打，出的是比较水的H题。即便如此题目还是想了很久才想出来。思维一直比较乱，直到想到2i和2i+1中有且仅有一个odious number后才发现这题好简单。A题想的倒比较快，不过不是很严谨，只是大致觉得贪心是正确的。</p><p>C是二叉树染色（其实跟图论没关系好吧还是有些关系的，考察的算法是线性代数……）。这题如果当时做感觉肯定是不会的（自己肯定是疯狂找规律然后陷入自闭，在听到题解时诧异“啊这题要用矩阵快速幂？”），因为自己没有想到要把root和第i层的节点node看作是一条长度为i的起点为root终点为node的路径。这个抽象很重要。这样抽象之后，便可以把原题转化为一个求定长路径的满足条件的路径数的问题了。根据离散书上的结论，这可以用一个矩阵快速幂算出来。但是，题目所要求的并非叶子节点的路径数，而是所有节点的路径数。故而要求的不能是$A$，而得是$\sum A$。（然后还是不会做，我知道$\sum A = (E - A^{n+1}) \times (E - A)^{-1}$但我不知道在一些情况下逆矩阵并不存在……）而这可以靠矩阵维护，很奇妙。从这题中回（xue）顾（xi）了一下线代中的一些套路。</p><p>在D，火柴人这题上微微锻炼了一下思维。这也是个贪心，不过没A那么显然。有点像求Euler path时的那种贪心：匹配后删边。为什么这样是正确的呢？看感觉吧……然后对于父親节点和父親的父親节点，还有父親的父親的父親节点的操作，他们并不是完全一致的，前两者是把儿子全删掉，后者就删一个儿子。为什么呢？画画图感受一下……所以一个bfs再加个reverse，自底向上地找火柴人再删边就好了。感觉自己对这类题（树上的操作）的理解还不是很深，还需要强化，否则下次碰到变式还是不会的。</p><p>E，并查集（棋盘区间合并）这题比较麻烦，比较锻炼综合能力。读入确是一个麻烦的点，但不应当一上来就搞读入，而要先设计好如何对题目中的操作进行建模。很明显，保存整个棋盘的状态是不可行的，空间不够。需要保存的也只有上一行的状态和这一行的状态。那么怎么将有交集的区间合并起来呢？感觉并查集比较好用，那就并查集吧。合并id，合并id对应的size。在最后找$id == pre[id]$。即可。并不好讲的，略显麻烦的综合题。</p><p>F是连分数的题。这个模型此前从没接触过，看到了一脸懵逼，不过跟着题解走感觉也还好，又学到了一些指不定用得上用不上的套路。先是找规律，发现分子/分母各满足一种递推关系。于是可以用矩阵维护这个递推关系。因为要支持单点修改和区间查询，就得把矩阵放到线段树上。也就差不多了。</p><h2 id="contest-3"><a href="#contest-3" class="headerlink" title="contest 3"></a>contest 3</h2><p>第三场感觉手感好一些，不过这场出了点锅，主要是A题，把一周前的原题摆出来这是认真的么……秒完A就是看E，思考了一段时间后顺利AC；再来是F，思考了更长时间结合了一些奇技淫巧后也成功AC。但做完这三题就没题做了……C拿手推SG函数推得手抽筋还没发现规律。B题看到suffix就心烦不想看。G没经验，不会。这场虽然我做得还可以，不过学长们感觉不行，一找找出好多道原题……集训前练了练和期望相关的题目，也学了学整出分块，A也有补。总体来说运气的成分也占了一定的比重吧。</p><p>秒掉了A题然后就是看E，没有想到容斥，感觉似乎能递推？设规模为n时答案为$f[n]$。考虑男一，他的位置是随意的。有$\dfrac{1}{2n-1}$的概率女一坐在男一旁边。这时候答案就是$Df[n-1]$。可若是女一不坐在男一边上呢？考虑把男一旁边的位置和女一旁边的位置合并为一对位置。无论是否cp坐在这个位置上，它对于答案都没有贡献。记有这样一对“坏位置”时规模为n的答案为$g[n]$。同样地，我们对$g[n]$进行化归。即可得到这样的递推方程$g[n] = \dfrac{1}{2n-1}f[n-1] + \dfrac{2n-2}{2n-1}g[n-1]$。而$f[n] = \dfrac{1}{2n-1} D f[n-1] + \dfrac{2n-2}{2n-1}g[n-1]$。初始条件想一想，两个式子同时遍历一波，答案就出来了（数竞的时候总要从这样一组递推方程中得到封闭公式，有了计算机的算力反而递推方程是更容易理解也更容易搞出答案的形式，学科有别啊学科有别）。</p><p>写完了E看F，也是期望dp。一开始算出来没有模MOD，算出来跟答案不一样，看了好一会儿才发现问题出在哪（好尴尬，估计出题人看到我的request会想笑）。想清楚了之后发现式子很好推，和整除分块好像。简单码了一码，交了上去，RE了，才发现没有把E换成calc_E。之后再是本地调，预处理了一下逆元以降低复杂度，然而又出锅了：inv预处理得不够大。于是之后代码就变成了算逆元又有费马小定理又有线性预处理的神奇版本……即便如此算得还是很慢。用clock_t算了一算，发现预处理很快，后面算很慢。于是用unordered_map记忆化一波，成功AC。</p><p>C还没补，状态的转移有两类，一类涉及增加的，要考虑边界。边界不会考虑，于是算出来的结果很奇怪很奇怪，不知怎么调整。</p><p>D涉及到快速求解大整数的质因子，还不会……</p><p>G感觉有些套路？线段树维护矩阵连乘。开始看到没想法，但其实和contest 2的F很像很像的。如果早点补题或许能把这题搞出来的……这样就不用纠结在C上面了。</p><h2 id="contest-4"><a href="#contest-4" class="headerlink" title="contest 4"></a>contest 4</h2><p>第四场比较难，一开始看题感觉啥也不会，慌得不行。大家做出来的题普遍不多，我也只做了一题，但是做得比较慢，因为对题意开始有些不理解，然后调参还调了很久。这场的节奏被几个陈题带偏掉了，于是大家都在看C和E，没有看（出题人说比较简单）的F和G。状态比较差，做完D之后就陷入了没题做的尴尬境地，想群论死活想不明白。B的复杂度也搞不对，C也是毫无头绪。其他题没有仔细看，又是决策失误啊决策失误。</p><p>作为签到题的D并不难，但我开始没有看出这是签到题，因为一开始没有正确理解题意，没想到只要求个$\Delta \theta$就好，反而七想八想想到奇怪的地方去了，给出题人send request还很尴尬地被no response。理解了题意就好做了，划两条公切线（开始只划了一条公切线，没有把微积分的本质掌握啊我orz），找一下几何关系，注意一下什么时候$\theta$要换成$\pi - \theta$，就差不多了。我一开始把概率的递推关系搞错了，导致$\sum P \not = 1$，搞了好一会才想明白。没有把微积分实质掌握还有一个反映，就是我以为区域是对称的然而并不是，只有下半边能取，上半边是取不得的。在这上头（$/ 2\pi$，不是$/ \pi$）又debug了老半天，拿python当计算器疯狂手工计算。虽然这点是比赛结束后才想到的，不过能凑出答案也是不错的。做得实在是慢啊。不过也算涨了些经验，之后碰到这类涉及浮点数的题时候会更顺手些吧。</p><p>E看着是个群论题？变换了好久才发现这个变换的实质：交换一三列，三列同时取反。然后就不会了……在四元那八种等价元素间一直在找特征值，死活找不到……这题还没补。</p><p>C有一万个人做出来但其实好难的咧……听说cjb，jsb他们当年都没人做出来……卡在这鬼题目上卡了一万年，心塞塞。</p><h2 id="contest-5"><a href="#contest-5" class="headerlink" title="contest 5"></a>contest 5</h2><p>又爆零了，菜本菜呀……</p><p>两个线代题都不会，第一个，A完全莫得想法。第二题，E对除法的处理不很恰当。想着凑出一个线性组和满足答案的形式，但怎么想怎么不对。而把未知量和已知量分离，再跑个高消则能解出答案。代码量略大，但思维难度不大，应当要想出来的。我不只是微积分没有掌握本质，线代也根本没有学清楚啊……这题补了却无法在99上面跑，也不知程序是否正确。</p><h2 id="contest-6"><a href="#contest-6" class="headerlink" title="contest 6"></a>contest 6</h2><p>虽然没有爆零但还是菜。</p><p>一来先把题目顺着过了一遍，A看着就慌，跳。B看着感觉比较套路，但没想法，也跳。C好可怕跳掉了。看到D还是稍稍有一点想法的，然后就死在这上面了。G看了看感觉做不出来，跳。E是关于LCS的较灵活的题，可能能做？但dp太差想问题想得乱七八糟的，也跳掉了。F被题意坑惨了……就算做题策略得当，我还能做出哪道题呢？也就罚时少一点吧。硬实力实在不行。</p><p>D题想了想，枚举最长边，枚举次长边，数形结合一下，可以直接找最短边。没有关注到数据范围的50000。一直WA一直WA，WA到怀疑人生。难道是这个-1的问题？嗯……终于T了！然后就没想法了，尝试分块，WA，再分块，WA，比赛结束。答案还没看。</p><p>F题发现题目中的点构成了一个特别特殊特别特殊的六边形。然后一个点染色，一个连通块的颜色就确定了！这样贪心地做就好了。一开始dfs，WA了。百思不得其解。之后感觉bfs更靠谱些，还是WA，奇怪奇怪。之后扫了一下classification，发现随意输出答案也是要顺序的……晕死了，浪费了一个小时加两发才A掉。这样下来F2也有想法了：对于每个连通块，维护一个结构，包含了未选区域的最小元、选区和未选区元素个数差、选了的区域和未选的区域。看上去很完美，叠了一层又一层的STL。然而……WA掉了？没有发现问题出现在哪里。</p><h1 id="对自我的剖析"><a href="#对自我的剖析" class="headerlink" title="对自我的剖析"></a>对自我的剖析</h1><p>（也就是颜学长强调的要写的“自己的长处短处”“以前认为的上一项”。不过我没有“以前”，就只好从零开始剖析自己的长短处了；作为非春季集训队成员，互评的任务也是没有的）</p><p>直视自己的弱小，找出权值最高的薄弱点，找出合理有效的解决方案，这是必要的。咱虽然能力不行，但可不能心态也不行呀。</p><p><strong>字符串</strong>：只会最基础的复杂度颇高的操作，对前缀函数等字符串相关知识点的理解还不够深。对较灵活的题目缺乏经验。亟需强化。</p><p><strong>动态规划</strong>：对动态规划没有很好的总结与系统性的认识，一般都是瞎搞而无法系统地对其进行分析与归纳。因为认识不深，能否做出题比较看运气。</p><p><strong>数论</strong>：（身为前数竞选手对于自己对于ICPC中的数论题不精颇感惭愧）打过一些基本的板子，如拓展卢卡斯定理，孙子定理，杜教筛的板子，并能对其有一定的认识，但认识并不深。碰到题目有时会陷入不知从何分析的境地。</p><p><strong>数值</strong>：做过的题不是很多，了解的结论也不是很多。</p><p><strong>图论</strong>：基础的知识基本掌握，但做的题还比较少，做题经验比较匮乏，看到较新颖的题会陷入不知如何分析的境地。</p><p><strong>博弈</strong>：了解一些基本模型，写过少量题，但没怎么做归纳。一般的套路还未掌握。能否想出来比较看运气，看思维是否和题目衔接上。</p><p><strong>计算几何</strong>：写过一些基本的板子：graham，旋转卡壳，最近点对，但对于灵活的题目还缺乏分析的能力。平时做的几何题也较少，经验较匮乏。</p><p><strong>数据结构</strong>：非常薄弱，许多模型都不甚了解。</p><p>总而言之，我并没有特别突出的强项，各个专题的能力差距不大，但对于数据结构和字符串还相当不擅长。</p><h1 id="出题总结"><a href="#出题总结" class="headerlink" title="出题总结"></a>出题总结</h1><p>这次出题还是比较顺利的，看得出来学长们经验相当丰富。一开始是大家各抛出一些idea，我想个了密码题，主要是思路题，但也有细节要处理，也要关注特判。抛完idea的第二天开始讨论，早上大家把自己的题大致说了一说，然后邓老板决定签到题、简单题、中档题的比例与题目的去留。</p><p>我在ICPC上与同学的交流还不是很多，于是听他们开会时有懵逼的感觉，很慌的感觉。大家都是简单讲一下破题的要点，涉及的算法，然后就没然后了。所以看着那些题而一点想法都没有的我颇有格格不入之感。虽然Odious Number看看没想法，但还是接下了邓老板的锅，把这题的题面、数据、标程搞掉。中午想了个dfs的做法，很麻烦，还要大数，用python写慢得离谱。之后观察了一下表中的数，猜出了一个结论，用C重写了一遍。这样出数据和标称的锅便可以拿下了。</p><p>之后又把题目从十六进制的输入输出，还有伪高精的数据范围，改成long long了，这样来放过更多的做法，让题目更签一些。</p><p>顺便也写了一写题解，帮D题审核题面，这是其他的工作。</p><p>感受的话，感觉大家都挺认真负责，出题的流程清楚明白很有可行性，各自的锅也能在ddl前赶完。</p><p>也从这次出题中理解了一些出题人的苦衷，明白比赛过程中为何频频会有announcement了。出题目不易呀……</p><h1 id="其他感想"><a href="#其他感想" class="headerlink" title="其他感想"></a>其他感想</h1><p>听讲座听得十脸懵逼，听着听着就会想睡，感觉思维有些跟不上主讲者的节奏。（听题解也是这样的）知识体系还太薄弱了。这样学得又累，收益又不大，心态又受挫，有些得不偿失的感觉？</p><p>集训的感受……感觉进步不是很大，在思维上的提升还不够显著，没能学到大家看待问题分析问题的思想。平时对题目的畏惧感也没有减轻，看题看题解看着看着就开始神游天外，或水手机，或睡觉……感觉自己还是曾经的自己，能力只线性地提升了一点点，学了些新知识，但对其的理解还不够深，无法举一反三。大家是怎么学习的呢？还没有观察出结论。</p><p>打比赛比较随缘，这不是恶补一下就能改变结果的，所以还是调好心态比较重要。赛后补题没有很紧迫地去做，因为有些心累。有时候会出现意志力下降的情况……这是比能力问题更严重的问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;（虽然是写给颜学长的作业，但感觉还是写出了些东西的，就把这篇放上来了。dl们轻喷鸭qwq）&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="https://nessoffice.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【数学之美】复变函数与拉普拉斯变换-金忆丹版：第一章 预备知识</title>
    <link href="https://nessoffice.github.io/2019/06/29/Notes-Complex_Function-CH01/"/>
    <id>https://nessoffice.github.io/2019/06/29/Notes-Complex_Function-CH01/</id>
    <published>2019-06-29T13:22:58.000Z</published>
    <updated>2019-06-29T14:06:16.836Z</updated>
    
    <content type="html"><![CDATA[<p>学复变函数嘛……首先不能不了解一下复数，复数的概念，复数的运算，复数与平面的关系，差不多了。</p><a id="more"></a><h1 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h1><p>一般来说，复数有三种表示：$x + y i, r(cos \theta + sin \theta i), re^{i \theta}$。三种表示各有其适用范围，前两者分别对应平面直角坐标系与极坐标系，而最后的表示法与极坐标系的表示有共同点也略有区别，一般来说它在运算上最为方便。</p><p>复数的模和辐角本身是独立的刻画复数的单元，故我们可以将二者分离来看。模是对于距离的刻画，很好理解，与模相关的知识要点则多和不等式相连结。至于辐角（$Arg z$与$arg z$），则要规定其范围。这样便可在$x + y i, r(cos \theta + sin \theta i)$两种表示间相互转化。（求辐角的规则有些麻烦，结合实例，比如$\pm 2 \pm 3i$感受更佳）</p><p>三种表示的共轭均非常简单，而能解决许多问题，降低运算复杂度。共轭的概念虽简单，但要灵活运用并不容易。另外，用共轭可以分离实部与虚部。</p><p>需要注意的是，复数更接近向量而非一般意义上的实数，是不可比的。复数集并非偏序集。</p><p>正如我们可以用实数刻画数轴一般，我们也能用复数（向量）来刻画坐标面。这便是复平面，在第三小节中将对其作进一步的探讨。</p><h1 id="复数运算"><a href="#复数运算" class="headerlink" title="复数运算"></a>复数运算</h1><p>将复数视作向量（即用$z = x + yi$看待复数），则加法同乘法非常好进行。至于除法，自然可以硬算，但是考虑$z \cdot \overline{z} = |z|^2$从而推出$z^{-1} = \dfrac{\overline{z} }{|z|^2}$显然更加优美，在计算上也更方便。</p><p>乘积的意义为何呢？在形式上，$z_1 = r_1 e^{i \theta_1}, z_2 = r_2 e^{i \theta_2}$，故而$z_1 z_2 = r_1 r_2 e^{i (\theta_1 + \theta_2)}$。考虑e的指数的意义，则能发现$Arg(z_1 z_2) = Arg(z_1) + Arg(z_2)$。故乘法的意义即旋转。</p><p>在这个意义下，除法作为乘法的逆运算，其意义也与上面相类似。</p><p>复数的乘幂和开方也是需要讨论的话题，比如求-1的四次方根，需要用到开方，而在此之前要先对乘幂有所了解。乘幂的形式，即$z = r e^{i \theta} \rightarrow z^n = r^n e^{i n \theta}$。</p><p>由这一式子可以引出de Moivre公式：，$r^n (cos \theta + i sin \theta)^n = r^n (cos n \theta + i sin n \theta)$，故有$(cos \theta + i sin \theta)^n = cos n \theta + i sin n \theta$，此即de Moivre公式（自然，它可以根据其他方式推出，不过这里我们实际上是是采用欧拉公式来推的）。</p><p>至于开方，经过推导，可以得到n个相异的根，其中第k个根$w_k = \sqrt[n] r  e^{i \frac{\theta_0 + 2k \pi}{n} }, k = 0, 1, 2, \dots, n-1$。把这些根放到复平面上看或可加深对其的理解，对复数乘积的理解。</p><h1 id="点集与复球面"><a href="#点集与复球面" class="headerlink" title="点集与复球面"></a>点集与复球面</h1><p>点集系函数定义域与值域的本质属性。在直角坐标面上，我们定义过点集。类似地，此处我们可以通过复数对其加以定义，只消将$\rho$替换为$|z|$即可。由此我们先后定义了邻域，内点，边界，有界/无界区域，曲线，单/复连通区域。</p><p>图形也可以用复数表示，如$|z - z_0| \leq R$表示一个圆域。在辐角、距离上加以限制，我们不难得到几类简单图形的复数表示。</p><p>（复球面详见书本，没图不好描述）</p><p>复球面的中心思想是将平面上的点与球面上的点做一一映射，从而将虚无缥缈的无穷远点转化为了看得见摸得着的北极点。可以用用$tan \theta$与实数轴间的一一映射与之作类比。</p><h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><p>①de Moivre公式的运用：用$cos \theta$与$\sin \theta$表示$cos 3 \theta$。（手算的复杂度为$O(n^2)$）</p><p>②共轭与模：或者$|z| = 1$或者$|w| = 1$，证明$|\dfrac{z - w}{1 - \overline{z} w}| = 1$。</p><p>③（瞎搞）若复数$z_1, z_2, z_3$满足$\dfrac{z_2 - z_1}{z_3 - z_2} = \dfrac{z_1 - z_3}{z_2 - z_3}$，证明$|z_2 - z_1| = |z_3 - z_1| = |z_2 - z_3|$。</p><p>④复数与多项式间的联系：若$w$为1的一个n次方根，证明$1 + w + w^2 + \dots + w^{n-1} = 0$。</p><p>⑤复数与不等式：证明在闭单位圆盘$D = \{ z \big| |z| \leq 1 \}$上，$|z^2 + 1| \leq 2$。</p><p>⑥数形结合：将$(1 + cos \theta) + i sin \theta$表示为指数形式。</p><p>⑦共轭：证明$\overline{(\dfrac{z_1}{z_2})} = \dfrac{\overline{z_1} }{\overline{z_2} }(z_2 \not = 0)$。</p><p>⑧共轭：证明实系数多项式$P(z) = a_0 + a_1 z + \dots + a_n z^n$若有一根为$z$，则$\overline{z}$也必为其根。</p><p>⑨复数与不等式（不会做）：$z_1, z_2$为复数，证明$|z_1 - z_2|^2 + |z_1 + z_2|^2 = 2(|z_1|^2 + |z_2|^2)$。</p><p>以上数题中，③不知其考点，⑨尚不会做，其他的题目较为灵活，知识点覆盖率也较高，结论也较有用，值得一做。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学复变函数嘛……首先不能不了解一下复数，复数的概念，复数的运算，复数与平面的关系，差不多了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="课程笔记" scheme="https://nessoffice.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数学_分析" scheme="https://nessoffice.github.io/tags/%E6%95%B0%E5%AD%A6-%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>【图灵之路】CF记-其三（2019-07-18更新）</title>
    <link href="https://nessoffice.github.io/2019/06/29/ICPC-Practice_Codeforces_3/"/>
    <id>https://nessoffice.github.io/2019/06/29/ICPC-Practice_Codeforces_3/</id>
    <published>2019-06-29T11:53:40.000Z</published>
    <updated>2019-07-18T05:06:47.786Z</updated>
    
    <content type="html"><![CDATA[<p>退役真快乐呀……</p><a id="more"></a><p>不知不觉，CF已经打了一个半个月。这一个半个月以来我收获了什么呢？我的rating能够反映出我认为我具备的实力了么？我题目补得，总结得怎么样呢？</p><h1 id="round-573-div2"><a href="#round-573-div2" class="headerlink" title="round #573 div2"></a>round #573 div2</h1><p>关键词：博弈，思维，模型转换，心态，其他能力</p><p>cjb他们参与出的<a href="https://codeforces.com/contest/1191" target="_blank" rel="noopener">题</a>，好难呀……其实并不难（第二套补完的题！），但我为何还是做不好呢？前面的题过的还是快的，但之后做得就比较糟糕了。一直卡在D这个博弈题上怎么想也想不出来，没有仔细看E和F。虽然E也是博弈题，过的人更少，但其实第二天看了看我还是比较有想法的。可能是看到翻硬币游戏就有点害怕不敢细想吧，不应该害怕的。F也没有仔细看，其实模型转化一下我也是能做出来的。做题之外的其他能力，良好的心态，自信与任性间的平衡，我还不够，需要提升呀。</p><p>DE两个博弈题均不套路，能够锻炼思维。F要先转换模型，我在比赛时这点做得还不够。F在转换模型后是问区间权值的问题，可以用树状数组处理。</p><h2 id="ABC"><a href="#ABC" class="headerlink" title="ABC"></a>ABC</h2><p>A题太水不讲，C题也就是个模拟，边界注意一下就好了。</p><p>B题是个模拟题，给你三张麻将牌，牌有数字也有花色。问至少还要拿几张牌（自己指定花色和数字）才能凑成一对“koutsu”或者“shuntsu”，前者是三张完全一样，后者是同花色，数字连续。</p><p>看上去用一堆if就能搞定？但如何保证if没有漏掉的呢？我是这么做的，把现有的三张牌按数字排序（这样判数字相差多少更方便），然后判是否它们构成了一对“koutsu”或者“shuntsu”。若无，再两两判，判是否有同花色同数字的牌，或者同花色数字连续（相差为1或2均可）。这样代码也比较清晰。</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>题意：有n堆石子，Alice和Bob轮流选一个有石子的堆，拿走一个。失败条件：当前没有堆有石子可拿，或者当前玩家拿完石子后出现两堆的石子数一样。（初始局面可出现若干堆石子数重复）</p><p>首先考虑这样的一种必败态：A在第一步会马上输掉。第一个条件就是00000……，我们看第二个条件，就是说A无论拿了哪个堆中的石子，剩下必然存在两堆满足其石子数相等。</p><p>简单想一想，如果初始局面中有两堆石子数一样，A必须要从中选一堆拿掉，不然必败。那么A从中拿掉了一个还必败的情况，就有一下四类情形。比如说第一堆和第二堆都是n个石子，那么第一步必败的情形有1）n=0；2）存在第三堆有n-1个石子；3）存在第三堆有n个石子；4）存在有第三堆和第四堆都有m个石子。这些特判并不难进行，在排序之后。</p><p>如果初始局面没有两堆石子数一样，那么A必败的状态是怎样的呢？必然是01234……证明也容易，考虑最小元即可。</p><p>如果初始局面不符合上述两类马上必败的条件，那么我们先忽视第二个失败条件，考虑A和B一直进行游戏后的“最终局面”。事实上，最终的局面必然是01234……的一种排列。为什么？因为最终局面中必然有0，若无，则游戏仍可继续进行。有了0，局面中必然有1，若无，则游戏仍可进行……数归证毕，虽然此处并未给出“最终局面”的定义。</p><p>最终局面的胜负是确定的，因为A和B采取最优策略，他们在局面可向合法局面转化时不会触发第二个失败条件。而如果用局面中的总石子数刻画一个局面的特征值，那么一种局面向另一种合法局面的转化必然使得特征值减一。故而，在特判以后可由初始局面的特征值和最终局面特征值之差的奇偶性判断初始局面为N位置抑或P位置。</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>题意：当前有n个硬币排成一列，给定其正反情况。Alice和Bob可以选择k个连续的硬币，把它们全翻成正面或全翻成反面。如果某玩家在进行操作后，所有硬币的正反性均一致，则其胜利。求A先手，A、B采取最优策略时A能胜利，必然失败，或是能够平局。</p><p>首先，题目有两种情形：游戏结束而不平局时硬币全为正面，或者全为反面。我们在下文中只考虑第一种情形，那么第二种怎么考虑呢？简单，把初始局面中所有硬币都翻转一下，把玩家的操作都翻转一下，就化归到第一种情形了。</p><p>考虑A在第一步能够胜利的情形，这很容易考虑：如果硬币中的0比较少，能够被k个1覆盖掉，也就是说最左边的0和最右边的0距离小于k，A就能马上胜利。我们用$lft[i]$表示i左侧（包括i点）最近的0所在的位置，用$rgt[i]$表示i右侧（包括i点）最近的0所在的位置。A能一步胜利的条件就是$lft[n] - rgt[1] \leq k-1$。</p><p>再考虑一下A在一步之后必然失败的情形，这要怎么处理呢？对A所有可能操作的位置进行判断。比如A把第3~k+2个位置的硬币全翻成0，那么只要判定第1~2个位置和第k+3~n个位置是否能被一段连续的1覆盖即可。这也可以用此前得到的$lft$和$rgt$数组处理。</p><p>如果A在走了一步，B也走了一步之后，局面还没有结束，那么剩下的局面必然是平局的。为什么呢？假设初始位置是N位置，但A走完一步局面还没有结束，那么B的位置是P位置。但是，B可以选择和A完全一致的操作，这样A的位置便成为P位置了。这和前面的假设矛盾！故，A走了一步B也走了一步局面还没结束的情形，必然就是平局。</p><p>以上程序涉及到一些细节没有说明，以代码的形式给出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> LL maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">2</span>][maxn];</span><br><span class="line"><span class="keyword">int</span> n, k, lft[<span class="number">2</span>][maxn], rgt[<span class="number">2</span>][maxn]; <span class="comment">// lft[1][] for the filpped situation</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++)</span><br><span class="line">        s[<span class="number">1</span>][i] = (<span class="number">1</span>^(s[<span class="number">0</span>][i]- <span class="string">'0'</span>)) + <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; maxn;i++)</span><br><span class="line">        rgt[<span class="number">0</span>][i] = rgt[<span class="number">1</span>][i] = len+<span class="number">1</span>; <span class="comment">// init the array "rgt" to avoid special judge</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> flip = <span class="number">0</span>;flip &lt; <span class="number">2</span>;flip++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ptrl = <span class="number">1</span>, ptrr = len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++)</span><br><span class="line">            <span class="keyword">if</span>(s[flip][i] == <span class="string">'0'</span>)</span><br><span class="line">                <span class="keyword">while</span>(ptrl &lt;= i)</span><br><span class="line">                    rgt[flip][ptrl++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">            <span class="keyword">if</span>(s[flip][i] == <span class="string">'0'</span>)</span><br><span class="line">                <span class="keyword">while</span>(ptrr &gt;= i)</span><br><span class="line">                    lft[flip][ptrr--] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(lft[<span class="number">0</span>][n] - rgt[<span class="number">0</span>][<span class="number">1</span>] &lt;= k - <span class="number">1</span> || lft[<span class="number">1</span>][n] - rgt[<span class="number">1</span>][<span class="number">1</span>] &lt;= k - <span class="number">1</span>) ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ans == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> lose = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> flip = <span class="number">0</span>;flip &lt; <span class="number">2</span>;flip++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n-k+<span class="number">1</span> &amp;&amp; lose;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(lft[flip][i<span class="number">-1</span>] &amp;&amp; rgt[flip][i+k] != len+<span class="number">1</span>) lose = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(lft[flip][n] - rgt[flip][i+k] &gt;= k) lose = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(lft[flip][i<span class="number">-1</span>] - rgt[flip][<span class="number">1</span>] &gt;= k) lose = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(lose) ans = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"tokitsukaze"</span>);</span><br><span class="line">    <span class="keyword">if</span>(ans == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"quailty"</span>);</span><br><span class="line">    <span class="keyword">if</span>(ans == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"once again"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><p>题意：平面上有n个点，其坐标给出。每次你可以在平面上圈定一个区域，区域由$x_1, x_2, y_b(x_1 &lt; x_2)$唯一确定，包含了满足$x_1 \leq x \leq x_2, y \leq y_b$条件的所有$(x, y)$。定义$S$为区域$R$中包含的题目中给出的点的集合。定义$R_1 \not = R_2 \Leftrightarrow S_1 \not = S_2$。询问不相等的区域有多少种（除去只包含空集的区域）。</p><p>区域是连续的，不好处理。与$R$相关联的$S$是离散的，相对好处理一些。怎么确定所有可能的$S$呢？我们从$S$中的元素来着手。注意到，y更小的元素被包含时，y更大的元素更可能被包含；而y更大的元素被包含时，y更小的元素可能不被包含。故而，我们可以根据y从大到小对每个点进行遍历。比如y最大的点有4个，忽视下方的点。那么这样可能的$S$有$4 \times 5/2=10$ 种。更一般地，如果“一行”中有k个点，那么可以生成 $k(k+1)/2$个集合。</p><p>至此，我们形成了一个朴素的解决问题的框架：把点按y从大到小遍历，把上一行的点压到下一行中，计算其对答案的贡献。写成伪代码，也就是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; set_of_x;</span><br><span class="line">sort(points, points+n, cmp);</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>, r;l &lt; n;l = r)</span><br><span class="line">&#123;</span><br><span class="line">    r = l;</span><br><span class="line">    <span class="keyword">while</span>(r &lt; n &amp;&amp; points[r].y == points[l].y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!set_of_x.count(points[r].x))</span><br><span class="line">        &#123;</span><br><span class="line">            set_of_x.add(points[r].x);</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += (<span class="number">1L</span>L*k*(k+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个思路看上去非常的正确，但我们要注意到它把上一行直接“压下来”，这个过程是对答案有影响的。比如考虑题目中给出了$(5, 6)(2, 3)(3, 3)$三个点。在处理到第二行的时候，$k=3, k(k+1)/2=6$。但是这6个集合中有与前面枚举的集合重复的！$\{ (5, 6) \}$。</p><p>所以我们不能这么直接粗暴地把上面的行压下来，而是要注意到，枚举这一行的时候，这一行的元素必然要在集合中。故而可以用集合的差去做：要把这行中计算出来的，仅由上面的行的元素所构成的集合减去。</p><p>而这要怎么进行呢？我们再把points按x进行排序，那么，如果一行中的$p_1, p_2$中间夹了一些上一行的点，那么这些点构成的集合要减去，而且只要把它们减掉就能得出答案！这不难证明。（当然，还要关注在此一行最右边的点右上角的点）</p><p>于是，我们需要计算$x_{p_1}$和$x_{p_2}$中夹杂了多少上一行中的点。这要怎么做呢？我们可以把所有x值先离散化，然后用树状数组记录权值（每个点出现与否）前缀和来做。</p><p>上代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span><span class="keyword">int</span> x, y;&#125;nodes[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node&amp; lhs, <span class="keyword">const</span> Node&amp; rhs)</span></span>&#123;<span class="keyword">return</span> lhs.y &gt; rhs.y || (lhs.y == rhs.y &amp;&amp; lhs.x &lt; rhs.x);&#125;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; set_of_x;</span><br><span class="line"><span class="keyword">int</span> x_unique[maxn], n, n_unique;</span><br><span class="line"><span class="keyword">int</span> tree[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;<span class="keyword">return</span> num&amp;(-num);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> begin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = begin;i &lt;= n_unique;i += lowbit(i))</span><br><span class="line">        tree[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> begin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = begin;i &gt; <span class="number">0</span>;i -= lowbit(i))</span><br><span class="line">        ans += tree[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;nodes[i].x, &amp;nodes[i].y);</span><br><span class="line">        x_unique[i] = nodes[i].x;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(x_unique+<span class="number">1</span>, x_unique+n+<span class="number">1</span>);</span><br><span class="line">    n_unique = unique(x_unique+<span class="number">1</span>, x_unique+n+<span class="number">1</span>)-x_unique<span class="number">-1</span>;</span><br><span class="line">    sort(nodes+<span class="number">1</span>, nodes+n+<span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">int</span> sz = <span class="number">0</span>, sz_lst = <span class="number">0</span>;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>, r;l &lt;= n;l = r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x_lst = <span class="number">0</span>, x_now;</span><br><span class="line">        r = l;</span><br><span class="line">        <span class="keyword">while</span>(r &lt;= n &amp;&amp; nodes[r].y == nodes[l].y)</span><br><span class="line">        &#123;</span><br><span class="line">            x_now = lower_bound(x_unique+<span class="number">1</span>, x_unique+n_unique+<span class="number">1</span>, nodes[r].x) - x_unique;</span><br><span class="line">            <span class="keyword">if</span>(!set_of_x.count(x_now))</span><br><span class="line">            &#123;</span><br><span class="line">                set_of_x[x_now] = <span class="number">1</span>;</span><br><span class="line">                add(x_now);</span><br><span class="line">                sz++;</span><br><span class="line">            &#125;</span><br><span class="line">            sz_lst = query(x_now<span class="number">-1</span>) - query(x_lst); <span class="comment">// x_now-1, not x_now</span></span><br><span class="line">            ans -= (<span class="number">1L</span>L*sz_lst*(sz_lst+<span class="number">1</span>)/<span class="number">2</span>); <span class="comment">// sz_lst for the number of points between x_p1 and x_p2</span></span><br><span class="line">            x_lst = x_now;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        x_now = n_unique;</span><br><span class="line">        sz_lst = query(x_now) - query(x_lst); <span class="comment">// don't forget this term</span></span><br><span class="line">        ans -= (<span class="number">1L</span>L*sz_lst*(sz_lst+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">        ans += (<span class="number">1L</span>L*sz*(sz+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="edu-round-68-div2"><a href="#edu-round-68-div2" class="headerlink" title="edu round #68 div2"></a>edu round #68 div2</h1><p>关键词：审题，树状数组归纳，扫描线</p><p>比较水的<a href="https://codeforces.com/contest/1194" target="_blank" rel="noopener">一场</a>，虽说如此rating也没涨多少，一个月才入蓝的辣鸡在此。</p><p>A题数归易证答案为2x。但答案真的是2x吗？应该加入特判：printf(“%lld”, min(2*x, n))。</p><p>C题模拟不谈，瞎搞就好了。（下次变量名不能再叫ptr_s, ptr_t了，敲得慢不说，还易混淆）</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>题意：麻烦，不想复述了。</p><p>这个鬼题目卡到比赛结束才卡出来。第i行若有$cnt_{r, i}$个点，第j列若有$cnt_{c, j}$个点。如果i行j列没交点，答案为$(n - cnt_{c, j}) + (m - cnt_{r, i}) - 1$。如果i行j列没交点，把最后的-1去掉。想这个东西想了半天，碰到边界就捉急，思路混乱的很。我应当清晰哪个是变量哪个是不变量，确定$cnt_{r, i}$和$cnt_{c, j}$不变再来结合有交点/没交点的具体例子看什么时候要-1什么时候不-1的。变量名的意义也要和草稿上的一样才行呀。</p><p>观察数据范围，$n, m$不确定，但$nm$是较小的。所以可以用$vector<char>$来存图。然后预处理$cnt_{r, i}$和$cnt_{c, j}$。一个点一个点扫过去，动态更新答案，这题就没了。</char></p><p>我一开始没有注意到$nm$是小量，以为图存不下，要在线处理。在线该怎么做呢？容易想到要保存$cnt_{r, i}$最大的这行$i_{max}$的信息。这是可以线性扫描得到的。得到了这行的信息，再考察所有$cnt_{c, j}$最大的$j_{max}$列（不一定一列）。因为i行j列没交点答案更优，所以找到没交点的就不必再找了。</p><p>但问题是，$cnt_{r, i}$最大的不一定只有一行，如果有多行怎么办呢？我的办法是把多行的有效信息都压进一行里：我们需要的信息是什么？也就是没有交点的格子。于是可以这般维护最大行的信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(rows[i] == rows[i_max])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)</span><br><span class="line">        <span class="keyword">if</span>(grids[j] == <span class="string">'.'</span>)</span><br><span class="line">            grids_max[j] = grids[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码是正确的，但是还要考虑其他杂七杂八的东西，写起来很麻烦，也容易出错。我一开始grids_max没有初始化，就出锅了。这样的代码也只能节省空间，对于全为$*$的那种图，时间复杂度完全没有降下去。不过个人觉得这个思路还是有一定价值的。</p><h2 id="D-1"><a href="#D-1" class="headerlink" title="D"></a>D</h2><p>题意：当前有n个石子，Alice和Bob先后轮流取石子，无法取者输。一次取的石子数只能是1，2，k。k由题目给定。</p><p>简单的博弈题，需要眼力。</p><p>通过k=4，k=5等情形时候的模拟，我们首先能够观察出来$k \not \equiv 0 (mod 3)$时这个跳k步是完全没有价值的，游戏等价于只能跳1步2步。证明？按n模3的情形分类，慢慢数归即可。</p><p>接下来思考$k \equiv 0(mod 3)$会怎么样。通过对k=3，k=6等情形时候的模拟，我们有理由猜想当前循环节为k+1。证明？按n模k+1的情形分类，慢慢数归即可。</p><p>所以这么漂亮的游戏是怎么构造出来的呢？</p><h2 id="E-1"><a href="#E-1" class="headerlink" title="E"></a>E</h2><p>脑子题，套不套路不清楚，起码之前自己是不会的。每每碰到这种模型便有慌里慌张的感觉，需要归纳总结。上次做到的略有相似的题是哪道呢……</p><p>（扫描线？知识盲区+1，学习ing）</p><p>题意：给定一些水平的线段和竖直的线段，求这些线段围成的图形中有多少个矩形。线段数、坐标点绝对值均$\leq 5000$。</p><p>首先，这是个枚举题，直接枚举两条水平的两条竖直的复杂度显然爆炸，得加速。问题在要如何加速呢？</p><p>一个$O(n^3)$的做法是对每条水平的线段求出与其相交的竖直线段的集合，扔到bitset里。然后枚举一对水平的线段，找与两者均相交的竖直线段的条数。这样的做法可以卡过去，也不知道为什么，比较玄学，菜鸡的我不会分析。</p><p>正常的解法是$O(n^2 logn)$的，和这个数据范围也很搭。我们先来把问题简化一下：如果竖直的线段是无限长的，那么我们若是枚举一对水平线段，便可以求两条水平线段的公共线段$[l, r]$。可以用树状数组在$O(logn)$的时间求出与之相交的竖直线段条数。这是一个（经典的？）子问题。</p><p>但现在竖直的线段不是无限长的，它要满足一定的约束条件：和我们枚举的两条水平线段在y轴上的投影均有交。这样的话，我们便不能预处理出树状数组了，而是要动态地更新。如何操作呢？把水平线段按y升序排序，每次枚举一对水平线段会得到$[y_1, y_2]$的一个区间，其中竖直线段必须要包含这个区间。根据这个需求，我们又可以将竖直线段按y2升序排序……下面的内容繁而不难，用文字较难表达出来，笔者便不再说明了，详见代码。这题最重要的是先要想到枚举的顺序，然后是看出树状数组能够处理这一问题，最后才是考虑各式各样的细节。</p><p>（对了，使用树状数组先要把坐标都转化为正值）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span><span class="keyword">int</span> x1, y1, x2, y2;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_by_y</span><span class="params">(<span class="keyword">const</span> Node&amp; lhs, <span class="keyword">const</span> Node&amp; rhs)</span></span>&#123;<span class="keyword">return</span> lhs.y2 &lt; rhs.y2;&#125; <span class="comment">// both for vert and hori</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; hori, vert;</span><br><span class="line"><span class="keyword">int</span> tree[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;<span class="keyword">return</span> num&amp;(-num);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> begin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = begin;i &lt; maxn;i += lowbit(i))</span><br><span class="line">        tree[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> begin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = begin;i &gt; <span class="number">0</span>;i -= lowbit(i))</span><br><span class="line">        ans += tree[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x1, x2, y1, y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">        x1 += <span class="number">5001</span>, y1 += <span class="number">5001</span>, x2 += <span class="number">5001</span>, y2 += <span class="number">5001</span>;</span><br><span class="line">        <span class="keyword">if</span>(x1 &gt; x2) swap(x1, x2);</span><br><span class="line">        <span class="keyword">if</span>(y1 &gt; y2) swap(y1, y2);</span><br><span class="line">        Node node = (Node)&#123;x1, y1, x2, y2&#125;;</span><br><span class="line">        <span class="keyword">if</span>(x1 == x2) vert.push_back(node);</span><br><span class="line">        <span class="keyword">if</span>(y1 == y2) hori.push_back(node);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(hori.begin(), hori.end(), cmp_by_y);</span><br><span class="line">    sort(vert.begin(), vert.end(), cmp_by_y);</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, sz1 = hori.size(), sz2 = vert.size();i &lt; sz1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(tree, <span class="number">0</span>, <span class="keyword">sizeof</span>(tree));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i2 = sz1<span class="number">-1</span>, j = sz2<span class="number">-1</span>;i2 &gt; i;i2--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; vert[j].y2 &gt;= hori[i2].y1)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(vert[j].y2 &gt;= hori[i].y1 &amp;&amp; vert[j].y1 &lt;= hori[i].y1)</span><br><span class="line">                    add(vert[j].x1);</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> l = max(hori[i].x1, hori[i2].x1), r = min(hori[i].x2, hori[i2].x2);</span><br><span class="line">            <span class="keyword">if</span>(l<span class="number">-1</span> &lt; r)</span><br><span class="line">            &#123;</span><br><span class="line">                LL num = query(r) - query(l<span class="number">-1</span>);</span><br><span class="line">                ans += (num*(num<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="round-574-div2"><a href="#round-574-div2" class="headerlink" title="round #574 div2"></a>round #574 div2</h1><p>感觉<a href="https://codeforces.com/contest/1195" target="_blank" rel="noopener">这场</a>的题都非常毒，题面不太好理解，看题面能看个半天。但为何大家还是过得这么快呢orz……</p><p>A题题意不太理解，稀里糊涂搞出来的……B题是个解方程没啥好讲的，怕sqrt出锅于是加了个误差检测但似乎并没必要？C题为啥也这么多人做出来呀orz……D题也是……碰到相性不佳的一场真是尴尬呀。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>题意：有2n个数，排成两行，每行n个。让你从中任取若干数，使得其总和最大，并且没有两个数在同一列。</p><p>本来以为两条对角线比一比就好了，没有想到这样的情况，思维不够缜密：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9 1 1</span><br><span class="line">1 1 10</span><br></pre></td></tr></table></figure><p>嗯……那我们来dp吧。考虑$dp[0][i]$是选取第i列上面元素时前i列的最大值，$dp[1][i]$是选取第i列下面元素时前i列的最大值。那么略加思索，我们可以列出这个式子：</p><p>$dp[0][i] = h[0][i] + min(dp[1][i-1], dp[1][i-2])$</p><p>为什么这样就可以了呢？数归一下或许就能理解吧……</p><h2 id="D-2"><a href="#D-2" class="headerlink" title="D"></a>D</h2><p>（鸽）</p><h2 id="E-2"><a href="#E-2" class="headerlink" title="E"></a>E</h2><p>题意：给定$n \times m$的矩阵，每个格子上面有数。让你求所有$a \times b$的子矩阵中最小值的和。（鬼题意看了好久才看明白……我英语太差了）</p><p>我们能否先处理出每个$a \times 1$的子矩阵的最小值，把它压成一个数，然后求这b个数所组成的新的$1 \times b$的子矩阵的最小值呢？这样就变成了RMQ问题了？不过是RMQ套RMQ而已。复杂度$O(n^2 logn)$。</p><hr><p>初稿写于2019.06.04</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;退役真快乐呀……&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="https://nessoffice.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【图灵之路】CF记-其二（2019-06-29更新）</title>
    <link href="https://nessoffice.github.io/2019/06/29/ICPC-Practice_Codeforces_2/"/>
    <id>https://nessoffice.github.io/2019/06/29/ICPC-Practice_Codeforces_2/</id>
    <published>2019-06-29T11:53:38.000Z</published>
    <updated>2019-07-16T14:25:58.688Z</updated>
    
    <content type="html"><![CDATA[<p>下分真快乐呀……</p><a id="more"></a><h1 id="round-567-div2"><a href="#round-567-div2" class="headerlink" title="round #567 div2"></a>round #567 div2</h1><p><a href="https://codeforces.com/contest/1181" target="_blank" rel="noopener">戳我做题</a></p><p>（总算，分又升回来了。虽然还是刚进来的水平……）</p><p>A题是个还不错的签到题，让我想了一小会。对于第二问，在模的意义下思考可能更容易想。</p><p>B题……见着大数就烦。思路很简单，但是代码并不容易写。把数位的存储顺序弄乱了，捣鼓了半个多钟头。之后用python又写了一遍，还是python优雅呀。</p><p>C题当时看着有些烦，不过想了想感觉还是能做的。分析的思路就是从分析width=1的flag要满足什么条件，再到分析flag的width更长时答案怎么算。简单的预处理即可。</p><p>然后要注意这题的一个大坑点……预处理完一段颜色的len中，得到可能的flag中每段的长度为len1, len2, len3，注意构成flag的条件是len1==len2&amp;&amp;len3&gt;=len2而非len1==len2==len3！为什么？因为最后一段不需要完整。</p><p>（不会做，D题鸽）</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>这题的代码不难（easy version），但并不好想，或许可以锻炼思维能力吧。</p><p>思考一下题目中怎样能把两个territory merge在一起呢？就是它们要有一条公共边，横或纵。我们把只包含一个castle的territory或是由多个按上述规则merge而来的territory称为good。那么，如果一个大的territory能够通过一条横/纵的边分为两个good territory，则这个territory则good……</p><h1 id="round-568-div2"><a href="#round-568-div2" class="headerlink" title="round #568 div2"></a>round #568 div2</h1><p><a href="https://codeforces.com/contest/1185" target="_blank" rel="noopener">戳我做题</a></p><p>A排序一下，然后容易证明左右两点向外扩展能够得到最优解。</p><p>B的话原文中的一个字母可以得到若干位相同的字母，于是可以把同一类的原文划为一组……</p><p>C是贪心的思路，首先把占时长的人都筛掉。于是我一开始就维护了两个堆，一个大顶堆一个小顶堆，两个堆之间元素换来换去，于是就T了……连总时长大于M的情况都没筛。</p><p>但是根据此题的特点，$0 &lt; t_i \leq 100$，直接遍历即可，根本不需要维护堆。而且这样和桶排的思想也很类似，怪我没想到桶排咯……</p><p>D这题略恶心，因为有个干扰项，如何把这个干扰项去掉呢？我们关注公差d。如果d是a0，a1的距离，那么下面的判断就很方便了。如果不是，要么a0是干扰项，要么a1是干扰项，特判一下后面的距离是否均为d即可。</p><p>特判完后得到d为a0a1距离，怎么找出干扰项ak呢？注意到，$a_{k-1}a_k \not = d$，然后就好啦。注意一下细节。</p><h2 id="E-1"><a href="#E-1" class="headerlink" title="E"></a>E</h2><p>题意是给定一个矩阵，每次可以在上面画一条蛇，也就是任取一块$1 \times c$或是$r \times 1$的区域标上字母：a, b, c…画蛇是没有限制的，也就是可以在有字母的区域上标上新的字母。然后给定一张已经按照a, b, c…顺序画出蛇来的矩阵，问能否从中反推出每次画的蛇的坐标（r1, c1, r2, c2）。</p><p>考虑反推的思路，看矩阵中最大的元素，比如说，’d’。它必得连续地占据一行或是一列，如不然，矛盾。那么，如何判断它是否连续地占据了一行呢？首先，它必然只占了一列。于是，可以设col_occupied[maxn]和num_of_col_occupied来判断它占了几列，占了哪几列。如果它只占了一列，那么可以再遍历出它在这一列中row最小的行r1与row最大的行r2（这也正是所需输出的）。然后，从r1遍历至r2，即可判断’d’在此行中是否连续。</p><p>这样最大的元素可以确定了，那么第二大的元素，’c’怎么确定呢？不同于’d’在矩阵中出现的必然性（由’d’的最大性可得），’c’不一定会出现在矩阵中，因为它们可能都被’d’覆盖掉了，这样输出r1[‘c’] = r1[‘d’]即可。这是一种情况，至于’c’出现在矩阵中的情况，可以用类似判断’d’是否连续占据一行/一列的方法判断’c’是否只占据了一行/一列。</p><p>但是’c’不一定连续。因为比如’c’是横的，’d’是纵的，’d’可以覆盖部分的’c’。同时，我们在之前的操作中不能把’d’简单地替换为字母序更小的字母，这样很容易造成结果的错误。那么，如何处理呢？</p><p>比如说，’c’至占据了一列，其所出现的row最小的行行号r1，row最大的行行号r2。在[r1, r2]间出现了不是’c’的字母，有两种情况。第一种，无法从该矩阵中还原出蛇的画法。第二种，这个字母本来是’c’，但是被覆盖了。注意覆盖它的字母只能是字母序比它大的字母。</p><p>然后至于更小的字母，跟上面的处理方法是相似的。</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><p>考虑单个pizza，怎么判断它能否please多少人呢？比如ingredient为1，3，5，那么可以将这个pizza编码为一个price = price, bitinfo = 000010101, index = index的node，这样的node至多1&lt;&lt;9个，因为碰到bitinfo相同的pizza可以只取price更小的。bitinfo和pleasures的关系又如何呢？比如一个friend喜欢的ingredient可以编码为000000101。那么上面这个pizza就可以please他。两个pizza的话，考虑两个bitinfo取&amp;即可。</p><p>这样本来的枚举量是m^2，现在只是(1&lt;&lt;9)^2了，计算量少了好多呀！这都是bitinfo去重的功劳。虽然枚举量大大减小了，但怎么确定这种组和较另一种更优呢？首先是看pleasures的数目，这需要预处理每一种bitinfo所能please的人数，而这可以在读入每个人的时候处理</p><h1 id="round-569-div2-鸽"><a href="#round-569-div2-鸽" class="headerlink" title="round #569 div2(鸽)"></a>round #569 div2(鸽)</h1><p><a href="https://codeforces.com/contest/1180" target="_blank" rel="noopener">戳我做题</a></p><p>（第一套补完的题……留念）</p><p>A……嗯……很可爱，很纯真，在这样险恶的世界里是存活不了几分钟的……</p><p>B：给你一个数列{a}，可以把每位a[i]替换为-a[i]-1，问怎样替换能使得$\prod a_i$最大。</p><p>yy一下，负数的绝对值更大，所以负数越多越好。如果n为偶数，全部为负就好。n为奇数的话，至多保留一个正数，取绝对值最大的maxv还是最小的minv呢？（先把所有数都转为负数，方便讨论）把全部数乘一块，记作pi，把maxv转换为-maxv-1后|pi’| = |pi / maxv * (maxv-1)|，把这个式子和把minv转换的式子对比一下，带个值进去，就能发现转换maxv能得出更优解。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>给定双端队列，给定操作：将首位元素与第二位元素出队，将较大元插在队首，较小元插在队尾。问k次操作后队首前两个元素。</p><p>显然，队首元素单调不减，而最大元被垒到队首之后，操作等价于在把后n-1个元素形成的队列中的队首放到队尾，可以用模运算模拟。前面模拟的步数不超过n，用链表实现复杂度为$O(n)$。</p><p>P.S.deque真快，还不用特判，爱了爱了。</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>给你n*m的矩阵，你一开始在(1, 1)这个位置，每次可以用(dx, dy)跳一跳，比如(dx = 2, dy = 3)，就能从(1, 1)跳到(3, 4)了。每个(dx, dy)跳了一次就不能再跳了，比如你不能一直(-1, 0)这么跳。问你能否跳过所有点一遍。</p><p>找规律试试？考虑1*m的矩阵，怎么跳呢？因为不能一路(0, 1)，我们需要找到有规律的跳法。考虑$(1, 1) \rightarrow (1, m) \rightarrow (1, 2) \rightarrow (1, m-1) \rightarrow …$，这种跳法是可行的，它好在哪里呢？它对于一些难以用到的(dx, dy)的利用率高，一开始的$(0, m-1)$显然只能用一次，后面的也一样（其实是化归到子问题了，把(1, m)这样一个问题化归到(1, m-1)了，只是翻折了一下）。</p><p>于是对于n*m的矩阵我们也能遵循类似的跳法：$(1, 1) \rightarrow (n, m) \rightarrow (1, 2) \rightarrow (n, m-1) \rightarrow …$。（不过这样的话，每一步无法化归到子问题，只有遍历完两行后才算是化归到子问题）注意对奇偶分类讨论。</p><h2 id="E-2"><a href="#E-2" class="headerlink" title="E"></a>E</h2><p>有一个食堂，里面有n道菜，每道价格不一样，每道只有一样。有m个学生，各有bi块钱。学生买菜的策略是，总是买他买得起的最贵的菜。然后题目有q次询问，每次可以改变一道菜的价格或者一个学生的金钱数。问改变之后所有学生买完菜后，剩下的最贵的菜的编号。</p><p>（什么鬼食堂，每道菜只有一样，菜的价格还能差个几千几千的。学生也挺牛逼，每次只买一样菜。这很不社会主义啊。）</p><p>首先，题目中提到了学生是排着队买的，但通过yy我们能够知道，不论学生的顺序如何，他们全体买的菜都是那几样（个体在调整顺序后买到的菜可能会发生变化）。我们想想能否二分答案：从0-maxn中，最贵的还没有买的菜的价格是多少？这样的区间查询要怎么进行呢？我们可以搞个线段树，第i棵树上搞个标记，学生有i块钱就-1，存在有i块钱的菜就+1。如果标记&gt;0，就说明有菜剩着。这样进行区间修改也比较方便。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, q, a[maxn], b[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span><span class="keyword">int</span> l, r, v, lazy;&#125;tree[<span class="number">4</span>*maxv];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[index].l = l;</span><br><span class="line">    tree[index].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    build(index &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    build((index &lt;&lt; <span class="number">1</span>)+<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> target, <span class="keyword">int</span> mark)</span> <span class="comment">// mark == 1 ? meal : pupil</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[index].r &lt;= target)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[index].v += mark;</span><br><span class="line">        tree[index].lazy += mark;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    down(index);</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[index].l + tree[index].r) / <span class="number">2</span>;</span><br><span class="line">    change(index &lt;&lt; <span class="number">1</span>, target, mark);</span><br><span class="line">    <span class="keyword">if</span>(target &gt; mid)</span><br><span class="line">        change((index &lt;&lt; <span class="number">1</span>)+<span class="number">1</span>, target, mark);</span><br><span class="line">    tree[index].v = max(tree[index&lt;&lt;<span class="number">1</span>].v, tree[(index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>].v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(tree[index].l != tree[index].r)</span><br><span class="line">    &#123;</span><br><span class="line">        down(index);</span><br><span class="line">        <span class="keyword">if</span>(tree[(index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>].v &gt; <span class="number">0</span>)</span><br><span class="line">            index = (index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            index &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (tree[index].v &gt; <span class="number">0</span>) ? tree[index].l : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, maxv<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a+i);</span><br><span class="line">        change(<span class="number">1</span>, a[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, b+i);</span><br><span class="line">        change(<span class="number">1</span>, b[i], <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cmd, i2, x, *c, mark;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;cmd, &amp;i2, &amp;x);</span><br><span class="line">        c = (cmd == <span class="number">1</span>) ? a : b;</span><br><span class="line">        mark = (cmd == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        change(<span class="number">1</span>, *(c+i2), -mark);</span><br><span class="line">        *(c+i2) = x;</span><br><span class="line">        change(<span class="number">1</span>, *(c+i2), mark);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ask());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[index].l == tree[index].r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[index].lazy == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[index].l + tree[index].r) / <span class="number">2</span>;</span><br><span class="line">    change(index &lt;&lt; <span class="number">1</span>, mid, tree[index].lazy);</span><br><span class="line">    change((index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>, tree[index].r, tree[index].lazy);</span><br><span class="line">    tree[index].lazy = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="round-570-div3-鸽"><a href="#round-570-div3-鸽" class="headerlink" title="round #570 div3(鸽)"></a>round #570 div3(鸽)</h1><p><a href="https://codeforces.com/contest/1183" target="_blank" rel="noopener">戳我做题</a></p><p>（水题好多，在细节上处理地不是很好以致没有一发ac。不知假如参加的话能不能把E/H苟出来）</p><p>A：计算比给定数大的，最小的，满足各数位上的数之和模4余0的数。</p><p>这题注意一下数据范围，无需特判，枚举即可……</p><p>B：给定一个数列{a}还有一个数k，问能否将所有a[i]替换为b使得$|a_i - b| \leq k$。</p><p>开始想的是二分，但之后发现检测一下上界取不取得到就好了……</p><p>C：你有n格电，每次可以消耗a格并爽一爽或者可以消耗b格但不能爽，已知有k个回合，问你最多能爽几爽。</p><p>贪心地把尽可能多的B换成A就好了，不过要注意数据范围！int的话中间可能会溢出，这是个隐蔽的坑点。</p><p>D：你有若干种糖，每个个数不一。然后你要送礼，每种糖的个数不能一样，问你最多能送出多少糖。</p><p>用个map处理一下，一波遍历，就好惹（但在G上栽了，细节没考虑全？不是很想补……）。</p><p>F：给你n个数，让你选1个或2个或3个，使得选出来的数两两不能整除，求这1/2/3个数的和的最大值。</p><p>莫得思路（对剪枝的复杂度不太明白就没写，网友的思路看不懂）。</p><h2 id="E-H"><a href="#E-H" class="headerlink" title="E/H"></a>E/H</h2><p>题意可以理解为给定字符串，让你求它的长为n, n-1, n-2…的subsequence（不要求连续，比如’acd’是’abcd’的合法子串）有多少个（其实不需要求出全部，求出长为n, n-1, …直至k的子串数目就行了，这里的k不同于题目中的k）。</p><p>枚举组和再判重复杂度看上去大得可怕，我们考虑dp。令$dp[length][char]$表示长度为length，末尾字符为char的子串的数目（这样无法表示空字串，所以要记得特判）。这样就能递推了：顺序遍历给定字符串，读到一个新的字符ch时，若它在第k位，枚举$length = k \rightarrow 1, char = a \rightarrow z$即可。记得length得倒序遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LL ch_tail = str[i];</span><br><span class="line"><span class="keyword">for</span>(LL len = i<span class="number">-1</span>;len &gt;= <span class="number">1</span>;len--)</span><br><span class="line">&#123;</span><br><span class="line">dp[len+<span class="number">1</span>][ch_tail] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(LL ch = <span class="number">0</span>;ch &lt; <span class="number">26</span>;ch++)</span><br><span class="line">dp[len+<span class="number">1</span>][ch_tail] += dp[len][ch];</span><br><span class="line">&#125;</span><br><span class="line">dp[<span class="number">1</span>][ch_tail] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>需要说明的是，长为k的子串在数量级上与$C^k_n$较为接近，而题目中的n可大至100，这样k=50时dp不是会溢出吗？然而事实是上述代码能够ac。私以为，问题在于dp是通过加法递推得到的，可以看作计算机在运算时进行了模处理，这样中间虽然可能出现负数，但是在边界值上仍然是正确的。如果对此感到不放心，不妨对dp取模，这样更保险些。</p><h1 id="round-571-div2-鸽"><a href="#round-571-div2-鸽" class="headerlink" title="round #571 div2(鸽)"></a>round #571 div2(鸽)</h1><p><a href="https://codeforces.com/contest/1186" target="_blank" rel="noopener">戳我做题</a></p><p>（A是什么东西，现在签到题都这么送的吗？？？）</p><p>（B好像是个假题，把好多人坑惨了。幸好这场没打，复习雾理要紧。）</p><h2 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h2><p>给定bit string a与b，a比b长，问a有多少子串满足和b异或以后有偶数个1。（这里的子串必然是连续的，和b等长的。比如a = ‘001100’, b = ‘001’时a的子串仅有’001’, ‘011’, ‘110’, ‘100’四种，它们和b异或后分别为’001’, ‘010’, ‘111’, ‘101’，有偶数个1的仅有’101’一项。）</p><p>直接模拟的复杂度高达$O(n^2)$，稳超时。然后这个操作和线性反馈移位寄存器(LFRS)的操作好像有点像？我们考虑递推。比如a的子串从’001’变到’010’，第一个0变成0，和b第一位异或必然不变；第二位从0变到1，第三位从1变到0，异或后都发生改变。于是，从前一个状态变到后一个状态时异或和中1的个数的改变量即a的原子串满足，此位与下一位相异的位的位数。（有些抽象，拿上面的例子来看能更清晰地感受这种想法）于是可以通过前缀和记录从i位到i+len位中此一位与下一位相异的位的位数。O(n)。</p><p>（因为答案是询问模2余0的cnt个数，而非输出每个cnt，所以代码中的cnt只是与”真正的“cnt模2同余而非相等。）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> str1[maxn], str2[maxn];</span><br><span class="line"><span class="keyword">int</span> delta[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, str1, str2);</span><br><span class="line">    <span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(str1), len2 = <span class="built_in">strlen</span>(str2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len1;i++)</span><br><span class="line">        delta[i] = delta[i<span class="number">-1</span>] + (str1[i] != str1[i<span class="number">-1</span>] ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len2;i++)</span><br><span class="line">        <span class="keyword">if</span>(str1[i] != str2[i]) cnt++;</span><br><span class="line">    <span class="keyword">if</span>(cnt % <span class="number">2</span> == <span class="number">0</span>) ans++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len2;i &lt; len1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt += (delta[i] - delta[i-len2]);</span><br><span class="line">        <span class="keyword">if</span>(cnt % <span class="number">2</span> == <span class="number">0</span>) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过细节处理略麻烦：边界的处理，delta的意义（是第i位与i+1位的异同，还是第i位与第i-1位的异同？）。在手工演算的同时，可以通过调整input中的数据边界判断边界处理是否妥当。</p><h2 id="E-3"><a href="#E-3" class="headerlink" title="E"></a>E</h2><p>有点烦的题。给你一块地，比如说这样一块2×3的地：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">010</span><br><span class="line">110</span><br></pre></td></tr></table></figure><p>然后这块地可以拓展程这样一块(2×2)×(2×3)的地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">010 101</span><br><span class="line">110 001</span><br><span class="line">101 010</span><br><span class="line">001 110</span><br></pre></td></tr></table></figure><p>如果把原来的地记作A，那么拓展后的地就可以记作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A  A&apos;</span><br><span class="line">A&apos; A</span><br></pre></td></tr></table></figure><p>其中A’由与A同行同列全为1的矩阵和A异或得到。</p><p>地可以无限拓展。题目问的给定这样一个子矩阵，知道其左上角坐标，知道其右下角坐标，问子矩阵中1的个数有多少。</p><p>怎么做呢？考虑二维dp。如果能求出(1, 1)到(x, y)这样一个矩阵中1的个数，那(x1, y1)到(x2, y2)的矩阵自然也不在话下。因为题目中x, y高达1e9，所以打表显然不现实。我们能求出来的也就只有$dp[n][m]$这个量级，再大的要怎么算呢？</p><p>注意到，很大的一块地中包含了许多小地。如果能求出小地中1的个数和小地的数目，那也很方便算。而注意到所有经过了一次拓展得到的2n×2m的地中1的个数都是相同的，我们就把这样一块地记为一个基本单元，B，其逆为B’。比如说，x = 6n, y = 4m，那么它包含了3×2个这样的基本单元，不管是B还是B’，里头1的数目都是一样的，这样算出来就是$dp[2n][2m] <em> (6n / 2n) </em> (4m / 2m)$。</p><p>但是大的地不一定都是上面那样规整的，比如，x = 6n + 2，这要怎么办？通过画图我们能得知，这样在竖直方向多出来了一点点，得把它补上。y = 4n + 3也这样处理。x、y都不规整还会多出来一个小矩阵。但多出来每一块的究竟是B还是B’的一部分呢？这可以通过递归得到。比如从左往右数第5个基本单元，它是由第1个基本单元，也就是B’异或得到的，所以它是B。如此。总之细节处理比较麻烦，结合图片理解更佳。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e3</span>+<span class="number">5</span>; <span class="comment">// caution! the basic unit is 2n*2m</span></span><br><span class="line">LL n, m, q;</span><br><span class="line">LL sum[<span class="number">2</span>][maxn][maxn]; <span class="comment">// 0 for original matrix while 1 for inversed matrix</span></span><br><span class="line"><span class="function">LL <span class="title">get_flag</span><span class="params">(LL c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">0</span> || c == <span class="number">1</span>) <span class="keyword">return</span> c;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>^get_flag(c-(c&amp;-c));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(LL r, LL c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    ans += ((c/m)*(r/n)*sum[<span class="number">0</span>][n][m]); <span class="comment">// part 1</span></span><br><span class="line">    LL dc = c % m, dr = r % n;</span><br><span class="line">    LL flag_r = get_flag(r/n), flag_c = get_flag(c/m); <span class="comment">// r/n for the number of fields in the row</span></span><br><span class="line">    ans += ((r/n+<span class="number">1</span>)/<span class="number">2</span>)*(sum[flag_c][n][dc]); <span class="comment">// part 2: the vertical</span></span><br><span class="line">    ans += (r/n/<span class="number">2</span>)*(sum[<span class="number">1</span>^flag_c][n][dc]);</span><br><span class="line">    ans += ((c/m+<span class="number">1</span>)/<span class="number">2</span>)*(sum[flag_r][dr][m]); <span class="comment">// part 3: the horizontal</span></span><br><span class="line">    ans += (c/m/<span class="number">2</span>)*(sum[<span class="number">1</span>^flag_r][dr][m]);</span><br><span class="line">    ans += sum[flag_r^flag_c][dr][dc]; <span class="comment">// part 4</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> grids[maxn];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, grids+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(LL j = <span class="number">1</span>;j &lt;= m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[<span class="number">0</span>][i][j] = sum[<span class="number">0</span>][i+n][j+m] = (grids[j] - <span class="string">'0'</span>);</span><br><span class="line">            sum[<span class="number">0</span>][i+n][j] = sum[<span class="number">0</span>][i][j+m] = <span class="number">1</span>^(grids[j] - <span class="string">'0'</span>);</span><br><span class="line">            sum[<span class="number">1</span>][i][j] = sum[<span class="number">1</span>][i+n][j+m] = <span class="number">1</span>^(grids[j] - <span class="string">'0'</span>);</span><br><span class="line">            sum[<span class="number">1</span>][i+n][j] = sum[<span class="number">1</span>][i][j+m] = (grids[j] - <span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n *= <span class="number">2</span>, m *= <span class="number">2</span>; <span class="comment">// basic unit: 2n*2m</span></span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    <span class="keyword">for</span>(LL j = <span class="number">1</span>;j &lt;= m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[<span class="number">0</span>][i][j] += (sum[<span class="number">0</span>][i<span class="number">-1</span>][j] + sum[<span class="number">0</span>][i][j<span class="number">-1</span>] - sum[<span class="number">0</span>][i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">        sum[<span class="number">1</span>][i][j] += (sum[<span class="number">1</span>][i<span class="number">-1</span>][j] + sum[<span class="number">1</span>][i][j<span class="number">-1</span>] - sum[<span class="number">1</span>][i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        LL r1, r2, c1, c2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>, &amp;r1, &amp;c1, &amp;r2, &amp;c2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, calc(r2, c2) + calc(r1<span class="number">-1</span>, c1<span class="number">-1</span>) - calc(r1<span class="number">-1</span>, c2) - calc(r2, c1<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="edu-round-67-div2"><a href="#edu-round-67-div2" class="headerlink" title="edu round #67 div2"></a>edu round #67 div2</h1><p><a href="https://codeforces.com/contest/1187" target="_blank" rel="noopener">戳我做题</a></p><p>A：给定n个gift，每个包含或者一个A，或者一个B，或者一个A+一个B。现给出n、A、B的数目。问至多要取多少个gift才能保证取到的gift中必然既包含A也包含B。</p><p>看到这题没啥思路……其实考虑最坏情形就好了：连着取到的都是只有A或者只有B的gift。设第一类有a个，第二类有b个，第三类c个。那么输出min(a, b)+1就好了。有点抽屉原理的思想？</p><p>B：给定一个字符串s，比如说是arrayhead。然后有q个查询，每个查询问的是某个字符串t，比如说’aaa’，要原字符串的从头开始的符合条件的子串的最短长度，这个子串包含了s中的所有字符（计数），比如’aaa’的例子答案为8，子串为’arrayhea’。</p><p>容易发现，t中字符的顺序是无关紧要的，重要的信息只有它各个字符出现的次数。于是，我们可以依据某字符频率在原字符串中进行查询，这样的话要先对原字符串进行预处理，得到一个$place[cnt][char]$表示这样的子串的最短长度，其能够匹配频率为cnt的字符char。于是代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> place[maxn][<span class="number">26</span>], occurence[<span class="number">26</span>], cnt[<span class="number">26</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[maxn];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ch = s[i] - <span class="string">'a'</span>;</span><br><span class="line">        place[++occurence[ch]][ch] = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, temp);</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="built_in">strlen</span>(temp)<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ch = temp[i] - <span class="string">'a'</span>;</span><br><span class="line">            cnt[ch]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">26</span>;j++)</span><br><span class="line">            ans = max(ans, place[cnt[j]][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>初稿写于2019.06.04</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下分真快乐呀……&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="https://nessoffice.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【图灵之路】CF记-其一（2019-06-29更新）</title>
    <link href="https://nessoffice.github.io/2019/06/29/ICPC-Practice_Codeforces_1/"/>
    <id>https://nessoffice.github.io/2019/06/29/ICPC-Practice_Codeforces_1/</id>
    <published>2019-06-29T11:53:37.000Z</published>
    <updated>2019-07-16T14:26:10.886Z</updated>
    
    <content type="html"><![CDATA[<p>下分真快乐呀……</p><a id="more"></a><p>（听到颜学长说要看CF rating时我是懵逼的：啥？这是啥？从来没碰过……不过既然选了课也只能硬着头皮上了。打得手很生，rating维持在基础分上……感觉要凉要凉，不过我还能怎么做呢？补题补题，弥补那，相距天际的差距。</p><h1 id="round-563-div2"><a href="#round-563-div2" class="headerlink" title="round #563 div2"></a>round #563 div2</h1><p>第一次玩CF……好紧张……这网站注册五个月了就没登进去过……</p><p>随便写写关于题解的随想吧……</p><p><a href="https://codeforces.com/contest/1174" target="_blank" rel="noopener">戳我做题</a></p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>（分析题，分析出关键的性质就能做了）</p><p>（一开始把题目看错了，看成是模2同余才能交换，心想这不就分奇偶排下序就好了嘛……码完代码就被测试数据piapia打脸）</p><p>不是很有想法。如果所有数奇偶性都相同这个情况是容易考虑的。可如果有奇数也有偶数呢？先考虑1奇n偶的情况吧。1奇1偶肯定能有序，1奇2偶呢？这个要分类讨论了，我的想法是把最小的数先移到最前面，之后化归到规模更小的情形。但是这样有个问题，就是如果最小数是那个奇数，比方说，输入数据为1, 6, 4，貌似会出问题……1, 6, 4能不能排成1, 4, 6呢？瞎搞了一下发现可以，于是乎，发现了一个奇妙的性质：只要序列中有奇数也有偶数，那么通过一个奇数（它的位置不会改变），任意两个偶数间也能交换位置。于是排序就是可行的了。sort之。</p><p>（可还是不知道这题在考什么<del>，群论？</del>）</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>（还是分析题……）</p><p>题目中说，任意两个互素的数，其f值不相等。这个条件初看比较别扭，也比较抽象，还是先把它具象化吧。</p><p>如果是素数的话，它的f值肯定不能和其他素数的f值相等。于是我们令f(2)=1, f(3)=2, …</p><p>至于合数呢？由题意，f的最大值不能过大，我们看看合数的f值能否和素数相等，可令f(合数)=f(该合数的某素因子)，为方便计算，不妨再令f(合数)=f(该合数的最小素因子)，即f(某数)=f(该数的最小素因子)。这样能否满足题意呢？</p><p>可以的！假如两数互素，它们的最小素因子必不同，而f是由一个数的最小素因子决定的。</p><p>这样分析完，上个欧拉筛就完事了。</p><p><del>其实令f(某数)=f(该数的最大素因子)更好算，直接埃氏筛就搞出来了，可是我没想到\cry\cry\cry</del></p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>（前缀和呀前缀和，我怎么就把你忘了呢）</p><p>嗯……题意是让你求一个数列，使得其任意子列全部元素异或后不能和0或x相等，且数列长度尽量长，答案有多组，任意输出一组（还有个条件：所有元素均小于2^n）。比如，x=5时候{6, 1, 3}满足条件，因为它的子列有{6}{1}{3}{6, 1}{1, 3}{6, 1, 3}，异或后分别为6, 1, 3, 7, 2, 4，都不等于5。</p><p>当时被“子列”这个条件困扰了好久，也不知道怎么样让数列长度尽量长（我的想法是，任意新添加一个元素，都会引发矛盾，但是这样复杂度巨大……），一直在玄学思考子列能推出什么，发现如果在数组的中间取标记点，向两边扩展，能够完美匹配题目中的条件，但是这样在细节上很难处理……线性计算复杂度太高，二分也不见得简单。</p><p>看到题目中说前缀和（其实是前缀异或和，不过反正思想是这个思想，将二维的子列化为一维的数组，级数也是这个思想）后，恍然大悟：</p><p>$a_l \oplus a_{l+1} \oplus … \oplus a_r = b_{l-1} \oplus b_r$（$b_i = a_1 \oplus a_2 \oplus … \oplus a_i$，由异或运算的交换律和自反率知，该等式成立）</p><p>这样的话，就不用考虑$a_i$，考虑$b_i$所成的数列就好了呀，因为$a_i = b_{i-1} \oplus b_i$。那么$b_i$，要如何考虑呢？</p><p>由题意，$b_i \oplus b_j \not = 0$，这说明$b_i \not = b_j$（异或的逆元是且仅是本身），还有$b_i \oplus b_j \not = x$，只要保证$b_i \not = (x \oplus b_j)$就好了。于是可以设个vis数组，逐个确定$b_1, b_2, …$，比如$b_1$确定了，那么$vis[b_1] = vis[x \oplus b_1] = 1$，后面的$b_j$不能取$b_1$或是$x \oplus b_1$。</p><p>因为交换$b_i$和$b_j$不影响答案的正确性，所以$b_i$是可以任取的。为方便记，不妨从小到大遍历，发现$vis[k] = 0$则取$b_i = k$。从这个过程可以看出，算法的复杂度为$O(2^n)$。</p><p>从这里也可以看出{b}的长度了。把$i$和$x \oplus i$看作是一对，那么一对中只能取一个。所以$len(b)$=可用的数的数量/2。</p><p>但是还要注意一下细节，题目中的输入数据也提示了：$x \geq 2^n$的时候，无需把$i$和$x \oplus i$看作一对，因为后者根本取不到。这个情况下$len(b)$=可用的数数目。</p><p>（开始把题目的数据看错了，看到18，就想到long long在十进制下约为18位，于是感觉这样的vis开不下，没有进一步往下想。<del>开了vis又如何呢，还不是做不出来</del>）</p><p>手是生了啊。</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>（需要分析的，较为复杂的dp）</p><p>题意稍微有点绕，它提到了一个f(p)，定义略奇特，我们用直观的例子体会一下这个f是怎么算的。</p><p>比如给定排列{6, 2, 1, 3, 5, 7}，求它前i个数的最大公约数，排出来，就是{6, 2, 1, 1, 1, 1}。这里头有三个不同的数，于是$f(p)=3$。</p><p>{1, 2, 3, 4, 5, 6}除了上面那种排列外，还有其他排列，算出来的$f$不尽相同，但总归是有最大值的，记作$f_{max}$。题目问的就是，n-排列中，有多少种排列，算出来的$f$等于$f_{max}$呢？</p><p>我们来看看那个前缀最大公约数的数列，粗略一看，它似乎是单调不增的，这很好证明。再一看，发现$g_i$和$g_{i+1}$是有关系的（$g_i$即前缀最大公约数数组的第i项），就是$gcd(g_i, g_{i+1}) = g_{i+1}$。</p><p>要想$g_i$的取值尽可能多样，我们要让它减少地尽量缓慢。将排列的首项，$a_0$，素因子分解，我们发现，$f = \sum \alpha_i$（算数基本定理的简单应用）。所以$f_{max}$就是$\sum \alpha_i$最大时候的取值。这个是数论上的内容。结论如下：f取最大值时，$a_0 = 2^x \cdot 3^y$，且$y \leq 1$。</p><p>（证明的话，就是替换的思想。如果$a_0$中有其他素数，比如说，5，那么我们可以令$a^{‘}_0=2<em>2/5</em>a_0$，这样$a^{‘}_0$打头时候得出的f必然比$a_0$打头时候得出的要大。同理可以证明$a_0$中3的指数小于2）</p><p>发现了这个结论我们该怎么算答案呢……看看题，感觉要dp？那么怎么指定状态呢？<del>参考题解发现</del>令$dp[i][x][y]$表示排列到前i个数时，最大公约数为$2^x \cdot 3^y$这一状态可以让我们很方便地算出答案。因为每次添加一个数，所以都是$dp[i+1][][] = dp[i][][] + …$，而要取到$f_{max}$，x、y可以保持不变或是x—或是y—，总共三种状态转移的模式。在添加第i+1个数时候，要考虑只能添加取符合要求的数，不能取已经取到的数。归纳一下，也便如下（伪代码，不是AC代码；和$dp[i][x][y]$相乘的那个数就是符合条件的第i+1个数的个数了）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i+<span class="number">1</span>][x][y] = (dp[i+<span class="number">1</span>][x][y] + dp[i][x][y] * (cnt(x, y) - i));</span><br><span class="line">dp[i+<span class="number">1</span>][x<span class="number">-1</span>][y] = (dp[i+<span class="number">1</span>][x<span class="number">-1</span>][y] + dp[i][x][y] * (cnt(x<span class="number">-1</span>, y) - cnt(x, y)));</span><br><span class="line">dp[i+<span class="number">1</span>][x][y<span class="number">-1</span>] = (dp[i+<span class="number">1</span>][x][y<span class="number">-1</span>] + dp[i][x][y] * (cnt(x, y<span class="number">-1</span>) - cnt(x, y)));</span><br></pre></td></tr></table></figure><p>下面是本题的坑点了……</p><p>不能用long long保存数据，会MLE，要用int，但是这样运算时候有可能溢出，怎么办呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i+<span class="number">1</span>][x][y] = (dp[i+<span class="number">1</span>][x][y] + <span class="number">1L</span>L*dp[i][x][y] * (cnt(x, y) - i)) % MOD;</span><br></pre></td></tr></table></figure><p>注意那个1LL……上次校赛的题也是。</p><p>（最后交上去，2s的时限跑了1965ms，也太不好玩了吧！O(nlogn)不是很优雅了么！本来想用bfs稍微优化一下的，但还是懒得弄了……）</p><p>（又把数字看错了，2^18 &gt; 1e6我是怎么算出来的……）</p><p>F题还没补，先放放。（Idleness？）</p><h1 id="edu-round-66-div2"><a href="#edu-round-66-div2" class="headerlink" title="edu round #66 div2"></a>edu round #66 div2</h1><p>模拟题杀我……贪心杀我……</p><p>（为什么edu没有答案啊啊啊啊还有edu是什么意思它和div什么关系啊啊啊啊）</p><p><a href="https://codeforces.com/contest/1175" target="_blank" rel="noopener">戳我做题</a></p><h2 id="B-1"><a href="#B-1" class="headerlink" title="B"></a>B</h2><p>复杂的模拟题……看着很烦，思绪很乱。感觉是对的结果交上去WA了，再改改又WA了。一天后突然想到自己是哪里没想明白，这才AC。</p><p>模拟题很烦，看上去不能够考察能力，但其实是能的。它能考察心态，考察对于问题的分析能力。这些，是我还不够好的。</p><p>先来读题。输出比较简单，那就看输出。输出分溢出与否两种情形。然后溢出也分两类，一类是小数加加加加爆了，还有是循环循出超级大的数然后一加就加爆了。这两类有何区别呢？区别在于，第一类可以直接模拟，而第二类不能直接模拟，需要记录是在哪一层会加爆，然后如果“ADD”出现在这层以上，就置flag=1。</p><p>大致想明白了输出要怎么处理，接下来是看输入了。输入有三类：“ADD”“FOR x”“END”，ADD用以模拟相加（还要看会不会出现上面的第二类情况），for和end共同构成一个循环。根据输入，我们可以设置一个loop[maxn]记录每层for的次数，设置一个looping_now记录当前需要ADD的值，同时记录一个depth_now记录当亲啊层数，设置一个depth_overflow记录加爆了的层数（超过此层，looping_now不再更新）。</p><p>于是我们可以写出这样的伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, cmd, &amp;x);</span><br><span class="line">    <span class="keyword">if</span>(cmd == <span class="string">"ADD"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(depth_now &gt; depth_overflow) <span class="comment">// case 2</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        ans += looping_now;</span><br><span class="line">        <span class="keyword">if</span>(overflow(ans)) <span class="comment">// case 1</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cmd == <span class="string">"FOR"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(overflow(looping_now * x + ans))</span><br><span class="line">            depth_overflow = depth_now;</span><br><span class="line">        <span class="keyword">if</span>(depth_now &lt; depth_overflow)</span><br><span class="line">            looping_now *= x;</span><br><span class="line">        loop[depth_now++] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cmd == <span class="string">"END"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        depth_now--;</span><br><span class="line">        <span class="keyword">if</span>(depth_now &gt;= depth_overflow)</span><br><span class="line">            looping_now /= loop[depth_now];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后便是处理细节了……</p><h2 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h2><p>是个思路题，问的是给定n个x轴上的不同位置的整点，让你找一个整点$p_0$，使得$p_0$到距$p_0$第k近的点的距离，比任意$p_{random}$到距$p_{random}$第k近的点的距离，来得小。k由题目给出。</p><p>简单想想，k=1或k=2的情况很容易考虑，但是如何将其推广到k更大的情况呢？我们注意到一个事实，即沿着一个点向左走，它所后经过的点一定远于它所先经过的点，向右亦然，但是左点的远近与右点的远近间没有关联。</p><p>那么，对$p_0$而言，如果距它第k近的点$p_k$在其右侧，则距它第k-1近的点$p_{k-1}$可以在左侧也可以在右侧。若在右侧，则可以把$p_0$向右移动一位，容易看出，此时$p_k$仍然为距$p_0$第k远的点（证明的话，反证）。于是我们可以重复此操作，直至$p_{k-1}$转移到$p_0$的左侧为止。</p><p>于是这样一来，我们得到$p_0$是被包围在$p_{k-1}$与$p_k$间的一点。让我们忽视$p_1, p_2, …, p_{k-1}$，因为既然它们同在这个“包围圈”中，那么$p_0$在这个“包围圈”中移动到$p_0^{‘}$位置时，这k-2个点的某个排列必然构成$p_1^{‘}, p_2^{‘}, …, p_{k-2}^{‘}$。</p><p>那么现在，问题就简化为：$p_0$在$p_{k-1}$和$p_k$之间，如何取$p_0^{‘}$使得它到两点中更远的点的距离最短？很显然，中点。（此时$p_{k-1}$和$p_k$都是形式上的记号，是固定的点，$|p_0^{‘} p_k|$不一定大于$|p_0^{‘} p_{k-1}|$。但这两点的排列必然构成$p_0$移动到$p_0^{‘}$位置时实际意义上的$p_{k-1}^{‘}, p_k^{‘}$。我们一开始选定的$p_0$是任取的。将此$p_0$进行移动所得到的最优的$p_0^{‘}$才是我们想要的答案）</p><p>然后上面得到的形式上的$p_{k-1}$和$p_k$要怎么确定呢？注意到只要中间包含了k-2个点的点对都可能符合要求，于是一波遍历就好了。</p><h2 id="D-1"><a href="#D-1" class="headerlink" title="D"></a>D</h2><p>给定一个n元数组，让你在其中放一些（k-1）隔板，使得从$\sum 从左往右第i个区块中所有数字的和 * i$最小。</p><p>看到一些数字的和，我们考虑前缀和（$s_i = \sum\limits_{j = 1}^i a_j$），设题目中的分点为$t_1, …, t_k$，则所求即$\sum\limits_{i = 1}^k (s_{t_i} - s_{t_{i-1}}) \cdot i$（$t_0 = 0, t_k = n$）。</p><p>这个式子可以写成$k \cdot (s_{t_k} - s_{t_{k-1}}) + (k - 1) \cdot (s_{t_{k-1}} - s_{t_{k-2}}) + … + 1 \cdot (s_1 - s_0)$。也即$k \cdot s_{t_k} - (s_{t_1} + s_{t_2} + … + s_{t_{k-1}})$。</p><p>其中$t_1, t_2, …, t_{k-1}$是我们选择的分点，$t_k = n$。所以把前缀和排个序就好了。（注意排序是sort(s+1, s+n)而不是sort(s+1, s+n+1)）。</p><p>下面是原思路……</p><p>给定的样例为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 2</span><br><span class="line">-1 -2 5 -4 8</span><br></pre></td></tr></table></figure><p>不难发现，将5，-4，8划分到第二组优于将8划分到第二组。为什么呢？因为5-4&gt;0。从8开始，我们向左找相加为正数的一个点，再找下一个点……这样的贪心思路。</p><p>（结合代码可能更容易理解我的思路，另外sum为后缀和而非前缀和……）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LL a[maxn], sum[maxn], next_node[maxn];</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(LL n, LL k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += (sum[<span class="number">1</span>] - sum[n+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL n_next = n;</span><br><span class="line">    <span class="keyword">while</span>(next_node[n_next] &gt;= k)</span><br><span class="line">        n_next = next_node[n_next];</span><br><span class="line">    ans += k*(sum[n_next] - sum[n+<span class="number">1</span>]);</span><br><span class="line">    split(n_next<span class="number">-1</span>, k<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这里头的next_node数组，我是这么算的，O(n)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LL temp = <span class="number">0</span>, last = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(LL i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    temp += a[i];</span><br><span class="line">    <span class="keyword">if</span>(temp &gt; <span class="number">0</span>)</span><br><span class="line">        next_node[i] = last;</span><br><span class="line">    <span class="keyword">if</span>(a[i] &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = <span class="number">0</span>;</span><br><span class="line">        last = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉并无问题，然鹅交上去就wa了，现在还没de出来。</p><h2 id="E-WA"><a href="#E-WA" class="headerlink" title="E(WA)"></a>E(WA)</h2><p>其实可以把问题做等价的转化，就是思考从x开始，它要经过多少个区间才能”跳“到y点。拿例子来说，比如已有[1, 3], [2, 4]两区间，那么(x, y) == (1, 2)时hop=1，因为经过[1, 3]区间即可，(x, y) == (1, 4)时则hop = 2：从1跳到3再跳到4，或是从1跳到2再跳到4，没有更短的路径。</p><p>在这个问题中，设询问区间的左端点为x，它通过一个区间能“跳”到$z_1, z_2, z_3, …, z_m$这些点（$z_1, z_2, z_3, …, z_m$呈升序）。不难发现，贪心的思路能帮助我们解决问题，即$x-&gt;z_m, z_m-&gt;y$这种跳法必然优于$x-&gt;z_k, z_k-&gt;y$（$1 \leq k \leq m$）。（画个图感受一下更好，证明的话反证即可）</p><p>想到了这点，我们再来想如何进一步地处理这个问题呢。储存所有可能的询问值么？这样复杂度在时间上是$O(n^2)$，空间上也会爆。为了降低复杂度，我们考虑倍增的思路，记录从每个点开始，跳1步，跳2步，跳4步……所能达到的最远点。这样也不难设计出针对每个查询的算法。</p><p>倍增首先要处理边界情形：跳1步所能达到的最远点。考虑将所给区间按$l$从小到大排序（$l$若相同，保留$r$最大的那个区间，其他舍去）。那么若一个点P在一个或多个区间内，选取包含它的$l$值最大的区间[$l_{max}$, $r_{max}$]，则该区间是所有包含点P的区间中$r$最大的（由之前的排序得到）。故P所能到达的最远点，即$r_{max}$。</p><p>（另外，题目中有一些不被任何区间包含的点，我们记它们跳任意距离都会到-1）</p><p>然后是写倍增了，这是较为容易的。（但不知道有没有地方写错了……也检查不出来）</p><p>对于每次查询，我们看x跳一步是否能到达y，如是，则所经路径数+1，返回答案。如否，则会有两种情况：1）x最终跳到了一个”不动点“（$f[x][i] == f[x][i+1]$）；2）存在$i \geq 0$使得$f[x][i] &lt; y \leq f[x][i+1]$。对于前一种情况，我们返回-1（因为这个不动点必然在y左侧，如果不是，那么x会从case 2中退出，或者x跳一步就到达y了）。对于后一种情况，我们把$f[x][i]$代回$x$，进行迭代。</p><p>（这个算法看上去是正确的？然而WA了……）</p><p>（测试数据规模较大故无法拿到。值得一提的是，有output=2而实际应为1的情况，也有output=-1而实际为正数的情况。）</p><h1 id="round-564-div2-鸽"><a href="#round-564-div2-鸽" class="headerlink" title="round #564 div2(鸽)"></a>round #564 div2(鸽)</h1><p><a href="https://codeforces.com/contest/1173" target="_blank" rel="noopener">戳我做题</a></p><p>A注意特判。</p><p>B倒是挺有意思，找规律+假的数学归纳法可以得出一种可能的答案，但它为何而正确呢？（更代数的看）三角不等式。</p><p>C……毒瘤题。总归是贪心的思路，就看开始要浪费多少牌才能开始顺序打出所有牌了。而这可以通过枚举要把哪张牌垒到顶上来算。但是，为什么这样的策略是可行的呢？（我希望构造性的游戏方案，而不是非构造性地给个最优解）</p><p>D的话，我的关注点在“交叉”上，然后想着想着就想到麻烦的方向去了，想到图的结构如此的话该如何如何……而忽视了“树”这一条件。从根结点出发，可以发现，子树中的结点都是占据了“整一块”连续的圆弧的。在这个条件下，如果知道父母结点的位置，子树的个数，还有父母+孩子所占据的圆弧是既定的这一信息，就能列出所有可能的方案数了（记父母节点有k个子节点，则$f(u) =  k! \cdot \prod\limits_{child} f(child)$）。虽然思想是dp，但算一算是能发现公式的，于是打表就好了。</p><h1 id="round-565-div3-鸽"><a href="#round-565-div3-鸽" class="headerlink" title="round #565 div3(鸽)"></a>round #565 div3(鸽)</h1><p><a href="https://codeforces.com/contest/1176" target="_blank" rel="noopener">戳我做题</a></p><p>B又是贪心……数字的位置无关紧要，只有模三余n的数的个数是重要的信息。瞎匹配就好。我想如果把题目中“任意取两数”的条件改成“取相邻两数”，这道题该怎么做？</p><p>E的话我想想把这个图打成树，然后bfs二染色就好了……懒得写bfs就用了dfs，结果居然t了。这时才看到数据规模竟有$T \leq 2e5, n \leq 2e5$之大，这dfs个毛线啊？于是我在读入的时候直接随便染色，居然还是t。把memset去掉换成for，才a……（随便染色是怎么染呢？就那么染呗。如果当前读入的两个点都没染过，一个染0一个染1；如果都染过就跳过；如果一个染过一个没染，把没染的染和染了的染色相不同的染色。容易证明，这样下来符合题意。）</p><h2 id="D-2"><a href="#D-2" class="headerlink" title="D"></a>D</h2><p>“看到这个题，我有一种莫名的近乎落泪的感动。”</p><h2 id="F-WA"><a href="#F-WA" class="headerlink" title="F(WA)"></a>F(WA)</h2><h1 id="round-566-div2"><a href="#round-566-div2" class="headerlink" title="round #566 div2"></a>round #566 div2</h1><p><a href="https://codeforces.com/contest/1182" target="_blank" rel="noopener">戳我做题</a></p><p>（掉分的感觉，真·爽的一批）</p><p>做A的时候，乘法法则加法法则傻傻分不清，我不仅现在离散没学好，高中组和数学也没学好……</p><p>做B的时候想能否边读入便判定，便先找center_c再找center_r，可这样不仅代码长，还要考虑特殊情况。直接通过center的性质找第一个符合条件的不就好了么！做得又慢，做完还错，讨厌模拟题，但又不能秒过它，这样的态度不行的啊。</p><p>做C的时候（读题读了好久……对关键点的挖掘还不够迅速而准确，我的阅读理解能力有待提高）贪心的思想是没问题了，结果在字符长度上出了篓子……这是ICPC不是CTF，毒瘤出题人总喜欢出毒瘤数据。对可变长数组的感觉还不够啊。$vector<char>$，或者$string$。</char></p><p>做E的时候看出它是个矩阵快速幂了，但是把这东西的细节都忘掉了……无奈在比赛结束后20分钟才过sample。不过当时如果做出来也过不了的吧，因为费马小定理的关系。</p><h2 id="C-2"><a href="#C-2" class="headerlink" title="C"></a>C</h2><p>题意：给你若干个单词，让你选四个配成一对。要求是第一个词和第三个词有相同的元音数，第二个词和第四个词有相同的元音数且它们最后一个元音一样（由题意，每个单词至少有一个元音，所以一行中的最后一个元音必然在后面的词上）。问最多能配出多少对。然后输出最多匹配时的任意一种方案。</p><p>题目里有效的信息是单词、元音数、最后的元音。于是我们可以用一个struct来存数据。然后怎么匹配呢？考虑到第二个词和第四个词间的关系更强，我们先匹配出这一类，然后再匹配有相同元音数但是末位元音不一的另一类。</p><p>二四类怎么匹配呢？考虑贪心的思路。按元音数-最后元音进行排序，i从1到n，考虑nodes[i]和nodes[i+1]能不能匹配，能就匹配它们了（同时设vis[i] = vis[i+1] = 1，以防一个单词被重复使用）。不能则说明nodes[i]不能和其它nodes匹配（易证）。这样遍历一遍就匹配出同时能取的最多的二四类了。</p><p>一三类的匹配比较常规，也是贪心的思路，就不谈了。</p><p>匹配完之后我们得到cnt_first个一三类的单词组，cnt_second个二四类的单词组。怎么输出呢？分类讨论呗。若是cnt_first &gt;= cnt_second，输出cnt_second组单词就好了。若是cnt_first &lt; cnt_second，考虑到二四类的单词比一三类强（也就是，二四类的单词可以兑换成一三类用），输出cnt_first + (cnt_second - cnt_first) / 2组单词就好了。细节不表。</p><h2 id="E-1"><a href="#E-1" class="headerlink" title="E"></a>E</h2><p>接近裸的递推关系。把$f_n$写成$c^{a(n)} \cdot f_1^{b(n)} \cdot f_2^{c(n)} \cdot f_3^{d(n)}$的形式，就可以发现递推方程啦。其中b, c, d都是同一形式的，只不过初始条件不同罢了。a要特殊点，因为你要把它在形式上做一些变换，这是高中的内容。</p><p>然后矩阵快速幂上板子。要注意的是，$MOD = 1e9+7$是个质数，故而$c^{p*(MOD-1) + q} \equiv c^{p + q}$（费马小定理）。在处理指数的递推关系时候，要模MOD-1；而在计算快速幂时，要模MOD。</p><p>写题目的时候碰到个坑点，记录如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n &gt;= <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    n -= <span class="number">3</span>;</span><br><span class="line">    LL ans = qpow_num(qpow_matrix(n) - n, c); <span class="comment">// qpow_num(expo, base)</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样是过不去的，为什么？因为上面把n改变了，所以在处理a的时候得小心一点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n &gt;= <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    n -= <span class="number">3</span>;</span><br><span class="line">    LL ans = qpow_num(qpow_matrix(n) - n - <span class="number">3</span>, c); <span class="comment">// caution!</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样有时候会t，为什么？因为前面算出来的qpow_matrix那个是模过MOD-1的，而n没有模过MOD-1，所以指数会出现负数的情形，这样子快速幂就跳不出来了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n &gt;= <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    n -= <span class="number">3</span>;</span><br><span class="line">    LL expo1 = qpow_matrix(n) - n - <span class="number">3</span>;</span><br><span class="line">    expo1 = ((expo1 % (MOD<span class="number">-1</span>)) + (MOD<span class="number">-1</span>)) % (MOD<span class="number">-1</span>); <span class="comment">// caution!</span></span><br><span class="line">    LL ans = qpow_num(expo1, c);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模过的数和没模过的数……变量在公式上的始终如一与在程序上的可变……这些都是坑点啊。尽管可能还会再犯，但希望下次能先把这些错误过一遍，有个印象总得。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下分真快乐呀……&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="https://nessoffice.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【数学之美】离散数学及其应用：第十一章 初探树</title>
    <link href="https://nessoffice.github.io/2019/06/22/Discrete_Mathematics-CH11/"/>
    <id>https://nessoffice.github.io/2019/06/22/Discrete_Mathematics-CH11/</id>
    <published>2019-06-22T11:22:10.000Z</published>
    <updated>2019-06-29T14:19:20.984Z</updated>
    
    <content type="html"><![CDATA[<p>树是一种特殊的图，它有一些良好的性质，也有相当广泛的应用。</p><a id="more"></a><h1 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h1><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><p>树：简单无环连通图（开始的定义是无向图，不过这并不是最重要的，最重要的是前面三条：无重边，无环，连通）</p><p>无向图为树，当且仅当任意两点间有唯一路径。</p><p>开始的定义中树是无向图，不过实际生活中我们建出来的树一般都有层级关系，故要定义方向。怎么确定方向呢？选定根节点然后递归（在subtree中递归）就好了。这样得出的树称为有根树，它的相关术语更多一些：parent, child, sibling, ancestor, descendant…这些是和点和点间的性质。至于点内部的性质，则有root, leaf, internal vertices，这些。</p><p>然后我们容易发现，parent有且仅有一个，除了根节点。children则可以不限量，除了叶节点。为了方便定量运算，我们定义每个节点children不超过m的树为m-ary tree，同时也定义了full m-ary tree。m取2比较常见，所以给它个好听的名字，binary tree。</p><p>然后child地位也不是平等的，有left child，有right child，有heavy child，有light child。这些是要有序地遍历树的时候要考虑的，这里先不必管。</p><h2 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h2><p>n个节点的树恰有n-1条边（可数归证，亦可套欧拉公式）。这条定理指出以下三个条件间的相互关系，即任意两个条件都能推出剩下的条件：1）G为连通图；2）G无环；3）G有n-1条边。</p><p>full m-ary tree若有i个internal vertices，则其有mi + 1个点。（由此，可确定总顶点数，内点数，叶子数间的关系，知二得三）</p><p>平衡树：叶子都在最后一层或是倒数第二层的树//为何作此定义？</p><p>m叉树至多$m^h$个叶子$\Leftrightarrow$m叉树高度h和叶子数满足$h \geq \lfloor log_m l \rfloor$。</p><h1 id="树的应用"><a href="#树的应用" class="headerlink" title="树的应用"></a>树的应用</h1><p>二分搜索树</p><p>决策树</p><p>博弈树</p><p>前缀码（关注Huffman编码）</p><h1 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h1><p>前序、中序、后序遍历</p><p>波兰式与逆波兰式</p><h1 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h1><p>图连通与其有生成树，二者等价</p><p>dfs、bfs求生成树</p><p>回溯的思路</p><p>Prim算法与Kruskal算法</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;树是一种特殊的图，它有一些良好的性质，也有相当广泛的应用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="课程笔记" scheme="https://nessoffice.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【数学之美】离散数学及其应用：第十章 图论基础</title>
    <link href="https://nessoffice.github.io/2019/06/22/Discrete_Mathematics-CH10/"/>
    <id>https://nessoffice.github.io/2019/06/22/Discrete_Mathematics-CH10/</id>
    <published>2019-06-22T11:22:09.000Z</published>
    <updated>2019-06-29T14:19:09.581Z</updated>
    
    <content type="html"><![CDATA[<p>想知道图有哪些好玩的应用吗？</p><p>想知道图有哪些奇妙的种类吗？</p><p>想知道怎样科学地研究我们生活中的电路和考试安排表吗？</p><p><strong>来学图论吧！</strong></p><p>①有向图、复杂图、环等奇妙关系的丰富组和！</p><p>②解锁打电话、找关系、打比赛、画分子、爬网站、焊电路板等趣味模型！</p><p>③用图论来获得缤纷色彩、最短路径等谜题的答案！</p><p>④所有的算法与复杂度都能尽情研究！</p><p>⑤在权重扩展包中探索新的玩法！</p><p><strong>好评发售中！</strong></p><a id="more"></a><h1 id="图的元素"><a href="#图的元素" class="headerlink" title="图的元素"></a>图的元素</h1><p>这一节主要在讲概念，概念也不复杂，一般动手画画就能理解，此处仅记一下术语。</p><p><strong>multigraphs</strong>，与之对应的是simple graph。multiplicity为边的重数。</p><p><strong>digraph</strong>（或directed graph），有向图。</p><p><strong>loop</strong>，在本书中指的是自环而非环（环一般用<strong>circuit</strong>表示）。</p><p>是否有重边，是否有自环，是否有向，也是Kenneth H.Rosen要求我们看到一个图时扪心自问的三个问题。</p><p><strong>pseudograph</strong>，同时有自环与重边的图，复杂图。</p><p>其他术语，什么mixed graph，simple directed graph就不记了，这些都可以通过组和最重要的三个元素得到。</p><h1 id="图的模型"><a href="#图的模型" class="headerlink" title="图的模型"></a>图的模型</h1><p>这里的模型基本大同小异，涉及的方面有日常生活；也有其他看似关联不大的学科，如心理学、环境学；还有就是各类网络：通信网，道路网……</p><p>书上的练习设计的的方向主要是自然语言与图论语言的转化，这是容易通过而熟练掌握的。练习中比较恶心的一类是画出precedence graph的Edge, 记于此处, 以供训练。<br>  s1: x := 0<br>  s2: x := x + 1<br>  s3: y := 2<br>  s4: z := y<br>  s5: x := x + 2<br>  s6: y := x + z<br>  s7: z := 4</p><h1 id="图的术语"><a href="#图的术语" class="headerlink" title="图的术语"></a>图的术语</h1><h2 id="邻域"><a href="#邻域" class="headerlink" title="邻域"></a>邻域</h2><p> 顶点A的邻域记作$N(A)$, 表示与A有共边的顶点的集合。</p><p>A的领域中的点与A是相邻(adjacent)的。</p><h2 id="度"><a href="#度" class="headerlink" title="度"></a>度</h2><p>在无向图中， $deg(A)$表示以A为端点的边的数目。</p><p>而在有向图中，$deg^-(A)$则表示起点为A的边数数目，类似地，$deg^+(A)$表示终点为A的边数数目。</p><p>度是与点有着直接关系的量。而边与度的关系则是每条边对总度数有两个贡献（举[有向]线段AB为例，无向图中数A的度与数B的度均要将其算一遍；在有向图中，它则只在A的入度和B的出度中各算了一次），由此可得定理1及其在有向图中的拓展（即书中的定理3）。</p><p>1.$\sum deg$ = $2|E|$</p><p>3.$\sum deg^-$ = $\sum deg^+$ = $|E|$</p><p>由此可见，无向图的度数和必为偶数。由此可得到书中的定理2：</p><p>2.无向图中度数为奇数的点必为偶数个。</p><p>证明的话，模2即可。</p><h1 id="特殊的图"><a href="#特殊的图" class="headerlink" title="特殊的图"></a>特殊的图</h1><p>1.完全图</p><p>2、3.环与轮（注意，$W_n$有n+1个点）</p><p>4.n维方体，顶点可用不超过$2^n$的正整数来表示（关注$n \geq 4$的情形，比如n=4要怎么画呢）</p><p>以上没什么好讨论的，其相关性质也非常好推。需要讨论的是以下的情形：二分图。</p><p>二分图的定义：对图$G = (V, E)$，若存在互不相交的顶点集$V_1, V_2$使得其并为$V$，且$E$中的任意元素$(u, v)$总满足$u, v$不同时属于$V_1$或$V_2$，则称$G$为二分图。</p><h2 id="二分图与染色问题的联系"><a href="#二分图与染色问题的联系" class="headerlink" title="二分图与染色问题的联系"></a>二分图与染色问题的联系</h2><p>二分图与染色问题有着密切的联系。简单图是二分图当且仅当其所有顶点能被染成两种颜色，并且没有同色点有共边。这并不难证明。</p><p>通过将求图$G$是否为二分图转化为能否将图$G$染色并使其满足上述条件，我们能得到一种求二分图的简单算法：从任意一点开始，将其染为一色，将与其相邻的点染为另一色，再转移到下一点，以此类推（类似BFS），直到出现矛盾或染色完成且自洽。</p><h2 id="二分图的匹配与Hall婚配定理"><a href="#二分图的匹配与Hall婚配定理" class="headerlink" title="二分图的匹配与Hall婚配定理"></a>二分图的匹配与Hall婚配定理</h2><p>给定二分图$G = (V, E)$，$E$的每一子集能够连接一些$V_1, V_2$中的点，若满足$V_1, V_2$中不存在度数超过1的元素，则称此为一次<strong>匹配</strong>。若一次匹配中连接起的$V_1$中的点的集合等于$V_1$，则称这是一次<strong>完全匹配</strong>。与二分图的匹配相对应的模型有求职、婚姻等。</p><p>了解了匹配的概念，我们自然会想到完全匹配需要什么条件，而Hall婚配定理则是对此的探讨。</p><p>二分图$G = (V, E)$存在完全匹配当且仅当对于所有$V_1$的子集$A$，都有$|N(A)| \geq |A|$。（此处$V_1$和$V_2$的地位是不对称的）</p><p>由存在完全匹配推出结论并不难，因为任意A中元素$u$唯一地对应$V_2$中的$v$，后者的集合是A的邻域的子集，其元素个数等于$A$的元素个数不大于$A$的邻域的元素个数。下面证明其逆命题，我们的思路是采用第二数学归纳法，将V中元素较大的情况缩减至V中元素较小的情况。</p><p>归纳前提：$|V|=1$时结论显然成立。</p><p>归纳假设：$|V|\leq k$时假设结论成立，下证明$|V|= k+1$时结论成立。</p><p>取$V_1$的恰含j个元素的子集A（A是任意的），由已知，存在两种情况：(1)$|N(A)| &gt; |A|$（对任意A情况均如此）与(2)$|N(A)| = |A|$，下分类讨论</p><p>(1)任取一个A，将其中一个元素与其对应元素配对（即剔除出$V_1$与$V_2$），余下的元素满足大前提及归纳假设，求证得证。</p><p>(2)将A与其对应集合配对，下用反证法证明余下的元素满足大前提（若不满足，其加上A之后也不会满足，故矛盾）也满足归纳假设，求证得证。</p><p>//此处应补充上图示</p><p>霍尔婚配定理的不足之处在于，它是一个存在性证明而非构造性证明，无法据其给出求出完全匹配的算法。</p><p>//霍尔婚配定理是否足够强呢？</p><p>(proper) subgraph</p><h1 id="图表示与图同构"><a href="#图表示与图同构" class="headerlink" title="图表示与图同构"></a>图表示与图同构</h1><p>邻接表、邻接矩阵, incidence matrix（前向星）</p><p>同构：关注不变量——环、度、子图结构，或者从补图入手</p><h1 id="图的连通性"><a href="#图的连通性" class="headerlink" title="图的连通性"></a>图的连通性</h1><p>割点（cut vertices）</p><p>从连通分量到强连通分量</p><p>k-connected</p><p>$\kappa(n) \leq \lambda (n) \leq min_{v \in V} deg(v)$</p><p>路径的条数（矩阵乘法）</p><h1 id="Euler路径与Hamilton路径"><a href="#Euler路径与Hamilton路径" class="headerlink" title="Euler路径与Hamilton路径"></a>Euler路径与Hamilton路径</h1><p>欧拉路径存在的充要条件</p><p>欧拉回路存在的充要条件</p><p>哈密顿回路：不能存在deg=1的点；deg=2的点至多一个</p><p>完全图（包括无向完全图与竞赛图）必有哈密顿回路</p><h1 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h1><p>dijkstra算法</p><h1 id="平面图"><a href="#平面图" class="headerlink" title="平面图"></a>平面图</h1><p>基本方法（如判定$K_{3, 3}$非平面图）</p><p>欧拉公式</p><p>degree of region</p><p>平面图中e，v相关的不等式</p><p>找和$K_5, K_{3, 3}$同构的子图</p><h1 id="图染色"><a href="#图染色" class="headerlink" title="图染色"></a>图染色</h1><p>找最大团</p><p>图染色的模型：考试安排表</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想知道图有哪些好玩的应用吗？&lt;/p&gt;
&lt;p&gt;想知道图有哪些奇妙的种类吗？&lt;/p&gt;
&lt;p&gt;想知道怎样科学地研究我们生活中的电路和考试安排表吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;来学图论吧！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;①有向图、复杂图、环等奇妙关系的丰富组和！&lt;/p&gt;
&lt;p&gt;②解锁打电话、找关系、打比赛、画分子、爬网站、焊电路板等趣味模型！&lt;/p&gt;
&lt;p&gt;③用图论来获得缤纷色彩、最短路径等谜题的答案！&lt;/p&gt;
&lt;p&gt;④所有的算法与复杂度都能尽情研究！&lt;/p&gt;
&lt;p&gt;⑤在权重扩展包中探索新的玩法！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好评发售中！&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="课程笔记" scheme="https://nessoffice.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【数学之美】离散数学及其应用：第九章 关系</title>
    <link href="https://nessoffice.github.io/2019/06/22/Discrete_Mathematics-CH09/"/>
    <id>https://nessoffice.github.io/2019/06/22/Discrete_Mathematics-CH09/</id>
    <published>2019-06-22T11:22:08.000Z</published>
    <updated>2019-06-30T13:07:22.597Z</updated>
    
    <content type="html"><![CDATA[<p>这章的主题是关系——我们关注的不是单个的元素，而是<strong>元素间</strong>的性质。</p><a id="more"></a><h1 id="关系的概念"><a href="#关系的概念" class="headerlink" title="关系的概念"></a>关系的概念</h1><h2 id="关系的定义"><a href="#关系的定义" class="headerlink" title="关系的定义"></a>关系的定义</h2><p>什么是关系呢？关系是集合论里的词，它是用笛卡尔积给出的。我们先来看一个简单的例子，比如我们有六只猫，三公三母，有哪些可能的配偶方案呢？我们先把猫放到集合里，令 公猫集 = {Wang, Miao, Aichiyu}，母猫集 = {qwq，bwb，dwd}。这时候我们考虑笛卡尔积。{Wang, bwb}，这表明Wang和bwb存在关系（’Wang’ is related to ‘bwb’），更确切的说，存在二元关系。</p><p>笛卡尔积给出的是有序元素，所以关系也是有序的。“关系”这个词看着很别扭，因为自然语言中的“关系”不仅是“有关系”的意思。但要在数学上研究元素间的关系，我们就得把“关系”看作一个集合，由形如$A \times B$的式子给出的集合的子集，比如说，R = { {Wang, qwq}, {Wang, bwb}, {Miao, bwb} }。这就是一个“关系”（relation）了。</p><p>不必管R有什么意义，因为它的意义是我们赋予的。我们可以定义$(a, b) \in R \Rightarrow$ a不喜欢b，也可以做相反的定义，都可以。关系也不仅限于猫猫狗狗上，只要是元素，都可以用笛卡尔积给它们搞出个关系。这样“关系”就能很丰富了，比如满足不等式的两元素间的关系，函数原像与像的关系，等等。这里谈到的“关系”是我们由经验中的“关系”抽象而出的，仅表示两元素间存在“关系”，而并未指明这样的“关系”是什么“关系”。（真是绕）</p><h2 id="关系的性质"><a href="#关系的性质" class="headerlink" title="关系的性质"></a>关系的性质</h2><p>知道了R的定义，我们可以来考察它的性质了。根据实际研究的需要，我们主要考察R是否有以下四种性质：</p><p>1.reflexive。即$\forall a \in A, (a, a) \in R, R \subseteq A \times A$。观察$R = {(a, b) | a &lt; b, a, b \in N}$和$R = {(a, b) | a \leq b, a, b \in N}$的区别很容易理解这条性质。</p><p>2.symmetric。即$\forall a, b,  (a, b) \in R \rightarrow (b, a) \in R$。</p><p>3.antisymmetric。即$\forall a, b,  (a, b) \in R \wedge (b, a) \in R \Rightarrow a = b$。（在猫猫匹配的例子中，如果R是antisymmetric的话那可真是悲哀）</p><p>4.transitive。即$\forall a, b, c, (a, b) \in R \wedge (b, c) \in R \rightarrow (a, c) \in R$。</p><p>transitive的画风看起来和上面那些很不一样，我们之后再来考虑它。（这一节中有一些叫你判断R是否transitive的例题，方法的话枚举中间元素较为方便）</p><p>需要注意，antisymmetric和symmetric并不是互斥的，它们研究问题的方向可以说完全不同。“关系”中还有其他和对称性沾边的性质，比如asymmetric，它和antisymmetric其实很像，只是限制了$\forall a, (a, a) \not \in R$（对了，这条性质就是irreflexive）。要确定这些研究方向各不相同而有所交集的性质间的关系并非那么容易的，不过，这是一个值得研究的问题吗？</p><p>这一节中还会有一些组和问题，比如，给定$|A| = n$，问antisymmetric的R有多少个。这类题在理解了R的定义之后非常好做。上面例子的答案为$2^n \cdot 3^{n \cdot (n-1)}$。捆绑的思想。</p><h2 id="关系间的运算"><a href="#关系间的运算" class="headerlink" title="关系间的运算"></a>关系间的运算</h2><p>既然关系是一个集合，我们可以利用集合中的运算研究关系和关系间有什么关系。在这里，$\cup, \cap, \oplus, -$都可以直接继承集合中的运算。</p><p>然后因为关系是多元组，它还有自己独特的计算：$\circ$。如果把关系表示为矩阵的话，那么这一项便可以类比矩阵乘法。具体写来，是这样的：$R \subseteq A \times B, S \subseteq B \times C, (a, b) \in R \wedge (b, c) \in S \rightarrow (a, c) \in S \circ R$。（这个符号真反人类……明明运算和$R \times S$很像，但硬是要反过来写，不懂）</p><p>还有需要注意的是，$R^{-1}$不是使得$R \circ R^{-1} = E$成立的集合，它更像是$R^T$，这些记号需要注意。</p><p>然后定义了这个”乘法“(composite)之后，我们就可以来关注transitive这条性质了。比如有一条定理，讲的是R满足transitive和$R^n \subseteq R$这一条等价。证明的话，右边推左边按性质就好了，左推右数归就好。至于这条定理有何意义？（至少我不清楚）</p><h1 id="n元关系-待补充"><a href="#n元关系-待补充" class="headerlink" title="n元关系[待补充]"></a>n元关系[待补充]</h1><p>上面讲的关系都是二元关系，形如$A \times B$。类似的，我们可以定义n元关系。</p><p>对n元关系我们就不考察它的性质了，反正它还是元素笛卡尔积得到的集合，研究n元的情形没什么必要。</p><p>需要考察的是它的应用：比如数据库中，一个条目，比如说学生，包含了很多子数据：姓名、学号、GPA……那么我们可以把姓名×学号×GPA×…得到的元素视作一段关系的元素，也就是数据库中的项。这样一来，一个数据库就对应一种关系。我们要进行各式各样的数据库操作：添加，删除，排序……这些该如何定义呢？</p><p>（关注select和projection的分别。）</p><h1 id="关系的表示"><a href="#关系的表示" class="headerlink" title="关系的表示"></a>关系的表示</h1><p>前面我们都是抽象地”感受“关系的，这样想问题或许不容易理解。我们试着将其化归到已经学过的可爱的数学元素上，好让它更直观一些。</p><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>简单地在关系和0-1矩阵上做个一一映射，就能用矩阵来表示关系啦。</p><p>用矩阵来表示关系可以让reflexive, symmetric, antisymmetric的判断变得很简单，但是判断transitive还是一如既往的麻烦。</p><p>用矩阵表示也让composite（乘法）更容易算了（注意0-1矩阵乘法的规则）。这在之后研究transitive上是好的。</p><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>矩阵规模好大，但又好稀疏，用矩阵表示要写好多0，好烦，怎么破？用邻接表呗。（前向星，多好的名字啊）</p><h2 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h2><p>随便找道例题体会一下即可，这种表示法更为直观。</p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h2><p>我们觉得满足性质的关系是好的，比较漂亮。不满足性质的关系就没那么漂亮。那么，怎么把不漂亮的关系补成漂亮的关系呢？（为什么一定要补呢？置$R = \varnothing$多方便啊？）称补出来的为闭包（很显然，笔者的定义是不严谨的，但很直观）。</p><p>reflexive, symmetric都很好补，而antisymmetric补不出来。看上去要研究的只剩transitive了。</p><p>可这并不容易，需要先定义一些其他的概念。</p><h2 id="传递闭包"><a href="#传递闭包" class="headerlink" title="传递闭包"></a>传递闭包</h2><p>我们先来回顾一下何谓传递性，不用关系中的术语，而是以图论的角度来思考。一个有向图，它有点和边，于是可以得到从一点a出发的”可到达的“点的集合（设其中任意一点为b），也得到了它要到那些点的路径及路径长度。而传递性，表明从a到任意的的b最短距离为2，也就是能直连通。</p><p>但是目前的图不一定使得连通的两点能够直连通啊，所以要补边（边和关系中的元素一一对应），也就是考虑构造传递闭包。</p><p>上面是较直观的感受，用数学语言该如何转译呢？a可达b，即$\exists k, (a, b) \in R^k$。于是这个(a, b)需要添加到闭包中。yy一下，我们得到了一种获得传递闭包的方式：$R^* = \bigcup\limits_{k = 1}^{\infty} R^k$。</p><p>然后如果路径太长，长过顶点数，这其中肯定是有环的，可以把环剪掉。所以$R^* = \bigcup\limits_{k = 1}^{n} R^k$。</p><p>这个算法的复杂度是$O(n^4)$，还不错？不过要算好多乘法好累，有没有稍微简单一点的算法呢？有的，Warshall’s Algorithm。</p><p>Warshall算法的思路是这样的：如果有长度超过2的路径，那么这条路径必然要经过中间的节点，于是可以通过枚举中间节点来构造传递闭包。（想到Floyd算法了吗？恰好，Floyd算法的全称正是Floyd-Warshall算法）yy一下，对着书上的例题手工模拟一番，便能学会这个算法了。（正确性证明考虑数归）</p><h1 id="等价关系"><a href="#等价关系" class="headerlink" title="等价关系"></a>等价关系</h1><p>什么是等价关系呢？我们来看看具体的例子吧：比如$\equiv$，它就是一个等价关系，$1 \equiv 5(mod 4)$。其中1和5本身并不相等，但是在mod 4这个条件下，它们是等价的，是可互换的。故，等价关系，指在给定的条件下，元素满足同样的性质。</p><p>等价关系要满足什么性质呢？其实这是我们自己归纳出来的。比如说$\equiv$，它reflexive，symmetric，transitive。然后满足这三点的关系，那么，我们就下个定义：满足reflexive，symmetric，transitive的关系就叫等价关系。（这一定义并非先验的，为什么等价和这三个性质有联系可能不好理解，但为什么要尝试理解它呢？）</p><p>满足等价关系的元素可以归到一类里，称等价类。同余等价类就是很好的例子。</p><p>定义了等价类，我们可以选取等价类中的一个元素，比如说a，来表示这个类，记作[a]。于是乎可以得到三种等价的表述：$a R b \Leftrightarrow [a] = [b] \Leftrightarrow [a] \cap [b] \not = \varnothing$。</p><p>由等价类间的互不交，可由等价类在原集合上做划分（partition）。</p><p>然后对于计数问题，如问有多少种等价关系这样的问题，可以考虑等价类的数目来做。</p><h1 id="偏序关系"><a href="#偏序关系" class="headerlink" title="偏序关系"></a>偏序关系</h1><p>这节讲的是偏序关系。偏序，偏序，顾名思义，和两个要素息息相关，其一为“偏”，其二为“序”，“偏”又是建立在“序”的基础上的，指的是并非所有元素间均可比较。与偏序关系对应的是全序关系。无论是偏序还是全序，它们都得要能排序，也就是能比较才行。什么样的关系是可排序的呢？</p><p>$\leq, |, \subseteq$，这些看似不同的运算都有着相似的特点：reflexive, antisymmetric, transitive。我们看到这样的关系是可比的。于是，我们用$\preccurlyeq$表示这样的偏序关系，也就是满足以上三条性质的关系。经历了等价关系的洗礼，读者应当能够接受这种表达。</p><p>定义了偏序关系，我们接着来定义一种常用的排序方式：字典序。//待补充</p><p>Hasse图：用以直观表示偏序关系的图//待补充</p><p>maximum, minimal, greatest, least, (greatest) lower bound(GLB), (least) upper bound(LUB)//待补充</p><p>lattice(a partially ordered set in which every pair of elements has both a least upper bound and a greatest lower bound)</p><p>topological sorting</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这章的主题是关系——我们关注的不是单个的元素，而是&lt;strong&gt;元素间&lt;/strong&gt;的性质。&lt;/p&gt;
    
    </summary>
    
    
      <category term="课程笔记" scheme="https://nessoffice.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【数学之美】离散数学及其应用：第八章 计数进阶</title>
    <link href="https://nessoffice.github.io/2019/06/22/Discrete_Mathematics-CH08/"/>
    <id>https://nessoffice.github.io/2019/06/22/Discrete_Mathematics-CH08/</id>
    <published>2019-06-22T06:19:07.000Z</published>
    <updated>2019-06-30T13:07:29.593Z</updated>
    
    <content type="html"><![CDATA[<p>虽然这章名为“计数进阶”，但其内容和“计数”关系似乎不是很大。除了生成函数是标准的“计数”内容，“递推”“分治”看起来和“计数”都没啥关系。另外容斥定理讲得也比较浅。</p><a id="more"></a><h1 id="递推关系"><a href="#递推关系" class="headerlink" title="递推关系"></a>递推关系</h1><h2 id="递推关系模型-需补充"><a href="#递推关系模型-需补充" class="headerlink" title="递推关系模型[需补充]"></a>递推关系模型[需补充]</h2><p>从兔子数列到牛数列</p><p>汉诺塔</p><p>满足特定条件的01串（如，不包括连续两个0的01串）</p><p>（卡塔兰数的一种情形）n个数相乘的顺序总数</p><h2 id="递推算法-需补充"><a href="#递推算法-需补充" class="headerlink" title="递推算法[需补充]"></a>递推算法[需补充]</h2><p>讲座问题</p><p>动态规划</p><h1 id="线性递推"><a href="#线性递推" class="headerlink" title="线性递推"></a>线性递推</h1><h2 id="齐次"><a href="#齐次" class="headerlink" title="齐次"></a>齐次</h2><p>所谓线性齐次常系数递推关系（linear homogeneous recurrence relations with constant coefficients），指的是形如$a_n = c_1 a_{n-1} + c_2 a_{n-2} + … c_k a_{n-k}$的递推关系。</p><p>提到“线性齐次常系数递推关系”我们就会提特征方程与特征根，它们是用以解递推式的利器。</p><p>特征根是个非常有效但也让人摸不着头脑的东西。它本身有何意义？下面笔者粗浅地谈谈自己对其的认识。</p><h3 id="二阶递推式-需完善"><a href="#二阶递推式-需完善" class="headerlink" title="二阶递推式[需完善]"></a>二阶递推式[需完善]</h3><p>如果递推式形如$a_n = Aa_{n-1} + Ba_{n-2}$，$a_n$该如何解呢？我们考虑能否用特殊的$a_n$凑出答案，比如，$a_n = x^n$，这样？把它代入原递推式，我们得到一个二次方程$x^2 - Ax - B = 0$，如果它有不同的解$x_1, x_2$，诶，好，$a_n = x_1^n$或者$a_n = x_2^n$看上去都可以。</p><p>但是啊，$a_n = Aa_{n-1} + Ba_{n-2}$是由$a_1, a_2$完全确定的。如果$a_1 \not = x_1$，那不就出问题了吗？其实，前面说$a_n = x_1^n$“可以”，那么$a_n = Cx_1^n + Dx_2^n$也是“可以”的。这样便能够通过给定的$a_1, a_2$解一解C、D，$a_n$的通解也就出来了。</p><p>因为$x^2 - Ax - B = 0$和$a_n$有着密切的联系，我们称前者为“特征方程”。</p><p>以上是特征方程有两个相异根的情形，如果相同则如何呢？不一定存在$C$使得$a_1 = Cx_1$且$a_2 = Cx_1^2$啊！在这个条件下，我们令$a_n = Cx_1^n + Dnx_1^n$。可以证明，这样的$a_n$满足条件//为什么想到要这样做？</p><h3 id="n阶递推式"><a href="#n阶递推式" class="headerlink" title="n阶递推式"></a>n阶递推式</h3><p>与上面类似的，我们能想到无重根的n阶递推式的通解形如$a_n = \sum\limits_{i = 1}^k \alpha_i r_i^n$，其中$r_i$为特征方程的解。</p><p>至于有重根的n阶递推式，它则形如$a_n = \sum\limits_{i = 1}^k(\sum\limits_{j = 0}^{m_i} \alpha_{(i, j)} n^j r_i^n)$，其中$r_i$为特征方程的解，$m_i$为重数。</p><p>证明呢？不管了(¬､¬)</p><p>有重根的n阶递推式</p><h2 id="非齐次-需完善"><a href="#非齐次-需完善" class="headerlink" title="非齐次[需完善]"></a>非齐次[需完善]</h2><p>所谓线性非齐次常系数递推关系（linear nonhomogeneous recurrence relations with constant coefficients），指的是形如$a_n = c_1 a_{n-1} + c_2 a_{n-2} + … c_k a_{n-k} + F(n)$的递推关系。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>找特解，而后化归到齐次。（这些方程都这种套路，得归纳一下）</p><p>特解怎么找呢？比如$a_n = 3a_{n-1} + 2n$，我们可以从结构上猜出$a_n = Cn$。而对于$a_n = 5a_{n-1} - 6a_{n-2} + 7^n$，我们也可以猜一个$a_n = C \cdot 7^n$。但是如果是$a_n = 5a_{n-1} - 6a_{n-2} + 3^n$，$a_n = C \cdot 3^n$就不管用了，要$a_n = C \cdot n^2 \cdot 3^n$才行（为什么又是这个形式？我不知道）。</p><p>一般的，有下面的定理。</p><h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p>若$a_n = c_1 a_{n-1} + c_2 a_{n-2} + … c_k a_{n-k} + F(n)$，$F(n)$形如$(b_t n^t + b_{t-1} n^{t-1} + … + b_1 n + b_0) s^n$，其中b、s均为常数。递推关系的特征方程$x^n - c_1 x^{n-1} - c_2 x^{n-2} - … c_k x^{n-k} = 0$的解中s的重数为m，则特解的形式形如$a_n = n^m (p_t n^t + p_{t-1} n^{t-1} + … + p_1 n + p_0) s^n$。</p><p><del>我不会，就不证了</del>例子：$a_n = 6a_{n-1} - 9a_{n-2} + F(n)$，当$F(n)$分别取$F(n) = 3^n, F(n) = n 3^n, F(n) = n^2 2^n, F(n) = (n^2 + 1) 3^n$，求$a_n$的通解。</p><p>应用：如求$a_n = \sum n^k$。</p><h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><p>研究分治算法时，一个值得关注的对象是时间复杂度。下面举几个大家耳熟能详的例子。</p><p>例子：矩阵乘法、二进制乘法（汇编乘法？）、二分查找、归并排序</p><p>上面的例子看似相似，但其算法复杂度可以很不一样！最后的公式会依据递推关系中的常数专门进行分类讨论，而且结论虽然能推，但是并不好记。//如何认识这一结论？</p><p>关于复杂度的推导，我们可以先简化问题，因为只要得到$f(n) = O(g(n))$就好了，可以对n进行“适当”的放大。这里，我们考虑$n = b^k$。</p><h2 id="f-n-的复杂度估计-需完善"><a href="#f-n-的复杂度估计-需完善" class="headerlink" title="f(n)的复杂度估计[需完善]"></a>f(n)的复杂度估计[需完善]</h2><h3 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h3><p>对于形如$f(n) = af(n/b) + c$的递推式，有</p><p>………………..$a = 1 \Rightarrow f(n) = O(log n)$</p><p>………………..$a &gt; 1 \Rightarrow f(n) = O(n^{log_b a})$</p><p>………………..$a &lt; 1 \Rightarrow f(n) = O(1)$</p><p>第一项很好理解，第二项是怎么得到的呢？其实直接得到的是$f(n) = O(a^k)$，而通过换底公式能得到$a^k = n^{log_b a}$，因为我们喜欢把n放到真数的位置。下面也是要用到这个转换的。</p><h3 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h3><p>对于形如$f(n) = af(n/b) + cn^d$的递推式，有</p><p>………………..$a = b^d \Rightarrow f(n) = O(n^d log n)$</p><p>………………..$a &lt; b^d \Rightarrow f(n) = O(n^d)$</p><p>………………..$a &gt; b^d \Rightarrow f(n) = O(n^{log_b a})$</p><h2 id="典例：最近点对问题-需完善"><a href="#典例：最近点对问题-需完善" class="headerlink" title="典例：最近点对问题[需完善]"></a>典例：最近点对问题[需完善]</h2><p>计算几何的一个<del>毒瘤</del>经典例题，初看非常的抽象，下面我试着以直观的方式说明一下如何用分治法解决这个问题。</p><p>首先分治呢，要先“分”，而后“治”。“分”的话二分比较常见，但二分要在有序集里才好进行。考虑以x坐标对这些点进行排序，然后取中间的点作为分界就好了。</p><p>下面的思路有些跳跃，我们从最后的算法出发来反推，这样可能更容易理解些。</p><p>分治法大框架的伪代码如下，一些细节先不必理解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">closest</span><span class="params">(Point p[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(high - low == <span class="number">1</span> <span class="keyword">or</span> <span class="number">2</span>)...</span><br><span class="line">    <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> d1 = closest(p, low, mid);</span><br><span class="line">    <span class="keyword">double</span> d2 = closest(p, mid + <span class="number">1</span>, high);</span><br><span class="line">    <span class="keyword">double</span> d = min(d1, d2);</span><br><span class="line">    d = merge(...);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面框架的细节主要是这个：d = min(d1, d2)。为什么要先算d呢？</p><p>这实质上是用于提高效率的。你想，“分”做好了，就是左右两边的最近点对距离都已经分别算出来了，“治”要怎么做呢？枚举左边的点和右边的点的距离么？这样还是$O(n^2)$，算法的复杂度还是没有降低呀！于是我们得限制枚举的点的数量。聪明的Preparata和Shamos发现，如果先算出d1、d2和d，那么用要枚举点的话，只要在下图中两条红线间的区域间（x坐标距mid为d的区域内）枚举即可。</p><p><img src="/2019/06/22/Discrete_Mathematics-CH08/closest_distance1.png" alt></p><p>就是说，这里用到了剪枝：把一些分居左右而距离必定超过d的点对剪掉。这个剪枝还是比较宽的，但它容易想到呀，如果要更深入地剪就要深入探究点的结构了，太复杂啦！我们不考虑。</p><p><img src="/2019/06/22/Discrete_Mathematics-CH08/closest_distance2.png" alt></p><p>可是，看这张图，即便上面有剪枝，枚举量还是太大了呀，如何缩减呢？我们遇到的问题是这些剩下的点还是无序的，只得暴力枚举，而没有有效的降低枚举量的技巧。于是，聪明的Preparata和Shamos又把剩下的点有序化了，并利用“两点间距离不能大于d”继续剪枝。请看伪代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">merge</span><span class="params">(Point p[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high, <span class="keyword">double</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;<span class="comment">// the size of the array "temp"</span></span><br><span class="line">    Point temp[];<span class="comment">// the points between the red lines</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//branch-cutting 1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = low;i &lt;= high;i++)</span><br><span class="line">        <span class="keyword">if</span>(p[i].x &gt;= p[mid].x - d)</span><br><span class="line">        <span class="keyword">if</span>(p[i].x &lt;= p[mid].x + d)</span><br><span class="line">        temp[len++] = p[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// the merge part</span></span><br><span class="line">    sort(temp, temp + len, cmp_y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;i + j &lt; len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp[i+j].y - temp[i].y &gt; d) <span class="keyword">break</span>;<span class="comment">// branch-cutting 2</span></span><br><span class="line">            d = min(d, dist(temp[i], temp[i+j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面“branch-cutting 2”这一行，它很容易理解，但是否足够有效呢？是否存在某组数据使得“the merge part”的运算量退化到$n^2$呢？幸运的是，它足够有效！而且运算量至多是7n！请看下面的图示。</p><p><img src="/2019/06/22/Discrete_Mathematics-CH08/closest_distance3.png" alt></p><p>假设我们正枚举到$P1$。Preparata和Shamos证明了，至多有7个$P2$满足$P2.y - P1.y \leq d$。因为前面在左右两边已经”分“过了，故有closest(left), closest(right) &gt;= d，即在“一边”的点两两距离大于d。这个结论非常有用！因为前面已经构造出了以2d为边长的长方形作为我们选点的区域，我们再在这个长方形里画小的正方形，再把P1放进去。能够发现，在图中所示的八个虚线区域中，每个区域至多一个点（否则矛盾）。故而“branch-cutting 2”在至多7步后就会退出，这个剪枝足够有效！</p><p>上面的分析还是比较粗略的，因为实际运算时似乎用不着7步，我们能否证明对每个点至多只要4次或5次比较呢？不论如何，总之都是较小的常数就是了。</p><p>接着来分析一下算法复杂度吧。开始的按x排序：O(nlogn)，之后的递推：f(n) = 2f(n/2) + nlogn + 7n（nlogn是按y排序）。解上面的递推式，得f(n) = O(nlogn)//为何网上有说法是nloglogn？</p><p>以反推的方式理解了一下这个算法，我们再来正面地总结一下我们的步骤：</p><p>①准备，按x排序原数组，使之有序；</p><p>②“分”，以中点为界，得到两子域中的最短点距；</p><p>③“治”，依据②中的最短点距d找出需要枚举的点，这里进行了第一次剪枝；</p><p>④“治”，将③中得到的点按y排序，顺序枚举，并通过y的距离进行第二次剪枝；</p><p>以上。</p><p>总而言之，这个算法的步骤还是容易实现的，难的是深入地理解它。这里两个剪枝分开来看都可能是效率不高的，但合在一起就产生了奇妙的相互作用，保证了总体剪枝的有效性。这十分精妙，但也很难想到，而且不好推广。</p><p>另外书上的算法是设了两个数组，分别对x排序与对y排序，之后在后者这一数组中检索，但这样细节是如何处理的呢？我还不知道。</p><p>算法的完整代码见下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span><span class="keyword">double</span> x, y;&#125;Points[maxn], temp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_x</span><span class="params">(Point &amp;lhs, Point &amp;rhs)</span></span>&#123;<span class="keyword">return</span> lhs.x &lt; rhs.x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_y</span><span class="params">(Point &amp;lhs, Point &amp;rhs)</span></span>&#123;<span class="keyword">return</span> lhs.y &lt; rhs.y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(Point &amp;lhs, Point &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>((lhs.x - rhs.x)*(lhs.x - rhs.x) + (lhs.y - rhs.y)*(lhs.y - rhs.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high, <span class="keyword">double</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> mid_x = Points[mid].x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = low;i &lt;= high;i++)</span><br><span class="line"><span class="keyword">if</span>(Points[i].x &gt;= mid_x - d)</span><br><span class="line"><span class="keyword">if</span>(Points[i].x &lt;= mid_x + d)</span><br><span class="line">temp[len++] = Points[i];</span><br><span class="line">sort(temp, temp + len, cmp_y);<span class="comment">//in the book, it's not necessary to sort. Why?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;i + j &lt; len &amp;&amp; (temp[i+j].y - temp[i].y &lt;= d);j++)</span><br><span class="line">d = min(d, dist(temp[i], temp[i+j]));</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">closest</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(high == low) <span class="keyword">return</span> INF;</span><br><span class="line"><span class="keyword">if</span>(high - low == <span class="number">1</span>) <span class="keyword">return</span> dist(Points[low], Points[low+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">double</span> d1 = closest(low, mid);</span><br><span class="line"><span class="keyword">double</span> d2 = closest(mid + <span class="number">1</span>, high);</span><br><span class="line"><span class="keyword">double</span> d = min(d1, d2);</span><br><span class="line"><span class="keyword">return</span> merge(low, mid, high, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...<span class="comment">//scanf</span></span><br><span class="line">sort(Points, Points + n, cmp_x);</span><br><span class="line">...<span class="comment">//printf</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>①分治算法在不同递推式下算法复杂度可能不同，需特殊情况特殊分析。</p><p>②分治算法的精髓在于“分而后治”，“分”是“治”的基础，通过“分”得到的有效信息能够帮助我们降低“治”部分的复杂度。在归并排序中，“分”得到的有效信息是子序列的有序性；在最近点对问题中，“分”得到的有效信息是子区域的最近点对距离。</p><p>③分治算法本身不难理解，但比较难想到，也比较灵活。分析分治算法时“为何这种问题可以用分治处理”。</p><h1 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h1><p>何谓生成函数？这是个比较玄妙的问题，它的定义很简单，但为何要这样定义，及它为何能用来解决组合问题，则常常会给人带来迷惑，下面笔者以个人的理解粗略地讲讲生成函数。</p><h2 id="生成函数的概念"><a href="#生成函数的概念" class="headerlink" title="生成函数的概念"></a>生成函数的概念</h2><p>先来看这样一个例子：$x_1 + x_2 + x_3 = 7$，其中$0 \leq x_1 \leq 2, 2 \leq x_2 \leq 3, 3 \leq x_4 \leq 4$，$x_1, x_2, x_3$为整数。求$(x_1, x_2, x_3)$有多少种可能。</p><p>我们固然可以通过解答树得到答案，但是否有其他更“代数”的做法呢？考虑这个式子：$(1 + x + x^2) \cdot (x^2 + x^3) \cdot (x^3 + x^4)$。它意味着什么？我们把第一个括号中x的指数看作$x_1$的取值，第二三个括号同理。从一二三个括号中各选一项乘起来，恰好对应$x_1 + x_2 + x_3 = k$的一种方法。故$(1 + x + x^2) \cdot (x^2 + x^3) \cdot (x^3 + x^4)$展开式中$x^k$的系数，即$x_1 + x_2 + x_3 = k$的方法数（而指数所对应的便是$x_1 + x_2 + x_3$的取值）。特别的，取k = 7，就得到了上面问题的答案。</p><p>这个方法看上去和暴力枚举并无二致，但事实并非如此。首先，生成函数将组合问题与代数问题连接起来，从而使得组和问题更易表示，而能为计算机所处理（多项式乘法）。其次，这样的算法在运算时更为容易，因为我们更熟练于多项式的乘法而不是列出解答树。</p><p>为何上述做法能建立从组和到代数的一一映射呢？原因在于乘法法则与加法法则——$ax^c + bx^c = (a+b)x^c$，这对应于加法法则；$ax^c \cdot bx^d = ab x^{c+d}$，这对应于乘法法则。如果认为这有些抽象，不妨在上面的例子中找找哪里用到了这两个法则。生成函数之所以能够解决组合问题，原因就在于多项式的运算能有这样和组和相关的性质。</p><p>上面的生成函数$G(x) = (1 + x + x^2) \cdot (x^2 + x^3) \cdot (x^3 + x^4)$是有限项的，容易理解。但是实际运用中我们一般会考虑无穷项的情况，即将$G(x)$写作无穷级数的形式。然后玄学东西又来了：比如$G(x) = \sum\limits_{i = 0}^{\infty} x^i = \dfrac{1}{1-x}$。为什么可以这样做？这样做有什么好处？这些我们将在下文中，结合具体的案例进行探讨，此时先不要被它迷糊了头脑。</p><h2 id="用生成函数证明组和恒等式-需完善"><a href="#用生成函数证明组和恒等式-需完善" class="headerlink" title="用生成函数证明组和恒等式[需完善]"></a>用生成函数证明组和恒等式[需完善]</h2><p>使用生成函数时，我们需要考虑“意义”。这不是指x的意义——x毫无意义，我们引入x只是要利用多项式的运算，因为它是好的。此处的意义指的是我们运算式子中的意义。拿上面的例子来说，$((1 + x + x^2)), (x^2 + x^3)$分别都有意义，它们相乘也是有意义的。谈到”意义“，你可能想到了第六章玄学的”组合证明“。而生成函数与组合证明，它们恰能够结合在一起。</p><p>//二项式定理？</p><p>比如Yanghui恒等式，可以这么证：$(1+ x)^n = (1 + x)^{n-1} + x (1 + x)^{n-1}$，关注左右式中$x^k$的系数即可。</p><p>又比如Vandermonde恒等式，关键的式子是$(1 + x)^{m + n} = (1 + x)^n (1 + x)^m$。</p><p>不难发现，使用生成函数的思路和组合证明的思路是完全一致的。但这个形式看起来就”正经“的多。</p><h2 id="用生成函数解决组和问题"><a href="#用生成函数解决组和问题" class="headerlink" title="用生成函数解决组和问题"></a>用生成函数解决组和问题</h2><h3 id="生成函数的模型"><a href="#生成函数的模型" class="headerlink" title="生成函数的模型"></a>生成函数的模型</h3><p><strong>例1</strong></p><p>$x_1 + x_2 + x_3 = 7$，其中$0 \leq x_1 \leq 2, 2 \leq x_2 \leq 3, 3 \leq x_4 \leq 4$，$x_1, x_2, x_3$为整数。求$(x_1, x_2, x_3)$有多少种可能。</p><p><strong>例2</strong></p><p>八本书，分给三个小孩，每人得到的书不少于两本不多于四本，求总方法数。</p><h3 id="再谈可重复元素的组和"><a href="#再谈可重复元素的组和" class="headerlink" title="再谈可重复元素的组和"></a><strong>再谈可重复元素的组和</strong></h3><p>在讲这个例子前，先要提一提广义二项式定理。</p><p><strong>广义二项式系数</strong>：$C_u^m = \dfrac{u \cdot (u-1) \cdot … \cdot (u - m + 1)} {1 \cdot 2 \cdot … \cdot m}$，其中m为非负整数，u为任意实数。</p><p>特别的，当u为负整数的时候，我们有$C_{-n}^m = (-1)^m C_{n + m - 1}^m$。</p><p><strong>广义二项式定理</strong>：$(1 + x)^u = \sum\limits_{i = 0}^{\infty} C_u^i x^i$。（证明的话，幂级数展开就好）</p><p><strong>例3</strong></p><p>有n种硬币，每种有无穷多个，问取r个硬币有多少种方法。</p><p>第一种硬币可以取0个、1个、2个、……，这样考虑的话，生成函数便是$G(x) = (1 + x + …)^n$。</p><p>但无穷级数相乘很难算。我们为了能够算出结果，假定级数收敛，那么$(1 + x + …) = \dfrac{1} {1 - x}$。则$G(x) = \dfrac{1} {(1 - x)^n}$。</p><p>于是可以使用上面的广义二项式定理了，得$x^r$的系数是$C_{n + r - 1}^r$。</p><p>回过来再考虑生成函数的问题，它为何要是无穷级数？为了方便表示”可重复元素“，也是为了计算上的方便，因为这样就可以在微积分和组合数学之间建立联系了，从而使用微积分中的一些性质。而对于实际的问题，我们都可以在模$x^r$的意义下考虑原式子，这样让人困惑的无穷就消失啦。</p><p>为何能假定上面的式子收敛？<del>我也不知道，好用就行了</del></p><p><strong>例4</strong></p><p>有三种硬币，币值分别为1、2、5，每种都有无穷个，求取r元有多少种方法？</p><h2 id="用生成函数解决排列问题-需完善"><a href="#用生成函数解决排列问题-需完善" class="headerlink" title="用生成函数解决排列问题[需完善]"></a>用生成函数解决排列问题[需完善]</h2><h2 id="用生成函数解决递推问题-需完善"><a href="#用生成函数解决递推问题-需完善" class="headerlink" title="用生成函数解决递推问题[需完善]"></a>用生成函数解决递推问题[需完善]</h2><p>考虑斐波那契数列的生成函数：$G(x) = \sum\limits_{i = 0}^{\infty} f_i x^i$，$G(x) = x + \sum\limits_{i = 2}^{\infty} f_i x^i = x + \sum\limits_{i = 2}^{\infty} (f_{i-1} + f_{i-2}) x^i = x + x\sum\limits_{i = 0}^{\infty} f_i x^i + x^2 \sum\limits_{i = 0}^{\infty} f_i x^i = x + xG(x) + x^2 G(x)$，则$G(x) = \dfrac{x} {1 - x - x^2}$，因式分解再裂项，就得到我们常见的结果了。</p><p>为什么生成函数这么奇妙？因为它巧妙地将递推关系用来消项。//<del>然后我也讲不出什么道道了</del></p><p>这里的G(x)看起来是很抽象的，有没有办法让它表现得具体一点呢？您好，有的。我们来算一下$G(1/10) = \dfrac{10}{89} = 0.1123595506…$，不难发现小数点后第i项就是斐波那契数列第i项（仅限前几项，因为后面的要进位）。</p><p>如此，我们便可以用生成函数在小数和数列间建立联系啦，也可以用生成函数得到一些好玩的小数。</p><h1 id="容斥原理-需补充"><a href="#容斥原理-需补充" class="headerlink" title="容斥原理[需补充]"></a>容斥原理[需补充]</h1><p>内容</p><p>素数个数（关注计算复杂度）</p><p>满射的个数</p><h2 id="错排问题"><a href="#错排问题" class="headerlink" title="错排问题"></a>错排问题</h2><p>后面的部分<a href="https://www.cnblogs.com/c1299401227/p/5349727.html" target="_blank" rel="noopener">引自网络</a>，略有删改。（不知是否这位老哥原创的）</p><p>$\forall i, f(i) \not = i, i, f(i) \in \{ 1, 2, …, n \};\forall i \not = j, f(i) \not = f(j)$，求符合要求的函数个数D(n)。</p><p>核心递推公式：</p><p>$D(n) = (n-1) [D(n-2) + D(n-1)]$</p><p>初始值：$D(1) = 0, D(2) = 1$。</p><h3 id="递推的推导错排公式"><a href="#递推的推导错排公式" class="headerlink" title="递推的推导错排公式"></a>递推的推导错排公式</h3><p>分析i = 1，它有n-1个取值。不失一般性，设$f(1) = 2$。再分析i = 2，若$f(2) = 1$，剩下的个数就是$D(n-2)$。</p><p>下面的一步就好玩了：如果$f(2) \not = 1$，那么剩下的个数是多少呢？注意！$f(2) \not = 1, f(3) \not = 3, …, f(n) \not = n$，这难道不是新的错排，个数是$D(n-1)$？于是，上面的递推式就得到啦！</p><p>下面咱们来推公式。</p><p>根据套路，设$D(n) = n! N(n)$，然后推一推，得//怎么想到要这么做的？</p><p>$nN(n) = (n-1) N(n-1) + N(n-2)$​，然后有</p><p>$N(n-1) - N(n-2) = (-1)^{n-1} / (n-1)!$，相加得</p><p>$N(n) = (-1)^2/2! + … + (-1)^{n-1} / (n-1)! + (-1)^n/n!$</p><p>故</p><p>$D(n) = n! [(-1)^2/2! + … + (-1)^{n-1}/(n-1)! + (-1)^n/n!]$</p><p>此即错排公式。</p><h3 id="用容斥原理的推导"><a href="#用容斥原理的推导" class="headerlink" title="用容斥原理的推导"></a>用容斥原理的推导</h3><p>用容斥原理也可以推出错排公式:</p><p>正整数1, 2, 3, ……, n的全排列有 n! 种，其中第k位是k的排列有 (n-1)! 种;当k分别取1, 2, 3, ……, n时，共有n*(n-1)!种排列是至少放对了一个的，由于所求的是错排的种数，所以应当减去这些排列;但是此时把同时有两个数不错排的排列多排除了一次，应补上;在补上时，把同时有三个数不错排的排列多补上了一次，应排除……重复该一过程，得到错排的排列种数为</p><p>$D(n) = n! - n!/1! + n!/2! - n!/3! + … + (-1)^n<em>n!/n! = ∑(k=2~n) (-1)^k </em> n! / k!$，</p><p>即$D(n) = n! [1/0! - 1/1! + 1/2! - 1/3! + 1/4! + … + (-1)^n/n!]$.</p><h3 id="简化公式"><a href="#简化公式" class="headerlink" title="简化公式"></a>简化公式</h3><p>错排的公式里有n项，计算复杂度是O(n)，有没有简便的近似值呢，像Stirling公式一般？有的，而且不仅仅是近似值：$D(n) = \lfloor n!/e+0.5 \rfloor$。（但是这个公式有何意义呢？计算n!不还得O(n)？）</p><p>以下是证明：</p><p>对$1/e$幂级数展开一波，得$1/e = e^{-1} = 1/0! - 1/1! + 1/2! - 1/3! - ….. + (-1)^n/n! + R_n(-1)$//看不懂</p><p>其中$R_n(-1)$，$R_n(-1) = (-1)^{n+1} \cdot e^u / (n+1), u∈(-1, 0)$</p><p>所以，$D(n) = n! \cdot e^{-1} - (-1)^{n+1} \cdot e^u / (n+1), u∈(-1, 0)$</p><p>而$|n! R_n| = |(-1)^{n+1} \cdot \dfrac{e^u} {n+1}| = \dfrac{e^u} {n+1} ∈ (\dfrac{1} {[e(n+1)]}, \dfrac{1}{n+1})$，可知即使在n=1时，该余项(的绝对值)也小于1/2。</p><h1 id="术语-需审核"><a href="#术语-需审核" class="headerlink" title="术语[需审核]"></a>术语[需审核]</h1><p>递推关系：recurrence relations</p><p>初始条件：initial conditions</p><p>线性常系数(非)齐次递推关系：linear (non)homogeneous recurrence relations with constant coefficients</p><p>关联的齐次递推关系：associated homogeneous recurrence relations（把F(n)去掉得到的递推关系）</p><p>特征方程/特征根：characteristic equation/roots</p><p>分治算法：divide-and-conquer algorithms</p><p>分治算法的递推关系：divide-and-conquer recurrence relation</p><p>最近点对问题：closest-pair problem</p><p>埃氏筛：sieve of Eratosthenes</p><p>错排：derangement</p><hr><p>完稿于2019-05-01</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然这章名为“计数进阶”，但其内容和“计数”关系似乎不是很大。除了生成函数是标准的“计数”内容，“递推”“分治”看起来和“计数”都没啥关系。另外容斥定理讲得也比较浅。&lt;/p&gt;
    
    </summary>
    
    
      <category term="课程笔记" scheme="https://nessoffice.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
