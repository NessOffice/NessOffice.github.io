<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ness</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nessoffice.github.io/"/>
  <updated>2019-07-18T04:18:22.200Z</updated>
  <id>https://nessoffice.github.io/</id>
  
  <author>
    <name>Ness</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【围炉夜话】对于国内计算机普及教育考核体系范式的简要批判</title>
    <link href="https://nessoffice.github.io/2019/07/18/Toughts-Exams_Of_Computer_Courses/"/>
    <id>https://nessoffice.github.io/2019/07/18/Toughts-Exams_Of_Computer_Courses/</id>
    <published>2019-07-18T11:50:59.000Z</published>
    <updated>2019-07-18T04:18:22.200Z</updated>
    
    <content type="html"><![CDATA[<p>日经，因为不开心。</p><a id="more"></a><p>（文章可能比较情绪化，一些观点会有失偏颇？欢迎批评）</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>咱不谈国内教材的风格问题，不谈谭浩强等经典教育家，不谈十年不更新的课件。咱就来看看现在高校中的计算机考核体系（考试制度、评分制度等等）中存在着哪些问题。</p><p>首先需要说明的是，此处涉及的计算机类课程是“计算机普及教育”性质的，是面向低年级学生的计算机基础课程，包括中学时的信息技术课程、大一的程序设计基础课程等，而非专业性较强的课程，后者因笔者尚未接触过故不作评价。</p><p>所谓考核体系中存在的问题，指的是计算机学科课程的考核无法客观全面地反映学生的能力，造成低能者高分，高能者低分的现象。当然，我并没有做统计，只能拿自己说事。个人看到这样的成绩比较不爽，写篇软文骂骂街，期盼一下更加让人（己）信服的计算机课程考核体系，仅此而已。</p><p>标题中所谓范式，指的是当前国内学校普遍采取的这种考核模式。不光浙大如此，大多数学校在计算机学科的考核模式上虽有差异，但总体而言还是如此的。个人比较不喜这样的考核模式，但也不了解其他的模式，对于墙外的教学也不甚了解，无法提出有指导性的教学改进意见。</p><p>对这种考核体系的厌恶是自中学时代开始的。从中学开始，我就不喜欢技术这门学科的考试，无论是信息技术，还是通用技术（这里不谈通用）。高一时候还能凭借着信息差稳拿信息技术的第一，但等到大家都明白这门课的套路后就发现它也就这样了。大家都满分，很没意思。（高中同学之前在寝室里吹水哪些课拿过第一的时候把信息拿出来吹，搞邪了你）倒是我会因为乱七八糟的问题满不了。难道分数不比别人高说明我不比别人强？怎么可能。难道每个分高于我的人都比我热爱计算机，都比我有程序设计的思想，都比我更理解算法？怎么可能。但分数就是摆在那里。很不爽。很不爽。高中的信息技术无法在思想深度上作拓展，只得在边边角角上挖坑，坑一坑考试技巧低的人。这到底有什么意思？设置这样一门考试是要考察什么？想不明白，于是我不选技术，选历史。</p><p>到了大学，本以为进了计院就不用再接触这些糟心的考试了，但还是事与愿违。</p><p>从浙江大学《C语言程序设计》《程序设计专题》课程的情况来看，这类计算机普及课程的考核一般会由project，平时参与情况，期中期末考三部分构成。其中后者为大头，占了50%~60%。我们便来谈谈这考试。不过在说考试之前，我们有必要关注，考试要考察什么。</p><h1 id="能力"><a href="#能力" class="headerlink" title="能力"></a>能力</h1><p>普及性的计算机学科，需要学生掌握哪些能力呢？中学课本中往往会有office、ps、flash（该换h5啦）的基础操作指南。这些好拿出来考试？有什么思维含量？通过简单的搜索就能掌握的记忆性的知识，完全没必要考察。让学生用文字描述具体的操作过程也挺蠢，有一种独到的滑稽感。说到底，我知道这些内容对中学生而言并非不重要，但感觉用传统的中学教学模式对待计算机课程就有种说不出的拧巴感。</p><p>还有呢？程序设计的能力，这实质上是对计算思维的培养，对逻辑思维以外一种独特而有效的解决问题的思维模式的培养，这是相当有价值的。教授一些简单的算法，一些常见的数据结构，足以打开低年级学生（尤其是中学生）的心智，让他们领略到计算机科学的魅力，而不是薪水的魅力。</p><p>把宏观的程序设计能力再细分，在具体的程序设计上，我们还需要具备对程序流程的理解能力，对意外事件的处理能力，对程序正确性与复杂度的分析能力，等等等等。虽然归纳地并不细，不过考试大抵也便是考察这些个能力。ok，那我们开始讲试卷，看看它能否较好地检验学生的综合能力。</p><h1 id="试卷"><a href="#试卷" class="headerlink" title="试卷"></a>试卷</h1><p>考试试卷会由多个部分组成：判断题（理论性较强），填空题（用大脑编译运行程序），程序填空题。这些部分分别能考察什么东西呢？首先是判断题，个人非常讨厌。有些理论书上没提看似值得深挖，但个人觉得真的没啥意思，举个例子：</p><blockquote><p>定义FILE  *fp; 则文件指针fp 指向的是（）。(1分)</p><p>A. 文件在磁盘上的读写位置</p><p>B. 文件在缓冲区上的读写位置</p><p>C. 整个磁盘文件</p><p>D. 文件类型结构体</p></blockquote><p>这种题目要考察什么？如果教师在课堂上对这一知识点有所强调，并能进行知识点的延伸，那这样的题目可作为检验听课情况的一枚试金石。可若是教师对此完全没有提，学生面对这样的题目要怎么办？虽然自学是重要的技能，但我们也应理清什么样的知识是好的，是值得我们投入时间的。计算机课程不是思想道德修养，它里头虽然也有理论，但切不可空谈理论而忽视实践。而在这样一类的题目中，实践的影子，何在呢？</p><p>虽然题库中存在许多这样无趣的题目，但无可否认的是，许多题目还是有一定价值的，能够帮助同学们检验知识漏洞。这是值得肯定的。</p><p>填空题最大的特点，就是没意思，和实际的工程比较脱节。它是在考察学生对于语法规则，简单的算法的理解能力，但笔者不认为这是一种合格的考核方式。且不谈优先级排序，++++++这种反人类题。填空题与工程的一大脱节便体现在考试的限制上，学生被要求不得打开编译器对程序进行调试。诚然，如果不这么做则填空题的区分度会大幅减少。但这样的规定也在很大程度上破坏了计算机课程可贵的实践性，这和程序填空题的弊端是一致的。本来一个编译运行，几个调试就能发现的低级错误，硬是成了所谓体现区分点的地方。这能区分个什么对语言特性的认识对编程范式的思索，只是停留在大众教育阶段的对于所谓“勤奋”“仔细”的筛选。想到大家在走出高考考场后仍要惦着曾经的那么一些无趣的行为模型，我比较无语。</p><p>至少我没有见到过有趣的填空题和程序填空题，虽然都会做，但做起来慌得不行，唯恐哪个细节又没注意到，感觉写下来的都是错的。事实也正是如此，总会因为trivial的错误错掉一些题（虽然中学老师教我们强调细节，不过在大学的context里，“仔细”的重要程度还是第一位吗？）。程序填空题的初衷是好的，希望考察学生对代码的阅读能力与对程序流程的认识。但不得不说这种形式实在不讨喜。码风的不一本应通过建立语言使用的共识（编码规范）来达到一定程度的消除，然而学校并未这么做。另外，对陌生代码细节的把控不当也是所谓“区分点”的一环，而这本应通过测试来消除的。</p><p>简言之，这三类题除了选择题尚可，对其他两类题鄙人均比较反感。虽然如此，我也不清楚什么样的题型是自己是大家所喜闻乐见的。感觉计算机学科就不适合笔试。加入一定量的编程题（不可以有码量巨大的模拟题）或许比较好吧，但浙大《程序设计专题》课程今年把编程题取消了，原因不明。</p><p>这里顺便吐槽一下PTA系统。死板的填空题检测机制不支持等价写法，程序填空题的评测系统简单粗暴连拼写都不帮你检查一下（变量名错了扣了一堆分，无语）。最让我不爽的是，编程题的题库里放了很多三流学校（浙大不知算不算）三流教师编写的牛逼题，什么答案输出4+-3i才能过，什么手动实现atof函数（还nm是残的，不支持指数写法），什么“题目主要是输入花费大量的时间，如查找出现超时，尝试多次提交。”我还能说什么呢？牛逼，真nmd牛逼。我不知道这样的题目能锻炼我什么能力，只知道我浪费了好多时间好多心情在这种没营养的东西上面。</p><h1 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h1><p>笔者眼中理想的计算机普及教育课程的评价体系相较于此前模式的改变，大抵如下：</p><p>提升project在评价中的占比，达到50%~60%。同时对project的拓展功能进行额外评分（拓展功能与正态分布不可得兼，不当让学生为了不被正太而将简单的project过分复杂化，加上许多“冗余”功能，使得恶性竞争的风气盛行。入门级的计算机课程是简单的，大家都能学得好，搞什么正态分布？猪头领导，不具体问题具体分析，不求是，当什么浙大校长），由教师、助教依据细则、个人判断进行评分。增加project的数目，包括小组project与个人project，两个短学期的课程中，前者一项（工作量较大），后者三项（工作量较小）为宜。互评作为签到性质的任务，在project的评分中只不占比重，只是平时参与情况的一部分，作为同学们相互学习的一环。同时恶意评分者当受到惩罚。</p><p>不取消期中期末考试因其还有一定价值，但应降低其比重至20%~30%。保证题库的质量，撤销同学们普遍认为没有价值的题目。教师当对所谓“考试技巧”进行强调，强调考试与工程的差异与考试本身的价值，本身的特点。考试要增加对伪代码的支持，简单粗暴的程序填空题当少，更能反映考生理解力和表达力（可用伪代码表达自己的想法）的简述题当有。添加一定量的编程题。</p><p>中学阶段的信息技术课程当向这样的模式看齐，尤其是浙江省的信息技术学科。</p><p>以上的方案不尽成熟，还是需要迭代优化的。（所以就鸽在这吧）</p><hr><p>开始于2019-07-03</p><p>完稿于2019-07-18</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日经，因为不开心。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随想" scheme="https://nessoffice.github.io/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>【围炉夜话】互膜与卖弱——黑暗森林中的生存法则</title>
    <link href="https://nessoffice.github.io/2019/07/18/Toughts-Wo_Laji_Nin_Niubi/"/>
    <id>https://nessoffice.github.io/2019/07/18/Toughts-Wo_Laji_Nin_Niubi/</id>
    <published>2019-07-18T11:50:50.000Z</published>
    <updated>2019-07-18T06:09:53.564Z</updated>
    
    <content type="html"><![CDATA[<p>“我最菜了，您最强啦。”金牌玩家如是说。</p><a id="more"></a><p>没有问卷，没有调查。全程瞎bb，欢迎指责本菜鸡哪里说的不对。</p><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>说到卖弱，大家很容易想到NOI，ACM（IMO怎么没人卖？），想到某几个或某几十个大佬间互夸互卖，“我要退学啦”“我是真的菜”，或者，“还是您更强”“您多厉害啊”。（定睛一看，我们能看到一张强连通图，没有自环的那种（夸夸图），还有一张非常神奇的仅由自环构成的图（卖卖图））</p><p>其中可能有历史原因：一开始某些毒瘤学长喜欢这样，于是后辈也都染上了这种风气。不过这样只能保证风气的开端而无法保证其生命力，真正要维持互夸互卖的风气，还是由互夸互卖这一行为本身的特点决定的。这一Meme的生命力为何得以那么顽强呢？首先，我们需要确定我们需要考虑的问题是否属实，在什么条件下属实。</p><p>互夸互卖的风气着实是存在的，但它存在在哪里呢？在别的学科，比如人文社科的学科上，大家也这样吗？在相对一般的大学中，大家也这样吗？这些先不管，虽然它们和我们要考虑的变量间也存在着一定的相关关系而可作为证据佐证我们的观点（因为懒得调查所以懒得管）。我们来yy一下，在工信学子中，在计院学子中，互夸互卖为何能成为一种历久弥新的风气。</p><h1 id="计院？"><a href="#计院？" class="headerlink" title="计院？"></a>计院？</h1><p>是否计算机专业的学生更能膜人呢？从专业，蔓延到其他领域，似乎是这样。</p><p>计算机课程较适合自学，其起点较低而终点难以估量。于是，同一年龄段的学生间往往差异较大。另外，计算机学科的实践性也使得其与数学物理这样的学科有明显的差异，在计算机学科上的领先能直接表现为可见的成果：动不动就能搞看上去很厉害的项目。这能给其他同学造成较大的冲击。</p><p>这套理论听上去很正确？但它能够解释OI选手间的互膜吗？另外，所谓“看上去很厉害的项目”实际上并不一定有难度。世界上有很多封装好的轮子和实现好的库，许多项目只是调库而已，很容易实现，但效果往往不错。</p><p>个人认为，互膜始于计算机课题的难以描述，还有难以把握，而非其难解性。对于同一个问题，或许大家都有些想法。但是要把它具体地实现，则要考虑许许多多的细节，其中许多并不好描述。于是在问题比较复杂的情况下，对这样的问题的解答有一定“玄学”的特质。一段程序，它为何是正确的呢？它这样不可名状，逻辑这般诡异，却又能得出正确的答案？在能够理解者与无法理解者之间，仿佛存在着语言上的隔阂，虽然处理的都是一样的作业，但二者对程序的理解是完全不同的。这层隔阂，或许是造成互膜风气的一个重要原因。开始这样的“膜”是敬畏性的，但逐渐地它演变为游戏性质的meme。</p><h1 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h1><p>单纯把这一行为视为一种游戏的话，它似乎也有可探讨的余地。</p><p>互夸与互卖似乎是一体两面的，表面上，前者是对他人的赞同，后者是对自身的否定。其目的也是相同的，这在之后讨论。但在操作的难易度上，二者并不相同，夸人可以因人而异，抓住对方的vulnerability猛夸猛奶；卖弱则要更深入的挖掘自己，挖到什么宝都能拿出来卖，以增强说服力。夸和卖也要有新意，有气势，这样效果才好。</p><p>夸人-被夸-夸人-被夸……简单的闭环系统，或者简单的博弈。当然，决策也可以是多样的，比如夸和卖可以结合在一起，这样博弈树的当前节点便能得到转换，其走向也能得以改变：“哎哟，我哪有您强啊，您看看您，①②③；您看我多菜啊，①②③”……</p><p>虽然作为调剂而言，偶尔互膜卖弱还是好玩的。但频率多了会感觉这样的对话真的很像小孩子吵架，只不过内容从“我是你爸爸”“我是你爷爷”变成了“您多强啊”“不不不还是您更强”。追求一个虚无缥缈的无法达到的共识，无法达成的认同，这从方向上来说就错了吧。网络上的辩论家们也沉浸在类似的行为中，不过他们争执的内容也不太一样。重复性强迫行为。自虐。Fort-Da。</p><p>是否我们永远长不大？</p><h1 id="认知"><a href="#认知" class="headerlink" title="认知"></a>认知</h1><p>我们为何而互膜而卖弱？因为我们关心自己在他人眼中的形象。</p><p>感到弱小倒是很稀松平常的状态。在庞大的知识体系面前，在生活的无字之书面前。学得越多，越能感到前人已经将弯路都走遍了，可探讨的问题也探讨个遍了，但自己还有很多细节没明白，对于宏观的知识架构也不甚清晰。面对这样的知识大厦，感到弱小，或者更确切些，敬畏，再自然不过的了。我不相信存在热爱数学而不敬畏她的人。</p><p>但是由热爱、信念、意志出发的作研究，与一般的考试，又是两种状态。既然是敬畏，何必要宣扬呢？对于考试，我们在题目之外，也相当看中排名，会自觉地不自觉地关注自己的，别人的位次。</p><p>惧怕形象在他人心目中跌落不起。无法在成绩上做补救，只得在其他方面上做努力。不去想关于考试的细节，假装看淡一切。拒绝交流，做些无关紧要的事情，划水，摸鱼。</p><p>当然，情况也不尽然，以上是我的情形。不过其他情形也就不讨论了吧，没什么好讨论的，大抵在行为上表现出“卖弱”的同学可以分为四五类，每类有不同的特征。但总归，我们当为自己的言行负责。即便是真的不满意，总是表现出来也不免会让他人不舒服，这是客观结果。在游戏的同时应兼顾他人的感受，尤其是因考试而心情不佳的同学，这并不容易，但我认为是必要的，至少自己要做到（似乎，并非人人这么想，这不是普适的价值观）。</p><h1 id="态度"><a href="#态度" class="headerlink" title="态度"></a>态度</h1><p>所以面对这样的风气，我们该怎么做呢？随意。</p><p>以下是笔者的态度：</p><blockquote><p>世人皆浊，何不淈其泥而扬其波？</p><p>众人皆醉，何不餔其糟而歠其醨？</p></blockquote><p>毕竟，主要是你的综合能力，而不是你的言论，决定了你到底是什么嘛。</p><hr><p>初稿写于2019-07-02</p><p>完稿写于2019-07-18</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;“我最菜了，您最强啦。”金牌玩家如是说。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随想" scheme="https://nessoffice.github.io/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>【围炉夜话】从设计的角度看《以撒的结合》</title>
    <link href="https://nessoffice.github.io/2019/07/18/Game-The_Binding_Of_Isaac/"/>
    <id>https://nessoffice.github.io/2019/07/18/Game-The_Binding_Of_Isaac/</id>
    <published>2019-07-18T02:05:59.000Z</published>
    <updated>2019-07-18T04:28:31.602Z</updated>
    
    <content type="html"><![CDATA[<p>并非严谨的考究，只是随便写写而已。</p><a id="more"></a><blockquote><p>以撒的结合是一款集合了推箱子、血统检验、少女换装、宠物养成等等元素的跨世代大作。——灰机wiki</p></blockquote><h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>游戏有多好玩，要素有多丰富就不讲了。初次对以撒感兴趣是因为它的名字，然后是游戏方式吧。在盗版游戏网站上下了羔羊，没玩多久，感觉不好玩，不太适应这种游戏模式，也不知道道具是干啥用的。于是就弃了。那时候大概是初一初二吧。</p><p>高中的时候班里流行元气骑士，我也跟风玩了一会，发现这种游戏模式和以撒很像，这时候能接受了。之后重新开始羔羊，打了几把，感觉不错，于是开始入正。</p><p>然后就是常规的入坑环节了。</p><h1 id="剧情"><a href="#剧情" class="headerlink" title="剧情"></a>剧情</h1><p>游戏究竟讲了一个怎样的故事？其实故事的逻辑并不重要。其中的一些细节也没必要深挖，如为什么天启只掉肉块/绷带，“afterbirth”是什么意思，为何又要设置“mega satan”。这些都是为游戏性，而非剧情服务的。拿hush来说，没有这个boss游戏在剧情上也是完整的，那它加进去的作用是什么呢？丰富boss的种类，给予玩家挑战。再如ultra greed，它不过是七宗罪之一的强化版，为何也是最终boss之一，有这样高的地位？因为游戏要加入greed mode，所以要加入跟这个模式相匹配的boss。从游戏性的角度考虑，这些困惑大都能迎刃而解。</p><p>而剧情也是开放的，没有真正的所谓结局。原版有十三个，重生又多了三个，胎衣又加了几个。那么故事究竟是如何的？无所谓，关键在于它能否打动你。</p><p>游戏中能打动我的点（重生版本），大致如下（<strong>严重剧透</strong>）：</p><font color="FFFFFF">①???结局，一些照片：全家福、带上妈妈的假发、独自一人不开心、愤怒的妈妈……祥和的音乐中，记忆远去，THE END。<br></font><font color="FFFFFF">②拿到cancer时，以撒会哭得更伤心。<br></font><font color="FFFFFF">③用眼泪和怪物对抗。<br></font><font color="FFFFFF">④“Are you sure you want me to die？”<br></font><font color="FFFFFF">⑤原版的海报中，光芒之下是绻缩的以撒，他的身边，是成千上万的腐烂血腥的觊觎的怪物。<br></font><font color="FFFFFF">⑥“子宫层”这个名字，以及其中噬咬的声音。<br></font><font color="FFFFFF">⑦妈心战斗背景音乐名为“Ventricide”，心之死；以撒战斗背景音乐名为“Infanticide”，弑婴。<br></font><font color="FFFFFF">⑧muligen的哭声，leech的叫声……Gurdling的表情与叫声<br></font><font color="FFFFFF">⑨“瘘管”“畸胎瘤”“枯萎卵”，它们的名称；“bloat”“the carrion queen”“枯萎卵”它们的形态。<br></font><h1 id="游戏性"><a href="#游戏性" class="headerlink" title="游戏性"></a>游戏性</h1><p>《以撒》中的元素有哪些呢？道具是为面板属性还有特殊能力服务的，故先来看属性吧。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>首先这个游戏要保障生存，所以要有血量和移速；为了生存还要杀怪，这需要射速和伤害。作为roguelike游戏需要引入更多要素，这先放在“其他”这一项中。简单划分一下，我们能得出基础属性大致能归到这几类中。</p><h3 id="玩家属性"><a href="#玩家属性" class="headerlink" title="玩家属性"></a>玩家属性</h3><p>（粗体字为可拓展可创新点）</p><p>①生存：血量、状态、<strong>受伤机制</strong></p><p>②攻击：伤害、距离、<strong>特效</strong></p><p>③速度：移速、射速、弹速</p><p>④其他：幸运等</p><h3 id="人物特性"><a href="#人物特性" class="headerlink" title="人物特性"></a>人物特性</h3><p>设计更多的可选人物更能激发玩家游戏的兴致，为使人物有特色，一方面要将不同人物的面板区别开来，但更要做的是给人物添加特点。《以撒》在这方面是通过人物初始道具及特性凸显人物的，比如Eve在一血时便能开启Whore of Babyron，???不可获取红心等。</p><p>这里还涉及了人物形象的塑造。总而言之，《以撒》中除Lazarus和Eden外的人物形象都较为独特而讨喜，个人尤其喜欢Eve、Azazel、Magdalene的形象，另外Magdalene和妈妈形象的相似及其恢复系特点则从侧面对剧情有所表现。</p><h3 id="眼泪属性"><a href="#眼泪属性" class="headerlink" title="眼泪属性"></a>眼泪属性</h3><p>除了基础的伤害、距离，特效就需要用到思维发散了。另外，伤害也能通过其他方式得到加成，如生成蓝苍蝇，烧伤或中毒效果。简单盘点一下，《以撒》中有这些个特效。</p><p>1.分裂（分击中分裂与直接分裂）：寄生虫或洛基的角、四眼蜘蛛</p><p>2.穿透（分穿透敌人与穿透地形两种）</p><p>3.击退：狗头</p><p>4.悬浮：反重力</p><p>5.状态变更(中毒/烧伤/迟缓/石化/恐惧）</p><p>6.追踪：弯勺者</p><p>7.蓄力：巧克力奶</p><p>8.爆炸：吐根</p><p>9.制造友军：猫套</p><p>10.变轨：除了各种worm外，还有镜像和妈刀，因为回程也算得上一种变轨</p><p>11.防御：隐形眼镜</p><p>12.吸引：奇异吸子</p><p>13.攻击方式变更：鲁多维科科技</p><p>……</p><p>这些并不好做归纳。但确实非常多样，非常给游戏性加分。</p><h2 id="地图与怪物"><a href="#地图与怪物" class="headerlink" title="地图与怪物"></a>地图与怪物</h2><h3 id="地形与地图结构"><a href="#地形与地图结构" class="headerlink" title="地形与地图结构"></a>地形与地图结构</h3><p>伤害类：刺、血</p><p>障碍：洞、石头</p><p>地图结构的总趋势是越下层地图越大目标房间越难找。而且越往下走，单个房间的难度一般也会更高。结合具体的地图说明或许更有说服力些。</p><h3 id="怪物"><a href="#怪物" class="headerlink" title="怪物"></a>怪物</h3><p>怪物的基础属性和玩家是类似的。所不同的是，怪物的攻击方式一般更加多样，除了“弹幕”，还可以以各种方式冲撞，放硫磺火（血束），招小怪等。</p><p>怪物的免疫方式也各有特色。The carrion queen就是个比较好的例子，虽然很蛋疼。</p><h2 id="道具"><a href="#道具" class="headerlink" title="道具"></a>道具</h2><h3 id="道具渊源"><a href="#道具渊源" class="headerlink" title="道具渊源"></a>道具渊源</h3><p>1.源自宗教：硫磺火、三位一体盾……分天使与恶魔两个方向</p><p>2.源自以撒的生活，包括很多腐烂的事物，如早餐中餐晚餐，Guppy相关的道具等</p><p>3.源自其他文化，包括其他游戏（魔法菇）、流行文化（十二星座）等</p><p>其中第三类看上去有些跟剧情不搭嘎，但也是合理的，不光是因为《以撒》并非剧情向的游戏。星座文化可能有些俗套，但在以撒的视角中，这也没什么问题——以撒作为一个既有普遍性又特殊的美国小男孩，了解这些文化，玩各式各样的游戏是很正常的。</p><h3 id="道具形象"><a href="#道具形象" class="headerlink" title="道具形象"></a>道具形象</h3><p>如果是我来设计这款游戏的话，我会先把道具的功能设计出来，再考虑形象。不过如果捡了道具而角色形象完全没改变，游戏性可能会有所下降。在这个意义上，《以撒》“换装”的特点将其roguelike的特性发挥得更深了一层，虽然这并非游戏的主要功能，但着实是一个很漂亮的bonus。（但是，后面的服装会覆盖前面的，我觉得这样不够好）</p><h2 id="探索性"><a href="#探索性" class="headerlink" title="探索性"></a>探索性</h2><p>《以撒》在游戏要素的展现尚做得还是可以的。一开始玩家只能start game。死亡。重开。死亡。重开。打完妈腿，游戏结束了？子宫解锁。妈心。每次都有不同的结局。黑暗层，教堂。再来是宝箱层，阴间。再之后呢？好像并没有个名义上的终点。虽然打完哪个boss都可能是the end。但相信玩家并不总是有the end的感觉。</p><p>但之后游戏的探索性便比较弱了。毕竟游戏的剧情并不清晰，可探索的元素在游戏后期相对较少了。之后，《以撒》更像是个日常打卡游戏。个人在玩了70h之后感觉游戏要素已经较少了，我也不是成就党，所以游戏基本就扔栈底了。这样看来，《以撒的》生命周期至少有40h，对一些核心玩家而言会较长。</p><h1 id="画面"><a href="#画面" class="headerlink" title="画面"></a>画面</h1><p>血腥、黏着、腐化的环境，却并不阴暗，而是非常明亮，真讽刺啊。</p><p>总体的画风还是比较萌的，但是有的道具，细细一想，好瘆人的。铁丝衣架还好了，眼球突出就比较引人不适了。用可爱的画风吸引玩家并使之适应，同时制造出反差，这也算是游戏的特色吧。</p><hr><p>初稿写于2019年5月4日</p><p>完稿写于2019年7月18日</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并非严谨的考究，只是随便写写而已。&lt;/p&gt;
    
    </summary>
    
    
      <category term="游戏" scheme="https://nessoffice.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="设计" scheme="https://nessoffice.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>【围炉夜话】七月集训自省书</title>
    <link href="https://nessoffice.github.io/2019/07/17/ICPC-Feeling-July/"/>
    <id>https://nessoffice.github.io/2019/07/17/ICPC-Feeling-July/</id>
    <published>2019-07-17T11:53:37.000Z</published>
    <updated>2019-07-17T13:46:24.129Z</updated>
    
    <content type="html"><![CDATA[<p>（虽然是写给颜学长的作业，但感觉还是写出了些东西的，就把这篇放上来了。dl们轻喷鸭qwq）</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记得之前颜学长在群里说集训队中有空余名额而鼓励同学们主动申报时，自己内心还是非常忐忑的。虽然知道自己能力尚不强，短期内也难有较大提升；但还是很想能以此催逼自己学算法，以收获一段不一样的体验。以下，是当时自己对“为何希望参加ICPC”的回答：</p><blockquote><p><strong>1.为何希望参加ICPC</strong></p><p>- 想要收获一段富足的，紧张刺激的体验；</p><p>- 想要结识其他厉害的同学，收获友谊；</p><p>- 想要在算法能力上有进一步的提升，拓宽拓深自身的知识面。</p></blockquote><p>当然，我知道自己的能力还很有限，所以参加集训的主要目的是学习，同时希望在比赛中收获经验，提升自我。不过从七月中我的所为来看，自己仍心有余而力不足，提升得还不够，能力上还是差了厉害的同学一大截。这有心态上的原因，有思维结构上的原因，还和具体的能力也有一定的关联。不论如何，总归是一段经历吧。</p><h1 id="个人赛总结"><a href="#个人赛总结" class="headerlink" title="个人赛总结"></a>个人赛总结</h1><h2 id="contest-1"><a href="#contest-1" class="headerlink" title="contest 1"></a>contest 1</h2><p>这场总体而言打得不好，爆零了。一方面题目不太容易，另一方面自己的知识点还太薄弱，A题将kmp稍作变式就不会了，hash也出锅了。写题策略也不是很得当，一直在纠结没有人做的D题，废了挺多时间的，导致到了挺后面才开始看B题（虽然即便能逃出WA的命运还是躲不过TLE啊）。知识点薄弱，于是在将E题的操作抽象出来后沮丧地发现自己的数据结构水平碰不动这题。</p><p>A题想了想发现可以用last数组记录上一个位置，然后就是字符串匹配了，但是要更新节点。自己之前写的kmp是迭代地算出来的，不支持更新的操作，于是改用hash：$map<deque<int>, int&gt;$，但不知道哪里出了问题，WA了三发。之后换成自己写的hash就过了。STL有些靠不住？</deque<int></p><p>B题一开始看到有点怕，但想了想发现还好，就是个树上的dp，状态的转移很自然，但还是WA了，原因不明。听讲题组说还要先bfs一遍确定顺序，要预处理逆元……虽然这些都做了但还是T了，不知为何，常数太大了？</p><p>D的话一直在推式子，看看这个CNF如何转化为full CNF，但越想越感到它不好描述，就弃了。</p><p>E看了看发现这就是个带修改的区间第k大值问题，不会做，还需要学习。</p><h2 id="contest-2"><a href="#contest-2" class="headerlink" title="contest 2"></a>contest 2</h2><p>第二场作为出题组所以没有打，出的是比较水的H题。即便如此题目还是想了很久才想出来。思维一直比较乱，直到想到2i和2i+1中有且仅有一个odious number后才发现这题好简单。A题想的倒比较快，不过不是很严谨，只是大致觉得贪心是正确的。</p><p>C是二叉树染色（其实跟图论没关系好吧还是有些关系的，考察的算法是线性代数……）。这题如果当时做感觉肯定是不会的（自己肯定是疯狂找规律然后陷入自闭，在听到题解时诧异“啊这题要用矩阵快速幂？”），因为自己没有想到要把root和第i层的节点node看作是一条长度为i的起点为root终点为node的路径。这个抽象很重要。这样抽象之后，便可以把原题转化为一个求定长路径的满足条件的路径数的问题了。根据离散书上的结论，这可以用一个矩阵快速幂算出来。但是，题目所要求的并非叶子节点的路径数，而是所有节点的路径数。故而要求的不能是$A$，而得是$\sum A$。（然后还是不会做，我知道$\sum A = (E - A^{n+1}) \times (E - A)^{-1}$但我不知道在一些情况下逆矩阵并不存在……）而这可以靠矩阵维护，很奇妙。从这题中回（xue）顾（xi）了一下线代中的一些套路。</p><p>在D，火柴人这题上微微锻炼了一下思维。这也是个贪心，不过没A那么显然。有点像求Euler path时的那种贪心：匹配后删边。为什么这样是正确的呢？看感觉吧……然后对于父親节点和父親的父親节点，还有父親的父親的父親节点的操作，他们并不是完全一致的，前两者是把儿子全删掉，后者就删一个儿子。为什么呢？画画图感受一下……所以一个bfs再加个reverse，自底向上地找火柴人再删边就好了。感觉自己对这类题（树上的操作）的理解还不是很深，还需要强化，否则下次碰到变式还是不会的。</p><p>E，并查集（棋盘区间合并）这题比较麻烦，比较锻炼综合能力。读入确是一个麻烦的点，但不应当一上来就搞读入，而要先设计好如何对题目中的操作进行建模。很明显，保存整个棋盘的状态是不可行的，空间不够。需要保存的也只有上一行的状态和这一行的状态。那么怎么将有交集的区间合并起来呢？感觉并查集比较好用，那就并查集吧。合并id，合并id对应的size。在最后找$id == pre[id]$。即可。并不好讲的，略显麻烦的综合题。</p><p>F是连分数的题。这个模型此前从没接触过，看到了一脸懵逼，不过跟着题解走感觉也还好，又学到了一些指不定用得上用不上的套路。先是找规律，发现分子/分母各满足一种递推关系。于是可以用矩阵维护这个递推关系。因为要支持单点修改和区间查询，就得把矩阵放到线段树上。也就差不多了。</p><h2 id="contest-3"><a href="#contest-3" class="headerlink" title="contest 3"></a>contest 3</h2><p>第三场感觉手感好一些，不过这场出了点锅，主要是A题，把一周前的原题摆出来这是认真的么……秒完A就是看E，思考了一段时间后顺利AC；再来是F，思考了更长时间结合了一些奇技淫巧后也成功AC。但做完这三题就没题做了……C拿手推SG函数推得手抽筋还没发现规律。B题看到suffix就心烦不想看。G没经验，不会。这场虽然我做得还可以，不过学长们感觉不行，一找找出好多道原题……集训前练了练和期望相关的题目，也学了学整出分块，A也有补。总体来说运气的成分也占了一定的比重吧。</p><p>秒掉了A题然后就是看E，没有想到容斥，感觉似乎能递推？设规模为n时答案为$f[n]$。考虑男一，他的位置是随意的。有$\dfrac{1}{2n-1}$的概率女一坐在男一旁边。这时候答案就是$Df[n-1]$。可若是女一不坐在男一边上呢？考虑把男一旁边的位置和女一旁边的位置合并为一对位置。无论是否cp坐在这个位置上，它对于答案都没有贡献。记有这样一对“坏位置”时规模为n的答案为$g[n]$。同样地，我们对$g[n]$进行化归。即可得到这样的递推方程$g[n] = \dfrac{1}{2n-1}f[n-1] + \dfrac{2n-2}{2n-1}g[n-1]$。而$f[n] = \dfrac{1}{2n-1} D f[n-1] + \dfrac{2n-2}{2n-1}g[n-1]$。初始条件想一想，两个式子同时遍历一波，答案就出来了（数竞的时候总要从这样一组递推方程中得到封闭公式，有了计算机的算力反而递推方程是更容易理解也更容易搞出答案的形式，学科有别啊学科有别）。</p><p>写完了E看F，也是期望dp。一开始算出来没有模MOD，算出来跟答案不一样，看了好一会儿才发现问题出在哪（好尴尬，估计出题人看到我的request会想笑）。想清楚了之后发现式子很好推，和整除分块好像。简单码了一码，交了上去，RE了，才发现没有把E换成calc_E。之后再是本地调，预处理了一下逆元以降低复杂度，然而又出锅了：inv预处理得不够大。于是之后代码就变成了算逆元又有费马小定理又有线性预处理的神奇版本……即便如此算得还是很慢。用clock_t算了一算，发现预处理很快，后面算很慢。于是用unordered_map记忆化一波，成功AC。</p><p>C还没补，状态的转移有两类，一类涉及增加的，要考虑边界。边界不会考虑，于是算出来的结果很奇怪很奇怪，不知怎么调整。</p><p>D涉及到快速求解大整数的质因子，还不会……</p><p>G感觉有些套路？线段树维护矩阵连乘。开始看到没想法，但其实和contest 2的F很像很像的。如果早点补题或许能把这题搞出来的……这样就不用纠结在C上面了。</p><h2 id="contest-4"><a href="#contest-4" class="headerlink" title="contest 4"></a>contest 4</h2><p>第四场比较难，一开始看题感觉啥也不会，慌得不行。大家做出来的题普遍不多，我也只做了一题，但是做得比较慢，因为对题意开始有些不理解，然后调参还调了很久。这场的节奏被几个陈题带偏掉了，于是大家都在看C和E，没有看（出题人说比较简单）的F和G。状态比较差，做完D之后就陷入了没题做的尴尬境地，想群论死活想不明白。B的复杂度也搞不对，C也是毫无头绪。其他题没有仔细看，又是决策失误啊决策失误。</p><p>作为签到题的D并不难，但我开始没有看出这是签到题，因为一开始没有正确理解题意，没想到只要求个$\Delta \theta$就好，反而七想八想想到奇怪的地方去了，给出题人send request还很尴尬地被no response。理解了题意就好做了，划两条公切线（开始只划了一条公切线，没有把微积分的本质掌握啊我orz），找一下几何关系，注意一下什么时候$\theta$要换成$\pi - \theta$，就差不多了。我一开始把概率的递推关系搞错了，导致$\sum P \not = 1$，搞了好一会才想明白。没有把微积分实质掌握还有一个反映，就是我以为区域是对称的然而并不是，只有下半边能取，上半边是取不得的。在这上头（$/ 2\pi$，不是$/ \pi$）又debug了老半天，拿python当计算器疯狂手工计算。虽然这点是比赛结束后才想到的，不过能凑出答案也是不错的。做得实在是慢啊。不过也算涨了些经验，之后碰到这类涉及浮点数的题时候会更顺手些吧。</p><p>E看着是个群论题？变换了好久才发现这个变换的实质：交换一三列，三列同时取反。然后就不会了……在四元那八种等价元素间一直在找特征值，死活找不到……这题还没补。</p><p>C有一万个人做出来但其实好难的咧……听说cjb，jsb他们当年都没人做出来……卡在这鬼题目上卡了一万年，心塞塞。</p><h2 id="contest-5"><a href="#contest-5" class="headerlink" title="contest 5"></a>contest 5</h2><p>又爆零了，菜本菜呀……</p><p>两个线代题都不会，第一个，A完全莫得想法。第二题，E对除法的处理不很恰当。想着凑出一个线性组和满足答案的形式，但怎么想怎么不对。而把未知量和已知量分离，再跑个高消则能解出答案。代码量略大，但思维难度不大，应当要想出来的。我不只是微积分没有掌握本质，线代也根本没有学清楚啊……这题补了却无法在99上面跑，也不知程序是否正确。</p><h2 id="contest-6"><a href="#contest-6" class="headerlink" title="contest 6"></a>contest 6</h2><p>虽然没有爆零但还是菜。</p><p>一来先把题目顺着过了一遍，A看着就慌，跳。B看着感觉比较套路，但没想法，也跳。C好可怕跳掉了。看到D还是稍稍有一点想法的，然后就死在这上面了。G看了看感觉做不出来，跳。E是关于LCS的较灵活的题，可能能做？但dp太差想问题想得乱七八糟的，也跳掉了。F被题意坑惨了……就算做题策略得当，我还能做出哪道题呢？也就罚时少一点吧。硬实力实在不行。</p><p>D题想了想，枚举最长边，枚举次长边，数形结合一下，可以直接找最短边。没有关注到数据范围的50000。一直WA一直WA，WA到怀疑人生。难道是这个-1的问题？嗯……终于T了！然后就没想法了，尝试分块，WA，再分块，WA，比赛结束。答案还没看。</p><p>F题发现题目中的点构成了一个特别特殊特别特殊的六边形。然后一个点染色，一个连通块的颜色就确定了！这样贪心地做就好了。一开始dfs，WA了。百思不得其解。之后感觉bfs更靠谱些，还是WA，奇怪奇怪。之后扫了一下classification，发现随意输出答案也是要顺序的……晕死了，浪费了一个小时加两发才A掉。这样下来F2也有想法了：对于每个连通块，维护一个结构，包含了未选区域的最小元、选区和未选区元素个数差、选了的区域和未选的区域。看上去很完美，叠了一层又一层的STL。然而……WA掉了？没有发现问题出现在哪里。</p><h1 id="对自我的剖析"><a href="#对自我的剖析" class="headerlink" title="对自我的剖析"></a>对自我的剖析</h1><p>（也就是颜学长强调的要写的“自己的长处短处”“以前认为的上一项”。不过我没有“以前”，就只好从零开始剖析自己的长短处了；作为非春季集训队成员，互评的任务也是没有的）</p><p>直视自己的弱小，找出权值最高的薄弱点，找出合理有效的解决方案，这是必要的。咱虽然能力不行，但可不能心态也不行呀。</p><p><strong>字符串</strong>：只会最基础的复杂度颇高的操作，对前缀函数等字符串相关知识点的理解还不够深。对较灵活的题目缺乏经验。亟需强化。</p><p><strong>动态规划</strong>：对动态规划没有很好的总结与系统性的认识，一般都是瞎搞而无法系统地对其进行分析与归纳。因为认识不深，能否做出题比较看运气。</p><p><strong>数论</strong>：（身为前数竞选手对于自己对于ICPC中的数论题不精颇感惭愧）打过一些基本的板子，如拓展卢卡斯定理，孙子定理，杜教筛的板子，并能对其有一定的认识，但认识并不深。碰到题目有时会陷入不知从何分析的境地。</p><p><strong>数值</strong>：做过的题不是很多，了解的结论也不是很多。</p><p><strong>图论</strong>：基础的知识基本掌握，但做的题还比较少，做题经验比较匮乏，看到较新颖的题会陷入不知如何分析的境地。</p><p><strong>博弈</strong>：了解一些基本模型，写过少量题，但没怎么做归纳。一般的套路还未掌握。能否想出来比较看运气，看思维是否和题目衔接上。</p><p><strong>计算几何</strong>：写过一些基本的板子：graham，旋转卡壳，最近点对，但对于灵活的题目还缺乏分析的能力。平时做的几何题也较少，经验较匮乏。</p><p><strong>数据结构</strong>：非常薄弱，许多模型都不甚了解。</p><p>总而言之，我并没有特别突出的强项，各个专题的能力差距不大，但对于数据结构和字符串还相当不擅长。</p><h1 id="出题总结"><a href="#出题总结" class="headerlink" title="出题总结"></a>出题总结</h1><p>这次出题还是比较顺利的，看得出来学长们经验相当丰富。一开始是大家各抛出一些idea，我想个了密码题，主要是思路题，但也有细节要处理，也要关注特判。抛完idea的第二天开始讨论，早上大家把自己的题大致说了一说，然后邓老板决定签到题、简单题、中档题的比例与题目的去留。</p><p>我在ICPC上与同学的交流还不是很多，于是听他们开会时有懵逼的感觉，很慌的感觉。大家都是简单讲一下破题的要点，涉及的算法，然后就没然后了。所以看着那些题而一点想法都没有的我颇有格格不入之感。虽然Odious Number看看没想法，但还是接下了邓老板的锅，把这题的题面、数据、标程搞掉。中午想了个dfs的做法，很麻烦，还要大数，用python写慢得离谱。之后观察了一下表中的数，猜出了一个结论，用C重写了一遍。这样出数据和标称的锅便可以拿下了。</p><p>之后又把题目从十六进制的输入输出，还有伪高精的数据范围，改成long long了，这样来放过更多的做法，让题目更签一些。</p><p>顺便也写了一写题解，帮D题审核题面，这是其他的工作。</p><p>感受的话，感觉大家都挺认真负责，出题的流程清楚明白很有可行性，各自的锅也能在ddl前赶完。</p><p>也从这次出题中理解了一些出题人的苦衷，明白比赛过程中为何频频会有announcement了。出题目不易呀……</p><h1 id="其他感想"><a href="#其他感想" class="headerlink" title="其他感想"></a>其他感想</h1><p>听讲座听得十脸懵逼，听着听着就会想睡，感觉思维有些跟不上主讲者的节奏。（听题解也是这样的）知识体系还太薄弱了。这样学得又累，收益又不大，心态又受挫，有些得不偿失的感觉？</p><p>集训的感受……感觉进步不是很大，在思维上的提升还不够显著，没能学到大家看待问题分析问题的思想。平时对题目的畏惧感也没有减轻，看题看题解看着看着就开始神游天外，或水手机，或睡觉……感觉自己还是曾经的自己，能力只线性地提升了一点点，学了些新知识，但对其的理解还不够深，无法举一反三。大家是怎么学习的呢？还没有观察出结论。</p><p>打比赛比较随缘，这不是恶补一下就能改变结果的，所以还是调好心态比较重要。赛后补题没有很紧迫地去做，因为有些心累。有时候会出现意志力下降的情况……这是比能力问题更严重的问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;（虽然是写给颜学长的作业，但感觉还是写出了些东西的，就把这篇放上来了。dl们轻喷鸭qwq）&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="https://nessoffice.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【数学之美】复变函数与拉普拉斯变换-金忆丹版：第一章 预备知识</title>
    <link href="https://nessoffice.github.io/2019/06/29/Notes-Complex_Function-CH01/"/>
    <id>https://nessoffice.github.io/2019/06/29/Notes-Complex_Function-CH01/</id>
    <published>2019-06-29T13:22:58.000Z</published>
    <updated>2019-06-29T14:06:16.836Z</updated>
    
    <content type="html"><![CDATA[<p>学复变函数嘛……首先不能不了解一下复数，复数的概念，复数的运算，复数与平面的关系，差不多了。</p><a id="more"></a><h1 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h1><p>一般来说，复数有三种表示：$x + y i, r(cos \theta + sin \theta i), re^{i \theta}$。三种表示各有其适用范围，前两者分别对应平面直角坐标系与极坐标系，而最后的表示法与极坐标系的表示有共同点也略有区别，一般来说它在运算上最为方便。</p><p>复数的模和辐角本身是独立的刻画复数的单元，故我们可以将二者分离来看。模是对于距离的刻画，很好理解，与模相关的知识要点则多和不等式相连结。至于辐角（$Arg z$与$arg z$），则要规定其范围。这样便可在$x + y i, r(cos \theta + sin \theta i)$两种表示间相互转化。（求辐角的规则有些麻烦，结合实例，比如$\pm 2 \pm 3i$感受更佳）</p><p>三种表示的共轭均非常简单，而能解决许多问题，降低运算复杂度。共轭的概念虽简单，但要灵活运用并不容易。另外，用共轭可以分离实部与虚部。</p><p>需要注意的是，复数更接近向量而非一般意义上的实数，是不可比的。复数集并非偏序集。</p><p>正如我们可以用实数刻画数轴一般，我们也能用复数（向量）来刻画坐标面。这便是复平面，在第三小节中将对其作进一步的探讨。</p><h1 id="复数运算"><a href="#复数运算" class="headerlink" title="复数运算"></a>复数运算</h1><p>将复数视作向量（即用$z = x + yi$看待复数），则加法同乘法非常好进行。至于除法，自然可以硬算，但是考虑$z \cdot \overline{z} = |z|^2$从而推出$z^{-1} = \dfrac{\overline{z} }{|z|^2}$显然更加优美，在计算上也更方便。</p><p>乘积的意义为何呢？在形式上，$z_1 = r_1 e^{i \theta_1}, z_2 = r_2 e^{i \theta_2}$，故而$z_1 z_2 = r_1 r_2 e^{i (\theta_1 + \theta_2)}$。考虑e的指数的意义，则能发现$Arg(z_1 z_2) = Arg(z_1) + Arg(z_2)$。故乘法的意义即旋转。</p><p>在这个意义下，除法作为乘法的逆运算，其意义也与上面相类似。</p><p>复数的乘幂和开方也是需要讨论的话题，比如求-1的四次方根，需要用到开方，而在此之前要先对乘幂有所了解。乘幂的形式，即$z = r e^{i \theta} \rightarrow z^n = r^n e^{i n \theta}$。</p><p>由这一式子可以引出de Moivre公式：，$r^n (cos \theta + i sin \theta)^n = r^n (cos n \theta + i sin n \theta)$，故有$(cos \theta + i sin \theta)^n = cos n \theta + i sin n \theta$，此即de Moivre公式（自然，它可以根据其他方式推出，不过这里我们实际上是是采用欧拉公式来推的）。</p><p>至于开方，经过推导，可以得到n个相异的根，其中第k个根$w_k = \sqrt[n] r  e^{i \frac{\theta_0 + 2k \pi}{n} }, k = 0, 1, 2, \dots, n-1$。把这些根放到复平面上看或可加深对其的理解，对复数乘积的理解。</p><h1 id="点集与复球面"><a href="#点集与复球面" class="headerlink" title="点集与复球面"></a>点集与复球面</h1><p>点集系函数定义域与值域的本质属性。在直角坐标面上，我们定义过点集。类似地，此处我们可以通过复数对其加以定义，只消将$\rho$替换为$|z|$即可。由此我们先后定义了邻域，内点，边界，有界/无界区域，曲线，单/复连通区域。</p><p>图形也可以用复数表示，如$|z - z_0| \leq R$表示一个圆域。在辐角、距离上加以限制，我们不难得到几类简单图形的复数表示。</p><p>（复球面详见书本，没图不好描述）</p><p>复球面的中心思想是将平面上的点与球面上的点做一一映射，从而将虚无缥缈的无穷远点转化为了看得见摸得着的北极点。可以用用$tan \theta$与实数轴间的一一映射与之作类比。</p><h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><p>①de Moivre公式的运用：用$cos \theta$与$\sin \theta$表示$cos 3 \theta$。（手算的复杂度为$O(n^2)$）</p><p>②共轭与模：或者$|z| = 1$或者$|w| = 1$，证明$|\dfrac{z - w}{1 - \overline{z} w}| = 1$。</p><p>③（瞎搞）若复数$z_1, z_2, z_3$满足$\dfrac{z_2 - z_1}{z_3 - z_2} = \dfrac{z_1 - z_3}{z_2 - z_3}$，证明$|z_2 - z_1| = |z_3 - z_1| = |z_2 - z_3|$。</p><p>④复数与多项式间的联系：若$w$为1的一个n次方根，证明$1 + w + w^2 + \dots + w^{n-1} = 0$。</p><p>⑤复数与不等式：证明在闭单位圆盘$D = \{ z \big| |z| \leq 1 \}$上，$|z^2 + 1| \leq 2$。</p><p>⑥数形结合：将$(1 + cos \theta) + i sin \theta$表示为指数形式。</p><p>⑦共轭：证明$\overline{(\dfrac{z_1}{z_2})} = \dfrac{\overline{z_1} }{\overline{z_2} }(z_2 \not = 0)$。</p><p>⑧共轭：证明实系数多项式$P(z) = a_0 + a_1 z + \dots + a_n z^n$若有一根为$z$，则$\overline{z}$也必为其根。</p><p>⑨复数与不等式（不会做）：$z_1, z_2$为复数，证明$|z_1 - z_2|^2 + |z_1 + z_2|^2 = 2(|z_1|^2 + |z_2|^2)$。</p><p>以上数题中，③不知其考点，⑨尚不会做，其他的题目较为灵活，知识点覆盖率也较高，结论也较有用，值得一做。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学复变函数嘛……首先不能不了解一下复数，复数的概念，复数的运算，复数与平面的关系，差不多了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="课程笔记" scheme="https://nessoffice.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数学_分析" scheme="https://nessoffice.github.io/tags/%E6%95%B0%E5%AD%A6-%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>【图灵之路】CF记-其三（2019-07-18更新）</title>
    <link href="https://nessoffice.github.io/2019/06/29/ICPC-Practice_Codeforces_3/"/>
    <id>https://nessoffice.github.io/2019/06/29/ICPC-Practice_Codeforces_3/</id>
    <published>2019-06-29T11:53:40.000Z</published>
    <updated>2019-07-18T05:06:47.786Z</updated>
    
    <content type="html"><![CDATA[<p>退役真快乐呀……</p><a id="more"></a><p>不知不觉，CF已经打了一个半个月。这一个半个月以来我收获了什么呢？我的rating能够反映出我认为我具备的实力了么？我题目补得，总结得怎么样呢？</p><h1 id="round-573-div2"><a href="#round-573-div2" class="headerlink" title="round #573 div2"></a>round #573 div2</h1><p>关键词：博弈，思维，模型转换，心态，其他能力</p><p>cjb他们参与出的<a href="https://codeforces.com/contest/1191" target="_blank" rel="noopener">题</a>，好难呀……其实并不难（第二套补完的题！），但我为何还是做不好呢？前面的题过的还是快的，但之后做得就比较糟糕了。一直卡在D这个博弈题上怎么想也想不出来，没有仔细看E和F。虽然E也是博弈题，过的人更少，但其实第二天看了看我还是比较有想法的。可能是看到翻硬币游戏就有点害怕不敢细想吧，不应该害怕的。F也没有仔细看，其实模型转化一下我也是能做出来的。做题之外的其他能力，良好的心态，自信与任性间的平衡，我还不够，需要提升呀。</p><p>DE两个博弈题均不套路，能够锻炼思维。F要先转换模型，我在比赛时这点做得还不够。F在转换模型后是问区间权值的问题，可以用树状数组处理。</p><h2 id="ABC"><a href="#ABC" class="headerlink" title="ABC"></a>ABC</h2><p>A题太水不讲，C题也就是个模拟，边界注意一下就好了。</p><p>B题是个模拟题，给你三张麻将牌，牌有数字也有花色。问至少还要拿几张牌（自己指定花色和数字）才能凑成一对“koutsu”或者“shuntsu”，前者是三张完全一样，后者是同花色，数字连续。</p><p>看上去用一堆if就能搞定？但如何保证if没有漏掉的呢？我是这么做的，把现有的三张牌按数字排序（这样判数字相差多少更方便），然后判是否它们构成了一对“koutsu”或者“shuntsu”。若无，再两两判，判是否有同花色同数字的牌，或者同花色数字连续（相差为1或2均可）。这样代码也比较清晰。</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>题意：有n堆石子，Alice和Bob轮流选一个有石子的堆，拿走一个。失败条件：当前没有堆有石子可拿，或者当前玩家拿完石子后出现两堆的石子数一样。（初始局面可出现若干堆石子数重复）</p><p>首先考虑这样的一种必败态：A在第一步会马上输掉。第一个条件就是00000……，我们看第二个条件，就是说A无论拿了哪个堆中的石子，剩下必然存在两堆满足其石子数相等。</p><p>简单想一想，如果初始局面中有两堆石子数一样，A必须要从中选一堆拿掉，不然必败。那么A从中拿掉了一个还必败的情况，就有一下四类情形。比如说第一堆和第二堆都是n个石子，那么第一步必败的情形有1）n=0；2）存在第三堆有n-1个石子；3）存在第三堆有n个石子；4）存在有第三堆和第四堆都有m个石子。这些特判并不难进行，在排序之后。</p><p>如果初始局面没有两堆石子数一样，那么A必败的状态是怎样的呢？必然是01234……证明也容易，考虑最小元即可。</p><p>如果初始局面不符合上述两类马上必败的条件，那么我们先忽视第二个失败条件，考虑A和B一直进行游戏后的“最终局面”。事实上，最终的局面必然是01234……的一种排列。为什么？因为最终局面中必然有0，若无，则游戏仍可继续进行。有了0，局面中必然有1，若无，则游戏仍可进行……数归证毕，虽然此处并未给出“最终局面”的定义。</p><p>最终局面的胜负是确定的，因为A和B采取最优策略，他们在局面可向合法局面转化时不会触发第二个失败条件。而如果用局面中的总石子数刻画一个局面的特征值，那么一种局面向另一种合法局面的转化必然使得特征值减一。故而，在特判以后可由初始局面的特征值和最终局面特征值之差的奇偶性判断初始局面为N位置抑或P位置。</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>题意：当前有n个硬币排成一列，给定其正反情况。Alice和Bob可以选择k个连续的硬币，把它们全翻成正面或全翻成反面。如果某玩家在进行操作后，所有硬币的正反性均一致，则其胜利。求A先手，A、B采取最优策略时A能胜利，必然失败，或是能够平局。</p><p>首先，题目有两种情形：游戏结束而不平局时硬币全为正面，或者全为反面。我们在下文中只考虑第一种情形，那么第二种怎么考虑呢？简单，把初始局面中所有硬币都翻转一下，把玩家的操作都翻转一下，就化归到第一种情形了。</p><p>考虑A在第一步能够胜利的情形，这很容易考虑：如果硬币中的0比较少，能够被k个1覆盖掉，也就是说最左边的0和最右边的0距离小于k，A就能马上胜利。我们用$lft[i]$表示i左侧（包括i点）最近的0所在的位置，用$rgt[i]$表示i右侧（包括i点）最近的0所在的位置。A能一步胜利的条件就是$lft[n] - rgt[1] \leq k-1$。</p><p>再考虑一下A在一步之后必然失败的情形，这要怎么处理呢？对A所有可能操作的位置进行判断。比如A把第3~k+2个位置的硬币全翻成0，那么只要判定第1~2个位置和第k+3~n个位置是否能被一段连续的1覆盖即可。这也可以用此前得到的$lft$和$rgt$数组处理。</p><p>如果A在走了一步，B也走了一步之后，局面还没有结束，那么剩下的局面必然是平局的。为什么呢？假设初始位置是N位置，但A走完一步局面还没有结束，那么B的位置是P位置。但是，B可以选择和A完全一致的操作，这样A的位置便成为P位置了。这和前面的假设矛盾！故，A走了一步B也走了一步局面还没结束的情形，必然就是平局。</p><p>以上程序涉及到一些细节没有说明，以代码的形式给出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> LL maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">2</span>][maxn];</span><br><span class="line"><span class="keyword">int</span> n, k, lft[<span class="number">2</span>][maxn], rgt[<span class="number">2</span>][maxn]; <span class="comment">// lft[1][] for the filpped situation</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++)</span><br><span class="line">        s[<span class="number">1</span>][i] = (<span class="number">1</span>^(s[<span class="number">0</span>][i]- <span class="string">'0'</span>)) + <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; maxn;i++)</span><br><span class="line">        rgt[<span class="number">0</span>][i] = rgt[<span class="number">1</span>][i] = len+<span class="number">1</span>; <span class="comment">// init the array "rgt" to avoid special judge</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> flip = <span class="number">0</span>;flip &lt; <span class="number">2</span>;flip++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ptrl = <span class="number">1</span>, ptrr = len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++)</span><br><span class="line">            <span class="keyword">if</span>(s[flip][i] == <span class="string">'0'</span>)</span><br><span class="line">                <span class="keyword">while</span>(ptrl &lt;= i)</span><br><span class="line">                    rgt[flip][ptrl++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">            <span class="keyword">if</span>(s[flip][i] == <span class="string">'0'</span>)</span><br><span class="line">                <span class="keyword">while</span>(ptrr &gt;= i)</span><br><span class="line">                    lft[flip][ptrr--] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(lft[<span class="number">0</span>][n] - rgt[<span class="number">0</span>][<span class="number">1</span>] &lt;= k - <span class="number">1</span> || lft[<span class="number">1</span>][n] - rgt[<span class="number">1</span>][<span class="number">1</span>] &lt;= k - <span class="number">1</span>) ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ans == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> lose = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> flip = <span class="number">0</span>;flip &lt; <span class="number">2</span>;flip++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n-k+<span class="number">1</span> &amp;&amp; lose;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(lft[flip][i<span class="number">-1</span>] &amp;&amp; rgt[flip][i+k] != len+<span class="number">1</span>) lose = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(lft[flip][n] - rgt[flip][i+k] &gt;= k) lose = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(lft[flip][i<span class="number">-1</span>] - rgt[flip][<span class="number">1</span>] &gt;= k) lose = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(lose) ans = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"tokitsukaze"</span>);</span><br><span class="line">    <span class="keyword">if</span>(ans == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"quailty"</span>);</span><br><span class="line">    <span class="keyword">if</span>(ans == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"once again"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><p>题意：平面上有n个点，其坐标给出。每次你可以在平面上圈定一个区域，区域由$x_1, x_2, y_b(x_1 &lt; x_2)$唯一确定，包含了满足$x_1 \leq x \leq x_2, y \leq y_b$条件的所有$(x, y)$。定义$S$为区域$R$中包含的题目中给出的点的集合。定义$R_1 \not = R_2 \Leftrightarrow S_1 \not = S_2$。询问不相等的区域有多少种（除去只包含空集的区域）。</p><p>区域是连续的，不好处理。与$R$相关联的$S$是离散的，相对好处理一些。怎么确定所有可能的$S$呢？我们从$S$中的元素来着手。注意到，y更小的元素被包含时，y更大的元素更可能被包含；而y更大的元素被包含时，y更小的元素可能不被包含。故而，我们可以根据y从大到小对每个点进行遍历。比如y最大的点有4个，忽视下方的点。那么这样可能的$S$有$4 \times 5/2=10$ 种。更一般地，如果“一行”中有k个点，那么可以生成 $k(k+1)/2$个集合。</p><p>至此，我们形成了一个朴素的解决问题的框架：把点按y从大到小遍历，把上一行的点压到下一行中，计算其对答案的贡献。写成伪代码，也就是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; set_of_x;</span><br><span class="line">sort(points, points+n, cmp);</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>, r;l &lt; n;l = r)</span><br><span class="line">&#123;</span><br><span class="line">    r = l;</span><br><span class="line">    <span class="keyword">while</span>(r &lt; n &amp;&amp; points[r].y == points[l].y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!set_of_x.count(points[r].x))</span><br><span class="line">        &#123;</span><br><span class="line">            set_of_x.add(points[r].x);</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += (<span class="number">1L</span>L*k*(k+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个思路看上去非常的正确，但我们要注意到它把上一行直接“压下来”，这个过程是对答案有影响的。比如考虑题目中给出了$(5, 6)(2, 3)(3, 3)$三个点。在处理到第二行的时候，$k=3, k(k+1)/2=6$。但是这6个集合中有与前面枚举的集合重复的！$\{ (5, 6) \}$。</p><p>所以我们不能这么直接粗暴地把上面的行压下来，而是要注意到，枚举这一行的时候，这一行的元素必然要在集合中。故而可以用集合的差去做：要把这行中计算出来的，仅由上面的行的元素所构成的集合减去。</p><p>而这要怎么进行呢？我们再把points按x进行排序，那么，如果一行中的$p_1, p_2$中间夹了一些上一行的点，那么这些点构成的集合要减去，而且只要把它们减掉就能得出答案！这不难证明。（当然，还要关注在此一行最右边的点右上角的点）</p><p>于是，我们需要计算$x_{p_1}$和$x_{p_2}$中夹杂了多少上一行中的点。这要怎么做呢？我们可以把所有x值先离散化，然后用树状数组记录权值（每个点出现与否）前缀和来做。</p><p>上代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span><span class="keyword">int</span> x, y;&#125;nodes[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node&amp; lhs, <span class="keyword">const</span> Node&amp; rhs)</span></span>&#123;<span class="keyword">return</span> lhs.y &gt; rhs.y || (lhs.y == rhs.y &amp;&amp; lhs.x &lt; rhs.x);&#125;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; set_of_x;</span><br><span class="line"><span class="keyword">int</span> x_unique[maxn], n, n_unique;</span><br><span class="line"><span class="keyword">int</span> tree[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;<span class="keyword">return</span> num&amp;(-num);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> begin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = begin;i &lt;= n_unique;i += lowbit(i))</span><br><span class="line">        tree[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> begin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = begin;i &gt; <span class="number">0</span>;i -= lowbit(i))</span><br><span class="line">        ans += tree[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;nodes[i].x, &amp;nodes[i].y);</span><br><span class="line">        x_unique[i] = nodes[i].x;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(x_unique+<span class="number">1</span>, x_unique+n+<span class="number">1</span>);</span><br><span class="line">    n_unique = unique(x_unique+<span class="number">1</span>, x_unique+n+<span class="number">1</span>)-x_unique<span class="number">-1</span>;</span><br><span class="line">    sort(nodes+<span class="number">1</span>, nodes+n+<span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">int</span> sz = <span class="number">0</span>, sz_lst = <span class="number">0</span>;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>, r;l &lt;= n;l = r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x_lst = <span class="number">0</span>, x_now;</span><br><span class="line">        r = l;</span><br><span class="line">        <span class="keyword">while</span>(r &lt;= n &amp;&amp; nodes[r].y == nodes[l].y)</span><br><span class="line">        &#123;</span><br><span class="line">            x_now = lower_bound(x_unique+<span class="number">1</span>, x_unique+n_unique+<span class="number">1</span>, nodes[r].x) - x_unique;</span><br><span class="line">            <span class="keyword">if</span>(!set_of_x.count(x_now))</span><br><span class="line">            &#123;</span><br><span class="line">                set_of_x[x_now] = <span class="number">1</span>;</span><br><span class="line">                add(x_now);</span><br><span class="line">                sz++;</span><br><span class="line">            &#125;</span><br><span class="line">            sz_lst = query(x_now<span class="number">-1</span>) - query(x_lst); <span class="comment">// x_now-1, not x_now</span></span><br><span class="line">            ans -= (<span class="number">1L</span>L*sz_lst*(sz_lst+<span class="number">1</span>)/<span class="number">2</span>); <span class="comment">// sz_lst for the number of points between x_p1 and x_p2</span></span><br><span class="line">            x_lst = x_now;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        x_now = n_unique;</span><br><span class="line">        sz_lst = query(x_now) - query(x_lst); <span class="comment">// don't forget this term</span></span><br><span class="line">        ans -= (<span class="number">1L</span>L*sz_lst*(sz_lst+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">        ans += (<span class="number">1L</span>L*sz*(sz+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="edu-round-68-div2"><a href="#edu-round-68-div2" class="headerlink" title="edu round #68 div2"></a>edu round #68 div2</h1><p>关键词：审题，树状数组归纳，扫描线</p><p>比较水的<a href="https://codeforces.com/contest/1194" target="_blank" rel="noopener">一场</a>，虽说如此rating也没涨多少，一个月才入蓝的辣鸡在此。</p><p>A题数归易证答案为2x。但答案真的是2x吗？应该加入特判：printf(“%lld”, min(2*x, n))。</p><p>C题模拟不谈，瞎搞就好了。（下次变量名不能再叫ptr_s, ptr_t了，敲得慢不说，还易混淆）</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>题意：麻烦，不想复述了。</p><p>这个鬼题目卡到比赛结束才卡出来。第i行若有$cnt_{r, i}$个点，第j列若有$cnt_{c, j}$个点。如果i行j列没交点，答案为$(n - cnt_{c, j}) + (m - cnt_{r, i}) - 1$。如果i行j列没交点，把最后的-1去掉。想这个东西想了半天，碰到边界就捉急，思路混乱的很。我应当清晰哪个是变量哪个是不变量，确定$cnt_{r, i}$和$cnt_{c, j}$不变再来结合有交点/没交点的具体例子看什么时候要-1什么时候不-1的。变量名的意义也要和草稿上的一样才行呀。</p><p>观察数据范围，$n, m$不确定，但$nm$是较小的。所以可以用$vector<char>$来存图。然后预处理$cnt_{r, i}$和$cnt_{c, j}$。一个点一个点扫过去，动态更新答案，这题就没了。</char></p><p>我一开始没有注意到$nm$是小量，以为图存不下，要在线处理。在线该怎么做呢？容易想到要保存$cnt_{r, i}$最大的这行$i_{max}$的信息。这是可以线性扫描得到的。得到了这行的信息，再考察所有$cnt_{c, j}$最大的$j_{max}$列（不一定一列）。因为i行j列没交点答案更优，所以找到没交点的就不必再找了。</p><p>但问题是，$cnt_{r, i}$最大的不一定只有一行，如果有多行怎么办呢？我的办法是把多行的有效信息都压进一行里：我们需要的信息是什么？也就是没有交点的格子。于是可以这般维护最大行的信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(rows[i] == rows[i_max])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)</span><br><span class="line">        <span class="keyword">if</span>(grids[j] == <span class="string">'.'</span>)</span><br><span class="line">            grids_max[j] = grids[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码是正确的，但是还要考虑其他杂七杂八的东西，写起来很麻烦，也容易出错。我一开始grids_max没有初始化，就出锅了。这样的代码也只能节省空间，对于全为$*$的那种图，时间复杂度完全没有降下去。不过个人觉得这个思路还是有一定价值的。</p><h2 id="D-1"><a href="#D-1" class="headerlink" title="D"></a>D</h2><p>题意：当前有n个石子，Alice和Bob先后轮流取石子，无法取者输。一次取的石子数只能是1，2，k。k由题目给定。</p><p>简单的博弈题，需要眼力。</p><p>通过k=4，k=5等情形时候的模拟，我们首先能够观察出来$k \not \equiv 0 (mod 3)$时这个跳k步是完全没有价值的，游戏等价于只能跳1步2步。证明？按n模3的情形分类，慢慢数归即可。</p><p>接下来思考$k \equiv 0(mod 3)$会怎么样。通过对k=3，k=6等情形时候的模拟，我们有理由猜想当前循环节为k+1。证明？按n模k+1的情形分类，慢慢数归即可。</p><p>所以这么漂亮的游戏是怎么构造出来的呢？</p><h2 id="E-1"><a href="#E-1" class="headerlink" title="E"></a>E</h2><p>脑子题，套不套路不清楚，起码之前自己是不会的。每每碰到这种模型便有慌里慌张的感觉，需要归纳总结。上次做到的略有相似的题是哪道呢……</p><p>（扫描线？知识盲区+1，学习ing）</p><p>题意：给定一些水平的线段和竖直的线段，求这些线段围成的图形中有多少个矩形。线段数、坐标点绝对值均$\leq 5000$。</p><p>首先，这是个枚举题，直接枚举两条水平的两条竖直的复杂度显然爆炸，得加速。问题在要如何加速呢？</p><p>一个$O(n^3)$的做法是对每条水平的线段求出与其相交的竖直线段的集合，扔到bitset里。然后枚举一对水平的线段，找与两者均相交的竖直线段的条数。这样的做法可以卡过去，也不知道为什么，比较玄学，菜鸡的我不会分析。</p><p>正常的解法是$O(n^2 logn)$的，和这个数据范围也很搭。我们先来把问题简化一下：如果竖直的线段是无限长的，那么我们若是枚举一对水平线段，便可以求两条水平线段的公共线段$[l, r]$。可以用树状数组在$O(logn)$的时间求出与之相交的竖直线段条数。这是一个（经典的？）子问题。</p><p>但现在竖直的线段不是无限长的，它要满足一定的约束条件：和我们枚举的两条水平线段在y轴上的投影均有交。这样的话，我们便不能预处理出树状数组了，而是要动态地更新。如何操作呢？把水平线段按y升序排序，每次枚举一对水平线段会得到$[y_1, y_2]$的一个区间，其中竖直线段必须要包含这个区间。根据这个需求，我们又可以将竖直线段按y2升序排序……下面的内容繁而不难，用文字较难表达出来，笔者便不再说明了，详见代码。这题最重要的是先要想到枚举的顺序，然后是看出树状数组能够处理这一问题，最后才是考虑各式各样的细节。</p><p>（对了，使用树状数组先要把坐标都转化为正值）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span><span class="keyword">int</span> x1, y1, x2, y2;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_by_y</span><span class="params">(<span class="keyword">const</span> Node&amp; lhs, <span class="keyword">const</span> Node&amp; rhs)</span></span>&#123;<span class="keyword">return</span> lhs.y2 &lt; rhs.y2;&#125; <span class="comment">// both for vert and hori</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; hori, vert;</span><br><span class="line"><span class="keyword">int</span> tree[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;<span class="keyword">return</span> num&amp;(-num);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> begin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = begin;i &lt; maxn;i += lowbit(i))</span><br><span class="line">        tree[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> begin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = begin;i &gt; <span class="number">0</span>;i -= lowbit(i))</span><br><span class="line">        ans += tree[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x1, x2, y1, y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">        x1 += <span class="number">5001</span>, y1 += <span class="number">5001</span>, x2 += <span class="number">5001</span>, y2 += <span class="number">5001</span>;</span><br><span class="line">        <span class="keyword">if</span>(x1 &gt; x2) swap(x1, x2);</span><br><span class="line">        <span class="keyword">if</span>(y1 &gt; y2) swap(y1, y2);</span><br><span class="line">        Node node = (Node)&#123;x1, y1, x2, y2&#125;;</span><br><span class="line">        <span class="keyword">if</span>(x1 == x2) vert.push_back(node);</span><br><span class="line">        <span class="keyword">if</span>(y1 == y2) hori.push_back(node);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(hori.begin(), hori.end(), cmp_by_y);</span><br><span class="line">    sort(vert.begin(), vert.end(), cmp_by_y);</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, sz1 = hori.size(), sz2 = vert.size();i &lt; sz1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(tree, <span class="number">0</span>, <span class="keyword">sizeof</span>(tree));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i2 = sz1<span class="number">-1</span>, j = sz2<span class="number">-1</span>;i2 &gt; i;i2--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; vert[j].y2 &gt;= hori[i2].y1)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(vert[j].y2 &gt;= hori[i].y1 &amp;&amp; vert[j].y1 &lt;= hori[i].y1)</span><br><span class="line">                    add(vert[j].x1);</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> l = max(hori[i].x1, hori[i2].x1), r = min(hori[i].x2, hori[i2].x2);</span><br><span class="line">            <span class="keyword">if</span>(l<span class="number">-1</span> &lt; r)</span><br><span class="line">            &#123;</span><br><span class="line">                LL num = query(r) - query(l<span class="number">-1</span>);</span><br><span class="line">                ans += (num*(num<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="round-574-div2"><a href="#round-574-div2" class="headerlink" title="round #574 div2"></a>round #574 div2</h1><p>感觉<a href="https://codeforces.com/contest/1195" target="_blank" rel="noopener">这场</a>的题都非常毒，题面不太好理解，看题面能看个半天。但为何大家还是过得这么快呢orz……</p><p>A题题意不太理解，稀里糊涂搞出来的……B题是个解方程没啥好讲的，怕sqrt出锅于是加了个误差检测但似乎并没必要？C题为啥也这么多人做出来呀orz……D题也是……碰到相性不佳的一场真是尴尬呀。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>题意：有2n个数，排成两行，每行n个。让你从中任取若干数，使得其总和最大，并且没有两个数在同一列。</p><p>本来以为两条对角线比一比就好了，没有想到这样的情况，思维不够缜密：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9 1 1</span><br><span class="line">1 1 10</span><br></pre></td></tr></table></figure><p>嗯……那我们来dp吧。考虑$dp[0][i]$是选取第i列上面元素时前i列的最大值，$dp[1][i]$是选取第i列下面元素时前i列的最大值。那么略加思索，我们可以列出这个式子：</p><p>$dp[0][i] = h[0][i] + min(dp[1][i-1], dp[1][i-2])$</p><p>为什么这样就可以了呢？数归一下或许就能理解吧……</p><h2 id="D-2"><a href="#D-2" class="headerlink" title="D"></a>D</h2><p>（鸽）</p><h2 id="E-2"><a href="#E-2" class="headerlink" title="E"></a>E</h2><p>题意：给定$n \times m$的矩阵，每个格子上面有数。让你求所有$a \times b$的子矩阵中最小值的和。（鬼题意看了好久才看明白……我英语太差了）</p><p>我们能否先处理出每个$a \times 1$的子矩阵的最小值，把它压成一个数，然后求这b个数所组成的新的$1 \times b$的子矩阵的最小值呢？这样就变成了RMQ问题了？不过是RMQ套RMQ而已。复杂度$O(n^2 logn)$。</p><hr><p>初稿写于2019.06.04</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;退役真快乐呀……&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="https://nessoffice.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【图灵之路】CF记-其二（2019-06-29更新）</title>
    <link href="https://nessoffice.github.io/2019/06/29/ICPC-Practice_Codeforces_2/"/>
    <id>https://nessoffice.github.io/2019/06/29/ICPC-Practice_Codeforces_2/</id>
    <published>2019-06-29T11:53:38.000Z</published>
    <updated>2019-07-16T14:25:58.688Z</updated>
    
    <content type="html"><![CDATA[<p>下分真快乐呀……</p><a id="more"></a><h1 id="round-567-div2"><a href="#round-567-div2" class="headerlink" title="round #567 div2"></a>round #567 div2</h1><p><a href="https://codeforces.com/contest/1181" target="_blank" rel="noopener">戳我做题</a></p><p>（总算，分又升回来了。虽然还是刚进来的水平……）</p><p>A题是个还不错的签到题，让我想了一小会。对于第二问，在模的意义下思考可能更容易想。</p><p>B题……见着大数就烦。思路很简单，但是代码并不容易写。把数位的存储顺序弄乱了，捣鼓了半个多钟头。之后用python又写了一遍，还是python优雅呀。</p><p>C题当时看着有些烦，不过想了想感觉还是能做的。分析的思路就是从分析width=1的flag要满足什么条件，再到分析flag的width更长时答案怎么算。简单的预处理即可。</p><p>然后要注意这题的一个大坑点……预处理完一段颜色的len中，得到可能的flag中每段的长度为len1, len2, len3，注意构成flag的条件是len1==len2&amp;&amp;len3&gt;=len2而非len1==len2==len3！为什么？因为最后一段不需要完整。</p><p>（不会做，D题鸽）</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>这题的代码不难（easy version），但并不好想，或许可以锻炼思维能力吧。</p><p>思考一下题目中怎样能把两个territory merge在一起呢？就是它们要有一条公共边，横或纵。我们把只包含一个castle的territory或是由多个按上述规则merge而来的territory称为good。那么，如果一个大的territory能够通过一条横/纵的边分为两个good territory，则这个territory则good……</p><h1 id="round-568-div2"><a href="#round-568-div2" class="headerlink" title="round #568 div2"></a>round #568 div2</h1><p><a href="https://codeforces.com/contest/1185" target="_blank" rel="noopener">戳我做题</a></p><p>A排序一下，然后容易证明左右两点向外扩展能够得到最优解。</p><p>B的话原文中的一个字母可以得到若干位相同的字母，于是可以把同一类的原文划为一组……</p><p>C是贪心的思路，首先把占时长的人都筛掉。于是我一开始就维护了两个堆，一个大顶堆一个小顶堆，两个堆之间元素换来换去，于是就T了……连总时长大于M的情况都没筛。</p><p>但是根据此题的特点，$0 &lt; t_i \leq 100$，直接遍历即可，根本不需要维护堆。而且这样和桶排的思想也很类似，怪我没想到桶排咯……</p><p>D这题略恶心，因为有个干扰项，如何把这个干扰项去掉呢？我们关注公差d。如果d是a0，a1的距离，那么下面的判断就很方便了。如果不是，要么a0是干扰项，要么a1是干扰项，特判一下后面的距离是否均为d即可。</p><p>特判完后得到d为a0a1距离，怎么找出干扰项ak呢？注意到，$a_{k-1}a_k \not = d$，然后就好啦。注意一下细节。</p><h2 id="E-1"><a href="#E-1" class="headerlink" title="E"></a>E</h2><p>题意是给定一个矩阵，每次可以在上面画一条蛇，也就是任取一块$1 \times c$或是$r \times 1$的区域标上字母：a, b, c…画蛇是没有限制的，也就是可以在有字母的区域上标上新的字母。然后给定一张已经按照a, b, c…顺序画出蛇来的矩阵，问能否从中反推出每次画的蛇的坐标（r1, c1, r2, c2）。</p><p>考虑反推的思路，看矩阵中最大的元素，比如说，’d’。它必得连续地占据一行或是一列，如不然，矛盾。那么，如何判断它是否连续地占据了一行呢？首先，它必然只占了一列。于是，可以设col_occupied[maxn]和num_of_col_occupied来判断它占了几列，占了哪几列。如果它只占了一列，那么可以再遍历出它在这一列中row最小的行r1与row最大的行r2（这也正是所需输出的）。然后，从r1遍历至r2，即可判断’d’在此行中是否连续。</p><p>这样最大的元素可以确定了，那么第二大的元素，’c’怎么确定呢？不同于’d’在矩阵中出现的必然性（由’d’的最大性可得），’c’不一定会出现在矩阵中，因为它们可能都被’d’覆盖掉了，这样输出r1[‘c’] = r1[‘d’]即可。这是一种情况，至于’c’出现在矩阵中的情况，可以用类似判断’d’是否连续占据一行/一列的方法判断’c’是否只占据了一行/一列。</p><p>但是’c’不一定连续。因为比如’c’是横的，’d’是纵的，’d’可以覆盖部分的’c’。同时，我们在之前的操作中不能把’d’简单地替换为字母序更小的字母，这样很容易造成结果的错误。那么，如何处理呢？</p><p>比如说，’c’至占据了一列，其所出现的row最小的行行号r1，row最大的行行号r2。在[r1, r2]间出现了不是’c’的字母，有两种情况。第一种，无法从该矩阵中还原出蛇的画法。第二种，这个字母本来是’c’，但是被覆盖了。注意覆盖它的字母只能是字母序比它大的字母。</p><p>然后至于更小的字母，跟上面的处理方法是相似的。</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><p>考虑单个pizza，怎么判断它能否please多少人呢？比如ingredient为1，3，5，那么可以将这个pizza编码为一个price = price, bitinfo = 000010101, index = index的node，这样的node至多1&lt;&lt;9个，因为碰到bitinfo相同的pizza可以只取price更小的。bitinfo和pleasures的关系又如何呢？比如一个friend喜欢的ingredient可以编码为000000101。那么上面这个pizza就可以please他。两个pizza的话，考虑两个bitinfo取&amp;即可。</p><p>这样本来的枚举量是m^2，现在只是(1&lt;&lt;9)^2了，计算量少了好多呀！这都是bitinfo去重的功劳。虽然枚举量大大减小了，但怎么确定这种组和较另一种更优呢？首先是看pleasures的数目，这需要预处理每一种bitinfo所能please的人数，而这可以在读入每个人的时候处理</p><h1 id="round-569-div2-鸽"><a href="#round-569-div2-鸽" class="headerlink" title="round #569 div2(鸽)"></a>round #569 div2(鸽)</h1><p><a href="https://codeforces.com/contest/1180" target="_blank" rel="noopener">戳我做题</a></p><p>（第一套补完的题……留念）</p><p>A……嗯……很可爱，很纯真，在这样险恶的世界里是存活不了几分钟的……</p><p>B：给你一个数列{a}，可以把每位a[i]替换为-a[i]-1，问怎样替换能使得$\prod a_i$最大。</p><p>yy一下，负数的绝对值更大，所以负数越多越好。如果n为偶数，全部为负就好。n为奇数的话，至多保留一个正数，取绝对值最大的maxv还是最小的minv呢？（先把所有数都转为负数，方便讨论）把全部数乘一块，记作pi，把maxv转换为-maxv-1后|pi’| = |pi / maxv * (maxv-1)|，把这个式子和把minv转换的式子对比一下，带个值进去，就能发现转换maxv能得出更优解。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>给定双端队列，给定操作：将首位元素与第二位元素出队，将较大元插在队首，较小元插在队尾。问k次操作后队首前两个元素。</p><p>显然，队首元素单调不减，而最大元被垒到队首之后，操作等价于在把后n-1个元素形成的队列中的队首放到队尾，可以用模运算模拟。前面模拟的步数不超过n，用链表实现复杂度为$O(n)$。</p><p>P.S.deque真快，还不用特判，爱了爱了。</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>给你n*m的矩阵，你一开始在(1, 1)这个位置，每次可以用(dx, dy)跳一跳，比如(dx = 2, dy = 3)，就能从(1, 1)跳到(3, 4)了。每个(dx, dy)跳了一次就不能再跳了，比如你不能一直(-1, 0)这么跳。问你能否跳过所有点一遍。</p><p>找规律试试？考虑1*m的矩阵，怎么跳呢？因为不能一路(0, 1)，我们需要找到有规律的跳法。考虑$(1, 1) \rightarrow (1, m) \rightarrow (1, 2) \rightarrow (1, m-1) \rightarrow …$，这种跳法是可行的，它好在哪里呢？它对于一些难以用到的(dx, dy)的利用率高，一开始的$(0, m-1)$显然只能用一次，后面的也一样（其实是化归到子问题了，把(1, m)这样一个问题化归到(1, m-1)了，只是翻折了一下）。</p><p>于是对于n*m的矩阵我们也能遵循类似的跳法：$(1, 1) \rightarrow (n, m) \rightarrow (1, 2) \rightarrow (n, m-1) \rightarrow …$。（不过这样的话，每一步无法化归到子问题，只有遍历完两行后才算是化归到子问题）注意对奇偶分类讨论。</p><h2 id="E-2"><a href="#E-2" class="headerlink" title="E"></a>E</h2><p>有一个食堂，里面有n道菜，每道价格不一样，每道只有一样。有m个学生，各有bi块钱。学生买菜的策略是，总是买他买得起的最贵的菜。然后题目有q次询问，每次可以改变一道菜的价格或者一个学生的金钱数。问改变之后所有学生买完菜后，剩下的最贵的菜的编号。</p><p>（什么鬼食堂，每道菜只有一样，菜的价格还能差个几千几千的。学生也挺牛逼，每次只买一样菜。这很不社会主义啊。）</p><p>首先，题目中提到了学生是排着队买的，但通过yy我们能够知道，不论学生的顺序如何，他们全体买的菜都是那几样（个体在调整顺序后买到的菜可能会发生变化）。我们想想能否二分答案：从0-maxn中，最贵的还没有买的菜的价格是多少？这样的区间查询要怎么进行呢？我们可以搞个线段树，第i棵树上搞个标记，学生有i块钱就-1，存在有i块钱的菜就+1。如果标记&gt;0，就说明有菜剩着。这样进行区间修改也比较方便。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, q, a[maxn], b[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span><span class="keyword">int</span> l, r, v, lazy;&#125;tree[<span class="number">4</span>*maxv];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[index].l = l;</span><br><span class="line">    tree[index].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    build(index &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    build((index &lt;&lt; <span class="number">1</span>)+<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> target, <span class="keyword">int</span> mark)</span> <span class="comment">// mark == 1 ? meal : pupil</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[index].r &lt;= target)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[index].v += mark;</span><br><span class="line">        tree[index].lazy += mark;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    down(index);</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[index].l + tree[index].r) / <span class="number">2</span>;</span><br><span class="line">    change(index &lt;&lt; <span class="number">1</span>, target, mark);</span><br><span class="line">    <span class="keyword">if</span>(target &gt; mid)</span><br><span class="line">        change((index &lt;&lt; <span class="number">1</span>)+<span class="number">1</span>, target, mark);</span><br><span class="line">    tree[index].v = max(tree[index&lt;&lt;<span class="number">1</span>].v, tree[(index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>].v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(tree[index].l != tree[index].r)</span><br><span class="line">    &#123;</span><br><span class="line">        down(index);</span><br><span class="line">        <span class="keyword">if</span>(tree[(index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>].v &gt; <span class="number">0</span>)</span><br><span class="line">            index = (index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            index &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (tree[index].v &gt; <span class="number">0</span>) ? tree[index].l : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, maxv<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a+i);</span><br><span class="line">        change(<span class="number">1</span>, a[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, b+i);</span><br><span class="line">        change(<span class="number">1</span>, b[i], <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cmd, i2, x, *c, mark;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;cmd, &amp;i2, &amp;x);</span><br><span class="line">        c = (cmd == <span class="number">1</span>) ? a : b;</span><br><span class="line">        mark = (cmd == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        change(<span class="number">1</span>, *(c+i2), -mark);</span><br><span class="line">        *(c+i2) = x;</span><br><span class="line">        change(<span class="number">1</span>, *(c+i2), mark);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ask());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[index].l == tree[index].r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[index].lazy == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[index].l + tree[index].r) / <span class="number">2</span>;</span><br><span class="line">    change(index &lt;&lt; <span class="number">1</span>, mid, tree[index].lazy);</span><br><span class="line">    change((index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>, tree[index].r, tree[index].lazy);</span><br><span class="line">    tree[index].lazy = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="round-570-div3-鸽"><a href="#round-570-div3-鸽" class="headerlink" title="round #570 div3(鸽)"></a>round #570 div3(鸽)</h1><p><a href="https://codeforces.com/contest/1183" target="_blank" rel="noopener">戳我做题</a></p><p>（水题好多，在细节上处理地不是很好以致没有一发ac。不知假如参加的话能不能把E/H苟出来）</p><p>A：计算比给定数大的，最小的，满足各数位上的数之和模4余0的数。</p><p>这题注意一下数据范围，无需特判，枚举即可……</p><p>B：给定一个数列{a}还有一个数k，问能否将所有a[i]替换为b使得$|a_i - b| \leq k$。</p><p>开始想的是二分，但之后发现检测一下上界取不取得到就好了……</p><p>C：你有n格电，每次可以消耗a格并爽一爽或者可以消耗b格但不能爽，已知有k个回合，问你最多能爽几爽。</p><p>贪心地把尽可能多的B换成A就好了，不过要注意数据范围！int的话中间可能会溢出，这是个隐蔽的坑点。</p><p>D：你有若干种糖，每个个数不一。然后你要送礼，每种糖的个数不能一样，问你最多能送出多少糖。</p><p>用个map处理一下，一波遍历，就好惹（但在G上栽了，细节没考虑全？不是很想补……）。</p><p>F：给你n个数，让你选1个或2个或3个，使得选出来的数两两不能整除，求这1/2/3个数的和的最大值。</p><p>莫得思路（对剪枝的复杂度不太明白就没写，网友的思路看不懂）。</p><h2 id="E-H"><a href="#E-H" class="headerlink" title="E/H"></a>E/H</h2><p>题意可以理解为给定字符串，让你求它的长为n, n-1, n-2…的subsequence（不要求连续，比如’acd’是’abcd’的合法子串）有多少个（其实不需要求出全部，求出长为n, n-1, …直至k的子串数目就行了，这里的k不同于题目中的k）。</p><p>枚举组和再判重复杂度看上去大得可怕，我们考虑dp。令$dp[length][char]$表示长度为length，末尾字符为char的子串的数目（这样无法表示空字串，所以要记得特判）。这样就能递推了：顺序遍历给定字符串，读到一个新的字符ch时，若它在第k位，枚举$length = k \rightarrow 1, char = a \rightarrow z$即可。记得length得倒序遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LL ch_tail = str[i];</span><br><span class="line"><span class="keyword">for</span>(LL len = i<span class="number">-1</span>;len &gt;= <span class="number">1</span>;len--)</span><br><span class="line">&#123;</span><br><span class="line">dp[len+<span class="number">1</span>][ch_tail] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(LL ch = <span class="number">0</span>;ch &lt; <span class="number">26</span>;ch++)</span><br><span class="line">dp[len+<span class="number">1</span>][ch_tail] += dp[len][ch];</span><br><span class="line">&#125;</span><br><span class="line">dp[<span class="number">1</span>][ch_tail] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>需要说明的是，长为k的子串在数量级上与$C^k_n$较为接近，而题目中的n可大至100，这样k=50时dp不是会溢出吗？然而事实是上述代码能够ac。私以为，问题在于dp是通过加法递推得到的，可以看作计算机在运算时进行了模处理，这样中间虽然可能出现负数，但是在边界值上仍然是正确的。如果对此感到不放心，不妨对dp取模，这样更保险些。</p><h1 id="round-571-div2-鸽"><a href="#round-571-div2-鸽" class="headerlink" title="round #571 div2(鸽)"></a>round #571 div2(鸽)</h1><p><a href="https://codeforces.com/contest/1186" target="_blank" rel="noopener">戳我做题</a></p><p>（A是什么东西，现在签到题都这么送的吗？？？）</p><p>（B好像是个假题，把好多人坑惨了。幸好这场没打，复习雾理要紧。）</p><h2 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h2><p>给定bit string a与b，a比b长，问a有多少子串满足和b异或以后有偶数个1。（这里的子串必然是连续的，和b等长的。比如a = ‘001100’, b = ‘001’时a的子串仅有’001’, ‘011’, ‘110’, ‘100’四种，它们和b异或后分别为’001’, ‘010’, ‘111’, ‘101’，有偶数个1的仅有’101’一项。）</p><p>直接模拟的复杂度高达$O(n^2)$，稳超时。然后这个操作和线性反馈移位寄存器(LFRS)的操作好像有点像？我们考虑递推。比如a的子串从’001’变到’010’，第一个0变成0，和b第一位异或必然不变；第二位从0变到1，第三位从1变到0，异或后都发生改变。于是，从前一个状态变到后一个状态时异或和中1的个数的改变量即a的原子串满足，此位与下一位相异的位的位数。（有些抽象，拿上面的例子来看能更清晰地感受这种想法）于是可以通过前缀和记录从i位到i+len位中此一位与下一位相异的位的位数。O(n)。</p><p>（因为答案是询问模2余0的cnt个数，而非输出每个cnt，所以代码中的cnt只是与”真正的“cnt模2同余而非相等。）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> str1[maxn], str2[maxn];</span><br><span class="line"><span class="keyword">int</span> delta[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, str1, str2);</span><br><span class="line">    <span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(str1), len2 = <span class="built_in">strlen</span>(str2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len1;i++)</span><br><span class="line">        delta[i] = delta[i<span class="number">-1</span>] + (str1[i] != str1[i<span class="number">-1</span>] ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len2;i++)</span><br><span class="line">        <span class="keyword">if</span>(str1[i] != str2[i]) cnt++;</span><br><span class="line">    <span class="keyword">if</span>(cnt % <span class="number">2</span> == <span class="number">0</span>) ans++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len2;i &lt; len1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt += (delta[i] - delta[i-len2]);</span><br><span class="line">        <span class="keyword">if</span>(cnt % <span class="number">2</span> == <span class="number">0</span>) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过细节处理略麻烦：边界的处理，delta的意义（是第i位与i+1位的异同，还是第i位与第i-1位的异同？）。在手工演算的同时，可以通过调整input中的数据边界判断边界处理是否妥当。</p><h2 id="E-3"><a href="#E-3" class="headerlink" title="E"></a>E</h2><p>有点烦的题。给你一块地，比如说这样一块2×3的地：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">010</span><br><span class="line">110</span><br></pre></td></tr></table></figure><p>然后这块地可以拓展程这样一块(2×2)×(2×3)的地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">010 101</span><br><span class="line">110 001</span><br><span class="line">101 010</span><br><span class="line">001 110</span><br></pre></td></tr></table></figure><p>如果把原来的地记作A，那么拓展后的地就可以记作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A  A&apos;</span><br><span class="line">A&apos; A</span><br></pre></td></tr></table></figure><p>其中A’由与A同行同列全为1的矩阵和A异或得到。</p><p>地可以无限拓展。题目问的给定这样一个子矩阵，知道其左上角坐标，知道其右下角坐标，问子矩阵中1的个数有多少。</p><p>怎么做呢？考虑二维dp。如果能求出(1, 1)到(x, y)这样一个矩阵中1的个数，那(x1, y1)到(x2, y2)的矩阵自然也不在话下。因为题目中x, y高达1e9，所以打表显然不现实。我们能求出来的也就只有$dp[n][m]$这个量级，再大的要怎么算呢？</p><p>注意到，很大的一块地中包含了许多小地。如果能求出小地中1的个数和小地的数目，那也很方便算。而注意到所有经过了一次拓展得到的2n×2m的地中1的个数都是相同的，我们就把这样一块地记为一个基本单元，B，其逆为B’。比如说，x = 6n, y = 4m，那么它包含了3×2个这样的基本单元，不管是B还是B’，里头1的数目都是一样的，这样算出来就是$dp[2n][2m] <em> (6n / 2n) </em> (4m / 2m)$。</p><p>但是大的地不一定都是上面那样规整的，比如，x = 6n + 2，这要怎么办？通过画图我们能得知，这样在竖直方向多出来了一点点，得把它补上。y = 4n + 3也这样处理。x、y都不规整还会多出来一个小矩阵。但多出来每一块的究竟是B还是B’的一部分呢？这可以通过递归得到。比如从左往右数第5个基本单元，它是由第1个基本单元，也就是B’异或得到的，所以它是B。如此。总之细节处理比较麻烦，结合图片理解更佳。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e3</span>+<span class="number">5</span>; <span class="comment">// caution! the basic unit is 2n*2m</span></span><br><span class="line">LL n, m, q;</span><br><span class="line">LL sum[<span class="number">2</span>][maxn][maxn]; <span class="comment">// 0 for original matrix while 1 for inversed matrix</span></span><br><span class="line"><span class="function">LL <span class="title">get_flag</span><span class="params">(LL c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">0</span> || c == <span class="number">1</span>) <span class="keyword">return</span> c;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>^get_flag(c-(c&amp;-c));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(LL r, LL c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    ans += ((c/m)*(r/n)*sum[<span class="number">0</span>][n][m]); <span class="comment">// part 1</span></span><br><span class="line">    LL dc = c % m, dr = r % n;</span><br><span class="line">    LL flag_r = get_flag(r/n), flag_c = get_flag(c/m); <span class="comment">// r/n for the number of fields in the row</span></span><br><span class="line">    ans += ((r/n+<span class="number">1</span>)/<span class="number">2</span>)*(sum[flag_c][n][dc]); <span class="comment">// part 2: the vertical</span></span><br><span class="line">    ans += (r/n/<span class="number">2</span>)*(sum[<span class="number">1</span>^flag_c][n][dc]);</span><br><span class="line">    ans += ((c/m+<span class="number">1</span>)/<span class="number">2</span>)*(sum[flag_r][dr][m]); <span class="comment">// part 3: the horizontal</span></span><br><span class="line">    ans += (c/m/<span class="number">2</span>)*(sum[<span class="number">1</span>^flag_r][dr][m]);</span><br><span class="line">    ans += sum[flag_r^flag_c][dr][dc]; <span class="comment">// part 4</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> grids[maxn];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, grids+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(LL j = <span class="number">1</span>;j &lt;= m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[<span class="number">0</span>][i][j] = sum[<span class="number">0</span>][i+n][j+m] = (grids[j] - <span class="string">'0'</span>);</span><br><span class="line">            sum[<span class="number">0</span>][i+n][j] = sum[<span class="number">0</span>][i][j+m] = <span class="number">1</span>^(grids[j] - <span class="string">'0'</span>);</span><br><span class="line">            sum[<span class="number">1</span>][i][j] = sum[<span class="number">1</span>][i+n][j+m] = <span class="number">1</span>^(grids[j] - <span class="string">'0'</span>);</span><br><span class="line">            sum[<span class="number">1</span>][i+n][j] = sum[<span class="number">1</span>][i][j+m] = (grids[j] - <span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n *= <span class="number">2</span>, m *= <span class="number">2</span>; <span class="comment">// basic unit: 2n*2m</span></span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    <span class="keyword">for</span>(LL j = <span class="number">1</span>;j &lt;= m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[<span class="number">0</span>][i][j] += (sum[<span class="number">0</span>][i<span class="number">-1</span>][j] + sum[<span class="number">0</span>][i][j<span class="number">-1</span>] - sum[<span class="number">0</span>][i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">        sum[<span class="number">1</span>][i][j] += (sum[<span class="number">1</span>][i<span class="number">-1</span>][j] + sum[<span class="number">1</span>][i][j<span class="number">-1</span>] - sum[<span class="number">1</span>][i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        LL r1, r2, c1, c2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>, &amp;r1, &amp;c1, &amp;r2, &amp;c2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, calc(r2, c2) + calc(r1<span class="number">-1</span>, c1<span class="number">-1</span>) - calc(r1<span class="number">-1</span>, c2) - calc(r2, c1<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="edu-round-67-div2"><a href="#edu-round-67-div2" class="headerlink" title="edu round #67 div2"></a>edu round #67 div2</h1><p><a href="https://codeforces.com/contest/1187" target="_blank" rel="noopener">戳我做题</a></p><p>A：给定n个gift，每个包含或者一个A，或者一个B，或者一个A+一个B。现给出n、A、B的数目。问至多要取多少个gift才能保证取到的gift中必然既包含A也包含B。</p><p>看到这题没啥思路……其实考虑最坏情形就好了：连着取到的都是只有A或者只有B的gift。设第一类有a个，第二类有b个，第三类c个。那么输出min(a, b)+1就好了。有点抽屉原理的思想？</p><p>B：给定一个字符串s，比如说是arrayhead。然后有q个查询，每个查询问的是某个字符串t，比如说’aaa’，要原字符串的从头开始的符合条件的子串的最短长度，这个子串包含了s中的所有字符（计数），比如’aaa’的例子答案为8，子串为’arrayhea’。</p><p>容易发现，t中字符的顺序是无关紧要的，重要的信息只有它各个字符出现的次数。于是，我们可以依据某字符频率在原字符串中进行查询，这样的话要先对原字符串进行预处理，得到一个$place[cnt][char]$表示这样的子串的最短长度，其能够匹配频率为cnt的字符char。于是代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> place[maxn][<span class="number">26</span>], occurence[<span class="number">26</span>], cnt[<span class="number">26</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[maxn];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ch = s[i] - <span class="string">'a'</span>;</span><br><span class="line">        place[++occurence[ch]][ch] = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, temp);</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="built_in">strlen</span>(temp)<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ch = temp[i] - <span class="string">'a'</span>;</span><br><span class="line">            cnt[ch]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">26</span>;j++)</span><br><span class="line">            ans = max(ans, place[cnt[j]][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>初稿写于2019.06.04</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下分真快乐呀……&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="https://nessoffice.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【图灵之路】CF记-其一（2019-06-29更新）</title>
    <link href="https://nessoffice.github.io/2019/06/29/ICPC-Practice_Codeforces_1/"/>
    <id>https://nessoffice.github.io/2019/06/29/ICPC-Practice_Codeforces_1/</id>
    <published>2019-06-29T11:53:37.000Z</published>
    <updated>2019-07-16T14:26:10.886Z</updated>
    
    <content type="html"><![CDATA[<p>下分真快乐呀……</p><a id="more"></a><p>（听到颜学长说要看CF rating时我是懵逼的：啥？这是啥？从来没碰过……不过既然选了课也只能硬着头皮上了。打得手很生，rating维持在基础分上……感觉要凉要凉，不过我还能怎么做呢？补题补题，弥补那，相距天际的差距。</p><h1 id="round-563-div2"><a href="#round-563-div2" class="headerlink" title="round #563 div2"></a>round #563 div2</h1><p>第一次玩CF……好紧张……这网站注册五个月了就没登进去过……</p><p>随便写写关于题解的随想吧……</p><p><a href="https://codeforces.com/contest/1174" target="_blank" rel="noopener">戳我做题</a></p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>（分析题，分析出关键的性质就能做了）</p><p>（一开始把题目看错了，看成是模2同余才能交换，心想这不就分奇偶排下序就好了嘛……码完代码就被测试数据piapia打脸）</p><p>不是很有想法。如果所有数奇偶性都相同这个情况是容易考虑的。可如果有奇数也有偶数呢？先考虑1奇n偶的情况吧。1奇1偶肯定能有序，1奇2偶呢？这个要分类讨论了，我的想法是把最小的数先移到最前面，之后化归到规模更小的情形。但是这样有个问题，就是如果最小数是那个奇数，比方说，输入数据为1, 6, 4，貌似会出问题……1, 6, 4能不能排成1, 4, 6呢？瞎搞了一下发现可以，于是乎，发现了一个奇妙的性质：只要序列中有奇数也有偶数，那么通过一个奇数（它的位置不会改变），任意两个偶数间也能交换位置。于是排序就是可行的了。sort之。</p><p>（可还是不知道这题在考什么<del>，群论？</del>）</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>（还是分析题……）</p><p>题目中说，任意两个互素的数，其f值不相等。这个条件初看比较别扭，也比较抽象，还是先把它具象化吧。</p><p>如果是素数的话，它的f值肯定不能和其他素数的f值相等。于是我们令f(2)=1, f(3)=2, …</p><p>至于合数呢？由题意，f的最大值不能过大，我们看看合数的f值能否和素数相等，可令f(合数)=f(该合数的某素因子)，为方便计算，不妨再令f(合数)=f(该合数的最小素因子)，即f(某数)=f(该数的最小素因子)。这样能否满足题意呢？</p><p>可以的！假如两数互素，它们的最小素因子必不同，而f是由一个数的最小素因子决定的。</p><p>这样分析完，上个欧拉筛就完事了。</p><p><del>其实令f(某数)=f(该数的最大素因子)更好算，直接埃氏筛就搞出来了，可是我没想到\cry\cry\cry</del></p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>（前缀和呀前缀和，我怎么就把你忘了呢）</p><p>嗯……题意是让你求一个数列，使得其任意子列全部元素异或后不能和0或x相等，且数列长度尽量长，答案有多组，任意输出一组（还有个条件：所有元素均小于2^n）。比如，x=5时候{6, 1, 3}满足条件，因为它的子列有{6}{1}{3}{6, 1}{1, 3}{6, 1, 3}，异或后分别为6, 1, 3, 7, 2, 4，都不等于5。</p><p>当时被“子列”这个条件困扰了好久，也不知道怎么样让数列长度尽量长（我的想法是，任意新添加一个元素，都会引发矛盾，但是这样复杂度巨大……），一直在玄学思考子列能推出什么，发现如果在数组的中间取标记点，向两边扩展，能够完美匹配题目中的条件，但是这样在细节上很难处理……线性计算复杂度太高，二分也不见得简单。</p><p>看到题目中说前缀和（其实是前缀异或和，不过反正思想是这个思想，将二维的子列化为一维的数组，级数也是这个思想）后，恍然大悟：</p><p>$a_l \oplus a_{l+1} \oplus … \oplus a_r = b_{l-1} \oplus b_r$（$b_i = a_1 \oplus a_2 \oplus … \oplus a_i$，由异或运算的交换律和自反率知，该等式成立）</p><p>这样的话，就不用考虑$a_i$，考虑$b_i$所成的数列就好了呀，因为$a_i = b_{i-1} \oplus b_i$。那么$b_i$，要如何考虑呢？</p><p>由题意，$b_i \oplus b_j \not = 0$，这说明$b_i \not = b_j$（异或的逆元是且仅是本身），还有$b_i \oplus b_j \not = x$，只要保证$b_i \not = (x \oplus b_j)$就好了。于是可以设个vis数组，逐个确定$b_1, b_2, …$，比如$b_1$确定了，那么$vis[b_1] = vis[x \oplus b_1] = 1$，后面的$b_j$不能取$b_1$或是$x \oplus b_1$。</p><p>因为交换$b_i$和$b_j$不影响答案的正确性，所以$b_i$是可以任取的。为方便记，不妨从小到大遍历，发现$vis[k] = 0$则取$b_i = k$。从这个过程可以看出，算法的复杂度为$O(2^n)$。</p><p>从这里也可以看出{b}的长度了。把$i$和$x \oplus i$看作是一对，那么一对中只能取一个。所以$len(b)$=可用的数的数量/2。</p><p>但是还要注意一下细节，题目中的输入数据也提示了：$x \geq 2^n$的时候，无需把$i$和$x \oplus i$看作一对，因为后者根本取不到。这个情况下$len(b)$=可用的数数目。</p><p>（开始把题目的数据看错了，看到18，就想到long long在十进制下约为18位，于是感觉这样的vis开不下，没有进一步往下想。<del>开了vis又如何呢，还不是做不出来</del>）</p><p>手是生了啊。</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>（需要分析的，较为复杂的dp）</p><p>题意稍微有点绕，它提到了一个f(p)，定义略奇特，我们用直观的例子体会一下这个f是怎么算的。</p><p>比如给定排列{6, 2, 1, 3, 5, 7}，求它前i个数的最大公约数，排出来，就是{6, 2, 1, 1, 1, 1}。这里头有三个不同的数，于是$f(p)=3$。</p><p>{1, 2, 3, 4, 5, 6}除了上面那种排列外，还有其他排列，算出来的$f$不尽相同，但总归是有最大值的，记作$f_{max}$。题目问的就是，n-排列中，有多少种排列，算出来的$f$等于$f_{max}$呢？</p><p>我们来看看那个前缀最大公约数的数列，粗略一看，它似乎是单调不增的，这很好证明。再一看，发现$g_i$和$g_{i+1}$是有关系的（$g_i$即前缀最大公约数数组的第i项），就是$gcd(g_i, g_{i+1}) = g_{i+1}$。</p><p>要想$g_i$的取值尽可能多样，我们要让它减少地尽量缓慢。将排列的首项，$a_0$，素因子分解，我们发现，$f = \sum \alpha_i$（算数基本定理的简单应用）。所以$f_{max}$就是$\sum \alpha_i$最大时候的取值。这个是数论上的内容。结论如下：f取最大值时，$a_0 = 2^x \cdot 3^y$，且$y \leq 1$。</p><p>（证明的话，就是替换的思想。如果$a_0$中有其他素数，比如说，5，那么我们可以令$a^{‘}_0=2<em>2/5</em>a_0$，这样$a^{‘}_0$打头时候得出的f必然比$a_0$打头时候得出的要大。同理可以证明$a_0$中3的指数小于2）</p><p>发现了这个结论我们该怎么算答案呢……看看题，感觉要dp？那么怎么指定状态呢？<del>参考题解发现</del>令$dp[i][x][y]$表示排列到前i个数时，最大公约数为$2^x \cdot 3^y$这一状态可以让我们很方便地算出答案。因为每次添加一个数，所以都是$dp[i+1][][] = dp[i][][] + …$，而要取到$f_{max}$，x、y可以保持不变或是x—或是y—，总共三种状态转移的模式。在添加第i+1个数时候，要考虑只能添加取符合要求的数，不能取已经取到的数。归纳一下，也便如下（伪代码，不是AC代码；和$dp[i][x][y]$相乘的那个数就是符合条件的第i+1个数的个数了）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i+<span class="number">1</span>][x][y] = (dp[i+<span class="number">1</span>][x][y] + dp[i][x][y] * (cnt(x, y) - i));</span><br><span class="line">dp[i+<span class="number">1</span>][x<span class="number">-1</span>][y] = (dp[i+<span class="number">1</span>][x<span class="number">-1</span>][y] + dp[i][x][y] * (cnt(x<span class="number">-1</span>, y) - cnt(x, y)));</span><br><span class="line">dp[i+<span class="number">1</span>][x][y<span class="number">-1</span>] = (dp[i+<span class="number">1</span>][x][y<span class="number">-1</span>] + dp[i][x][y] * (cnt(x, y<span class="number">-1</span>) - cnt(x, y)));</span><br></pre></td></tr></table></figure><p>下面是本题的坑点了……</p><p>不能用long long保存数据，会MLE，要用int，但是这样运算时候有可能溢出，怎么办呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i+<span class="number">1</span>][x][y] = (dp[i+<span class="number">1</span>][x][y] + <span class="number">1L</span>L*dp[i][x][y] * (cnt(x, y) - i)) % MOD;</span><br></pre></td></tr></table></figure><p>注意那个1LL……上次校赛的题也是。</p><p>（最后交上去，2s的时限跑了1965ms，也太不好玩了吧！O(nlogn)不是很优雅了么！本来想用bfs稍微优化一下的，但还是懒得弄了……）</p><p>（又把数字看错了，2^18 &gt; 1e6我是怎么算出来的……）</p><p>F题还没补，先放放。（Idleness？）</p><h1 id="edu-round-66-div2"><a href="#edu-round-66-div2" class="headerlink" title="edu round #66 div2"></a>edu round #66 div2</h1><p>模拟题杀我……贪心杀我……</p><p>（为什么edu没有答案啊啊啊啊还有edu是什么意思它和div什么关系啊啊啊啊）</p><p><a href="https://codeforces.com/contest/1175" target="_blank" rel="noopener">戳我做题</a></p><h2 id="B-1"><a href="#B-1" class="headerlink" title="B"></a>B</h2><p>复杂的模拟题……看着很烦，思绪很乱。感觉是对的结果交上去WA了，再改改又WA了。一天后突然想到自己是哪里没想明白，这才AC。</p><p>模拟题很烦，看上去不能够考察能力，但其实是能的。它能考察心态，考察对于问题的分析能力。这些，是我还不够好的。</p><p>先来读题。输出比较简单，那就看输出。输出分溢出与否两种情形。然后溢出也分两类，一类是小数加加加加爆了，还有是循环循出超级大的数然后一加就加爆了。这两类有何区别呢？区别在于，第一类可以直接模拟，而第二类不能直接模拟，需要记录是在哪一层会加爆，然后如果“ADD”出现在这层以上，就置flag=1。</p><p>大致想明白了输出要怎么处理，接下来是看输入了。输入有三类：“ADD”“FOR x”“END”，ADD用以模拟相加（还要看会不会出现上面的第二类情况），for和end共同构成一个循环。根据输入，我们可以设置一个loop[maxn]记录每层for的次数，设置一个looping_now记录当前需要ADD的值，同时记录一个depth_now记录当亲啊层数，设置一个depth_overflow记录加爆了的层数（超过此层，looping_now不再更新）。</p><p>于是我们可以写出这样的伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, cmd, &amp;x);</span><br><span class="line">    <span class="keyword">if</span>(cmd == <span class="string">"ADD"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(depth_now &gt; depth_overflow) <span class="comment">// case 2</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        ans += looping_now;</span><br><span class="line">        <span class="keyword">if</span>(overflow(ans)) <span class="comment">// case 1</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cmd == <span class="string">"FOR"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(overflow(looping_now * x + ans))</span><br><span class="line">            depth_overflow = depth_now;</span><br><span class="line">        <span class="keyword">if</span>(depth_now &lt; depth_overflow)</span><br><span class="line">            looping_now *= x;</span><br><span class="line">        loop[depth_now++] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cmd == <span class="string">"END"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        depth_now--;</span><br><span class="line">        <span class="keyword">if</span>(depth_now &gt;= depth_overflow)</span><br><span class="line">            looping_now /= loop[depth_now];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后便是处理细节了……</p><h2 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h2><p>是个思路题，问的是给定n个x轴上的不同位置的整点，让你找一个整点$p_0$，使得$p_0$到距$p_0$第k近的点的距离，比任意$p_{random}$到距$p_{random}$第k近的点的距离，来得小。k由题目给出。</p><p>简单想想，k=1或k=2的情况很容易考虑，但是如何将其推广到k更大的情况呢？我们注意到一个事实，即沿着一个点向左走，它所后经过的点一定远于它所先经过的点，向右亦然，但是左点的远近与右点的远近间没有关联。</p><p>那么，对$p_0$而言，如果距它第k近的点$p_k$在其右侧，则距它第k-1近的点$p_{k-1}$可以在左侧也可以在右侧。若在右侧，则可以把$p_0$向右移动一位，容易看出，此时$p_k$仍然为距$p_0$第k远的点（证明的话，反证）。于是我们可以重复此操作，直至$p_{k-1}$转移到$p_0$的左侧为止。</p><p>于是这样一来，我们得到$p_0$是被包围在$p_{k-1}$与$p_k$间的一点。让我们忽视$p_1, p_2, …, p_{k-1}$，因为既然它们同在这个“包围圈”中，那么$p_0$在这个“包围圈”中移动到$p_0^{‘}$位置时，这k-2个点的某个排列必然构成$p_1^{‘}, p_2^{‘}, …, p_{k-2}^{‘}$。</p><p>那么现在，问题就简化为：$p_0$在$p_{k-1}$和$p_k$之间，如何取$p_0^{‘}$使得它到两点中更远的点的距离最短？很显然，中点。（此时$p_{k-1}$和$p_k$都是形式上的记号，是固定的点，$|p_0^{‘} p_k|$不一定大于$|p_0^{‘} p_{k-1}|$。但这两点的排列必然构成$p_0$移动到$p_0^{‘}$位置时实际意义上的$p_{k-1}^{‘}, p_k^{‘}$。我们一开始选定的$p_0$是任取的。将此$p_0$进行移动所得到的最优的$p_0^{‘}$才是我们想要的答案）</p><p>然后上面得到的形式上的$p_{k-1}$和$p_k$要怎么确定呢？注意到只要中间包含了k-2个点的点对都可能符合要求，于是一波遍历就好了。</p><h2 id="D-1"><a href="#D-1" class="headerlink" title="D"></a>D</h2><p>给定一个n元数组，让你在其中放一些（k-1）隔板，使得从$\sum 从左往右第i个区块中所有数字的和 * i$最小。</p><p>看到一些数字的和，我们考虑前缀和（$s_i = \sum\limits_{j = 1}^i a_j$），设题目中的分点为$t_1, …, t_k$，则所求即$\sum\limits_{i = 1}^k (s_{t_i} - s_{t_{i-1}}) \cdot i$（$t_0 = 0, t_k = n$）。</p><p>这个式子可以写成$k \cdot (s_{t_k} - s_{t_{k-1}}) + (k - 1) \cdot (s_{t_{k-1}} - s_{t_{k-2}}) + … + 1 \cdot (s_1 - s_0)$。也即$k \cdot s_{t_k} - (s_{t_1} + s_{t_2} + … + s_{t_{k-1}})$。</p><p>其中$t_1, t_2, …, t_{k-1}$是我们选择的分点，$t_k = n$。所以把前缀和排个序就好了。（注意排序是sort(s+1, s+n)而不是sort(s+1, s+n+1)）。</p><p>下面是原思路……</p><p>给定的样例为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 2</span><br><span class="line">-1 -2 5 -4 8</span><br></pre></td></tr></table></figure><p>不难发现，将5，-4，8划分到第二组优于将8划分到第二组。为什么呢？因为5-4&gt;0。从8开始，我们向左找相加为正数的一个点，再找下一个点……这样的贪心思路。</p><p>（结合代码可能更容易理解我的思路，另外sum为后缀和而非前缀和……）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LL a[maxn], sum[maxn], next_node[maxn];</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(LL n, LL k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += (sum[<span class="number">1</span>] - sum[n+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL n_next = n;</span><br><span class="line">    <span class="keyword">while</span>(next_node[n_next] &gt;= k)</span><br><span class="line">        n_next = next_node[n_next];</span><br><span class="line">    ans += k*(sum[n_next] - sum[n+<span class="number">1</span>]);</span><br><span class="line">    split(n_next<span class="number">-1</span>, k<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这里头的next_node数组，我是这么算的，O(n)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LL temp = <span class="number">0</span>, last = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(LL i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    temp += a[i];</span><br><span class="line">    <span class="keyword">if</span>(temp &gt; <span class="number">0</span>)</span><br><span class="line">        next_node[i] = last;</span><br><span class="line">    <span class="keyword">if</span>(a[i] &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = <span class="number">0</span>;</span><br><span class="line">        last = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉并无问题，然鹅交上去就wa了，现在还没de出来。</p><h2 id="E-WA"><a href="#E-WA" class="headerlink" title="E(WA)"></a>E(WA)</h2><p>其实可以把问题做等价的转化，就是思考从x开始，它要经过多少个区间才能”跳“到y点。拿例子来说，比如已有[1, 3], [2, 4]两区间，那么(x, y) == (1, 2)时hop=1，因为经过[1, 3]区间即可，(x, y) == (1, 4)时则hop = 2：从1跳到3再跳到4，或是从1跳到2再跳到4，没有更短的路径。</p><p>在这个问题中，设询问区间的左端点为x，它通过一个区间能“跳”到$z_1, z_2, z_3, …, z_m$这些点（$z_1, z_2, z_3, …, z_m$呈升序）。不难发现，贪心的思路能帮助我们解决问题，即$x-&gt;z_m, z_m-&gt;y$这种跳法必然优于$x-&gt;z_k, z_k-&gt;y$（$1 \leq k \leq m$）。（画个图感受一下更好，证明的话反证即可）</p><p>想到了这点，我们再来想如何进一步地处理这个问题呢。储存所有可能的询问值么？这样复杂度在时间上是$O(n^2)$，空间上也会爆。为了降低复杂度，我们考虑倍增的思路，记录从每个点开始，跳1步，跳2步，跳4步……所能达到的最远点。这样也不难设计出针对每个查询的算法。</p><p>倍增首先要处理边界情形：跳1步所能达到的最远点。考虑将所给区间按$l$从小到大排序（$l$若相同，保留$r$最大的那个区间，其他舍去）。那么若一个点P在一个或多个区间内，选取包含它的$l$值最大的区间[$l_{max}$, $r_{max}$]，则该区间是所有包含点P的区间中$r$最大的（由之前的排序得到）。故P所能到达的最远点，即$r_{max}$。</p><p>（另外，题目中有一些不被任何区间包含的点，我们记它们跳任意距离都会到-1）</p><p>然后是写倍增了，这是较为容易的。（但不知道有没有地方写错了……也检查不出来）</p><p>对于每次查询，我们看x跳一步是否能到达y，如是，则所经路径数+1，返回答案。如否，则会有两种情况：1）x最终跳到了一个”不动点“（$f[x][i] == f[x][i+1]$）；2）存在$i \geq 0$使得$f[x][i] &lt; y \leq f[x][i+1]$。对于前一种情况，我们返回-1（因为这个不动点必然在y左侧，如果不是，那么x会从case 2中退出，或者x跳一步就到达y了）。对于后一种情况，我们把$f[x][i]$代回$x$，进行迭代。</p><p>（这个算法看上去是正确的？然而WA了……）</p><p>（测试数据规模较大故无法拿到。值得一提的是，有output=2而实际应为1的情况，也有output=-1而实际为正数的情况。）</p><h1 id="round-564-div2-鸽"><a href="#round-564-div2-鸽" class="headerlink" title="round #564 div2(鸽)"></a>round #564 div2(鸽)</h1><p><a href="https://codeforces.com/contest/1173" target="_blank" rel="noopener">戳我做题</a></p><p>A注意特判。</p><p>B倒是挺有意思，找规律+假的数学归纳法可以得出一种可能的答案，但它为何而正确呢？（更代数的看）三角不等式。</p><p>C……毒瘤题。总归是贪心的思路，就看开始要浪费多少牌才能开始顺序打出所有牌了。而这可以通过枚举要把哪张牌垒到顶上来算。但是，为什么这样的策略是可行的呢？（我希望构造性的游戏方案，而不是非构造性地给个最优解）</p><p>D的话，我的关注点在“交叉”上，然后想着想着就想到麻烦的方向去了，想到图的结构如此的话该如何如何……而忽视了“树”这一条件。从根结点出发，可以发现，子树中的结点都是占据了“整一块”连续的圆弧的。在这个条件下，如果知道父母结点的位置，子树的个数，还有父母+孩子所占据的圆弧是既定的这一信息，就能列出所有可能的方案数了（记父母节点有k个子节点，则$f(u) =  k! \cdot \prod\limits_{child} f(child)$）。虽然思想是dp，但算一算是能发现公式的，于是打表就好了。</p><h1 id="round-565-div3-鸽"><a href="#round-565-div3-鸽" class="headerlink" title="round #565 div3(鸽)"></a>round #565 div3(鸽)</h1><p><a href="https://codeforces.com/contest/1176" target="_blank" rel="noopener">戳我做题</a></p><p>B又是贪心……数字的位置无关紧要，只有模三余n的数的个数是重要的信息。瞎匹配就好。我想如果把题目中“任意取两数”的条件改成“取相邻两数”，这道题该怎么做？</p><p>E的话我想想把这个图打成树，然后bfs二染色就好了……懒得写bfs就用了dfs，结果居然t了。这时才看到数据规模竟有$T \leq 2e5, n \leq 2e5$之大，这dfs个毛线啊？于是我在读入的时候直接随便染色，居然还是t。把memset去掉换成for，才a……（随便染色是怎么染呢？就那么染呗。如果当前读入的两个点都没染过，一个染0一个染1；如果都染过就跳过；如果一个染过一个没染，把没染的染和染了的染色相不同的染色。容易证明，这样下来符合题意。）</p><h2 id="D-2"><a href="#D-2" class="headerlink" title="D"></a>D</h2><p>“看到这个题，我有一种莫名的近乎落泪的感动。”</p><h2 id="F-WA"><a href="#F-WA" class="headerlink" title="F(WA)"></a>F(WA)</h2><h1 id="round-566-div2"><a href="#round-566-div2" class="headerlink" title="round #566 div2"></a>round #566 div2</h1><p><a href="https://codeforces.com/contest/1182" target="_blank" rel="noopener">戳我做题</a></p><p>（掉分的感觉，真·爽的一批）</p><p>做A的时候，乘法法则加法法则傻傻分不清，我不仅现在离散没学好，高中组和数学也没学好……</p><p>做B的时候想能否边读入便判定，便先找center_c再找center_r，可这样不仅代码长，还要考虑特殊情况。直接通过center的性质找第一个符合条件的不就好了么！做得又慢，做完还错，讨厌模拟题，但又不能秒过它，这样的态度不行的啊。</p><p>做C的时候（读题读了好久……对关键点的挖掘还不够迅速而准确，我的阅读理解能力有待提高）贪心的思想是没问题了，结果在字符长度上出了篓子……这是ICPC不是CTF，毒瘤出题人总喜欢出毒瘤数据。对可变长数组的感觉还不够啊。$vector<char>$，或者$string$。</char></p><p>做E的时候看出它是个矩阵快速幂了，但是把这东西的细节都忘掉了……无奈在比赛结束后20分钟才过sample。不过当时如果做出来也过不了的吧，因为费马小定理的关系。</p><h2 id="C-2"><a href="#C-2" class="headerlink" title="C"></a>C</h2><p>题意：给你若干个单词，让你选四个配成一对。要求是第一个词和第三个词有相同的元音数，第二个词和第四个词有相同的元音数且它们最后一个元音一样（由题意，每个单词至少有一个元音，所以一行中的最后一个元音必然在后面的词上）。问最多能配出多少对。然后输出最多匹配时的任意一种方案。</p><p>题目里有效的信息是单词、元音数、最后的元音。于是我们可以用一个struct来存数据。然后怎么匹配呢？考虑到第二个词和第四个词间的关系更强，我们先匹配出这一类，然后再匹配有相同元音数但是末位元音不一的另一类。</p><p>二四类怎么匹配呢？考虑贪心的思路。按元音数-最后元音进行排序，i从1到n，考虑nodes[i]和nodes[i+1]能不能匹配，能就匹配它们了（同时设vis[i] = vis[i+1] = 1，以防一个单词被重复使用）。不能则说明nodes[i]不能和其它nodes匹配（易证）。这样遍历一遍就匹配出同时能取的最多的二四类了。</p><p>一三类的匹配比较常规，也是贪心的思路，就不谈了。</p><p>匹配完之后我们得到cnt_first个一三类的单词组，cnt_second个二四类的单词组。怎么输出呢？分类讨论呗。若是cnt_first &gt;= cnt_second，输出cnt_second组单词就好了。若是cnt_first &lt; cnt_second，考虑到二四类的单词比一三类强（也就是，二四类的单词可以兑换成一三类用），输出cnt_first + (cnt_second - cnt_first) / 2组单词就好了。细节不表。</p><h2 id="E-1"><a href="#E-1" class="headerlink" title="E"></a>E</h2><p>接近裸的递推关系。把$f_n$写成$c^{a(n)} \cdot f_1^{b(n)} \cdot f_2^{c(n)} \cdot f_3^{d(n)}$的形式，就可以发现递推方程啦。其中b, c, d都是同一形式的，只不过初始条件不同罢了。a要特殊点，因为你要把它在形式上做一些变换，这是高中的内容。</p><p>然后矩阵快速幂上板子。要注意的是，$MOD = 1e9+7$是个质数，故而$c^{p*(MOD-1) + q} \equiv c^{p + q}$（费马小定理）。在处理指数的递推关系时候，要模MOD-1；而在计算快速幂时，要模MOD。</p><p>写题目的时候碰到个坑点，记录如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n &gt;= <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    n -= <span class="number">3</span>;</span><br><span class="line">    LL ans = qpow_num(qpow_matrix(n) - n, c); <span class="comment">// qpow_num(expo, base)</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样是过不去的，为什么？因为上面把n改变了，所以在处理a的时候得小心一点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n &gt;= <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    n -= <span class="number">3</span>;</span><br><span class="line">    LL ans = qpow_num(qpow_matrix(n) - n - <span class="number">3</span>, c); <span class="comment">// caution!</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样有时候会t，为什么？因为前面算出来的qpow_matrix那个是模过MOD-1的，而n没有模过MOD-1，所以指数会出现负数的情形，这样子快速幂就跳不出来了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n &gt;= <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    n -= <span class="number">3</span>;</span><br><span class="line">    LL expo1 = qpow_matrix(n) - n - <span class="number">3</span>;</span><br><span class="line">    expo1 = ((expo1 % (MOD<span class="number">-1</span>)) + (MOD<span class="number">-1</span>)) % (MOD<span class="number">-1</span>); <span class="comment">// caution!</span></span><br><span class="line">    LL ans = qpow_num(expo1, c);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模过的数和没模过的数……变量在公式上的始终如一与在程序上的可变……这些都是坑点啊。尽管可能还会再犯，但希望下次能先把这些错误过一遍，有个印象总得。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下分真快乐呀……&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="https://nessoffice.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【数学之美】离散数学及其应用：第十一章 初探树</title>
    <link href="https://nessoffice.github.io/2019/06/22/Discrete_Mathematics-CH11/"/>
    <id>https://nessoffice.github.io/2019/06/22/Discrete_Mathematics-CH11/</id>
    <published>2019-06-22T11:22:10.000Z</published>
    <updated>2019-06-29T14:19:20.984Z</updated>
    
    <content type="html"><![CDATA[<p>树是一种特殊的图，它有一些良好的性质，也有相当广泛的应用。</p><a id="more"></a><h1 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h1><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><p>树：简单无环连通图（开始的定义是无向图，不过这并不是最重要的，最重要的是前面三条：无重边，无环，连通）</p><p>无向图为树，当且仅当任意两点间有唯一路径。</p><p>开始的定义中树是无向图，不过实际生活中我们建出来的树一般都有层级关系，故要定义方向。怎么确定方向呢？选定根节点然后递归（在subtree中递归）就好了。这样得出的树称为有根树，它的相关术语更多一些：parent, child, sibling, ancestor, descendant…这些是和点和点间的性质。至于点内部的性质，则有root, leaf, internal vertices，这些。</p><p>然后我们容易发现，parent有且仅有一个，除了根节点。children则可以不限量，除了叶节点。为了方便定量运算，我们定义每个节点children不超过m的树为m-ary tree，同时也定义了full m-ary tree。m取2比较常见，所以给它个好听的名字，binary tree。</p><p>然后child地位也不是平等的，有left child，有right child，有heavy child，有light child。这些是要有序地遍历树的时候要考虑的，这里先不必管。</p><h2 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h2><p>n个节点的树恰有n-1条边（可数归证，亦可套欧拉公式）。这条定理指出以下三个条件间的相互关系，即任意两个条件都能推出剩下的条件：1）G为连通图；2）G无环；3）G有n-1条边。</p><p>full m-ary tree若有i个internal vertices，则其有mi + 1个点。（由此，可确定总顶点数，内点数，叶子数间的关系，知二得三）</p><p>平衡树：叶子都在最后一层或是倒数第二层的树//为何作此定义？</p><p>m叉树至多$m^h$个叶子$\Leftrightarrow$m叉树高度h和叶子数满足$h \geq \lfloor log_m l \rfloor$。</p><h1 id="树的应用"><a href="#树的应用" class="headerlink" title="树的应用"></a>树的应用</h1><p>二分搜索树</p><p>决策树</p><p>博弈树</p><p>前缀码（关注Huffman编码）</p><h1 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h1><p>前序、中序、后序遍历</p><p>波兰式与逆波兰式</p><h1 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h1><p>图连通与其有生成树，二者等价</p><p>dfs、bfs求生成树</p><p>回溯的思路</p><p>Prim算法与Kruskal算法</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;树是一种特殊的图，它有一些良好的性质，也有相当广泛的应用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="课程笔记" scheme="https://nessoffice.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【数学之美】离散数学及其应用：第十章 图论基础</title>
    <link href="https://nessoffice.github.io/2019/06/22/Discrete_Mathematics-CH10/"/>
    <id>https://nessoffice.github.io/2019/06/22/Discrete_Mathematics-CH10/</id>
    <published>2019-06-22T11:22:09.000Z</published>
    <updated>2019-06-29T14:19:09.581Z</updated>
    
    <content type="html"><![CDATA[<p>想知道图有哪些好玩的应用吗？</p><p>想知道图有哪些奇妙的种类吗？</p><p>想知道怎样科学地研究我们生活中的电路和考试安排表吗？</p><p><strong>来学图论吧！</strong></p><p>①有向图、复杂图、环等奇妙关系的丰富组和！</p><p>②解锁打电话、找关系、打比赛、画分子、爬网站、焊电路板等趣味模型！</p><p>③用图论来获得缤纷色彩、最短路径等谜题的答案！</p><p>④所有的算法与复杂度都能尽情研究！</p><p>⑤在权重扩展包中探索新的玩法！</p><p><strong>好评发售中！</strong></p><a id="more"></a><h1 id="图的元素"><a href="#图的元素" class="headerlink" title="图的元素"></a>图的元素</h1><p>这一节主要在讲概念，概念也不复杂，一般动手画画就能理解，此处仅记一下术语。</p><p><strong>multigraphs</strong>，与之对应的是simple graph。multiplicity为边的重数。</p><p><strong>digraph</strong>（或directed graph），有向图。</p><p><strong>loop</strong>，在本书中指的是自环而非环（环一般用<strong>circuit</strong>表示）。</p><p>是否有重边，是否有自环，是否有向，也是Kenneth H.Rosen要求我们看到一个图时扪心自问的三个问题。</p><p><strong>pseudograph</strong>，同时有自环与重边的图，复杂图。</p><p>其他术语，什么mixed graph，simple directed graph就不记了，这些都可以通过组和最重要的三个元素得到。</p><h1 id="图的模型"><a href="#图的模型" class="headerlink" title="图的模型"></a>图的模型</h1><p>这里的模型基本大同小异，涉及的方面有日常生活；也有其他看似关联不大的学科，如心理学、环境学；还有就是各类网络：通信网，道路网……</p><p>书上的练习设计的的方向主要是自然语言与图论语言的转化，这是容易通过而熟练掌握的。练习中比较恶心的一类是画出precedence graph的Edge, 记于此处, 以供训练。<br>  s1: x := 0<br>  s2: x := x + 1<br>  s3: y := 2<br>  s4: z := y<br>  s5: x := x + 2<br>  s6: y := x + z<br>  s7: z := 4</p><h1 id="图的术语"><a href="#图的术语" class="headerlink" title="图的术语"></a>图的术语</h1><h2 id="邻域"><a href="#邻域" class="headerlink" title="邻域"></a>邻域</h2><p> 顶点A的邻域记作$N(A)$, 表示与A有共边的顶点的集合。</p><p>A的领域中的点与A是相邻(adjacent)的。</p><h2 id="度"><a href="#度" class="headerlink" title="度"></a>度</h2><p>在无向图中， $deg(A)$表示以A为端点的边的数目。</p><p>而在有向图中，$deg^-(A)$则表示起点为A的边数数目，类似地，$deg^+(A)$表示终点为A的边数数目。</p><p>度是与点有着直接关系的量。而边与度的关系则是每条边对总度数有两个贡献（举[有向]线段AB为例，无向图中数A的度与数B的度均要将其算一遍；在有向图中，它则只在A的入度和B的出度中各算了一次），由此可得定理1及其在有向图中的拓展（即书中的定理3）。</p><p>1.$\sum deg$ = $2|E|$</p><p>3.$\sum deg^-$ = $\sum deg^+$ = $|E|$</p><p>由此可见，无向图的度数和必为偶数。由此可得到书中的定理2：</p><p>2.无向图中度数为奇数的点必为偶数个。</p><p>证明的话，模2即可。</p><h1 id="特殊的图"><a href="#特殊的图" class="headerlink" title="特殊的图"></a>特殊的图</h1><p>1.完全图</p><p>2、3.环与轮（注意，$W_n$有n+1个点）</p><p>4.n维方体，顶点可用不超过$2^n$的正整数来表示（关注$n \geq 4$的情形，比如n=4要怎么画呢）</p><p>以上没什么好讨论的，其相关性质也非常好推。需要讨论的是以下的情形：二分图。</p><p>二分图的定义：对图$G = (V, E)$，若存在互不相交的顶点集$V_1, V_2$使得其并为$V$，且$E$中的任意元素$(u, v)$总满足$u, v$不同时属于$V_1$或$V_2$，则称$G$为二分图。</p><h2 id="二分图与染色问题的联系"><a href="#二分图与染色问题的联系" class="headerlink" title="二分图与染色问题的联系"></a>二分图与染色问题的联系</h2><p>二分图与染色问题有着密切的联系。简单图是二分图当且仅当其所有顶点能被染成两种颜色，并且没有同色点有共边。这并不难证明。</p><p>通过将求图$G$是否为二分图转化为能否将图$G$染色并使其满足上述条件，我们能得到一种求二分图的简单算法：从任意一点开始，将其染为一色，将与其相邻的点染为另一色，再转移到下一点，以此类推（类似BFS），直到出现矛盾或染色完成且自洽。</p><h2 id="二分图的匹配与Hall婚配定理"><a href="#二分图的匹配与Hall婚配定理" class="headerlink" title="二分图的匹配与Hall婚配定理"></a>二分图的匹配与Hall婚配定理</h2><p>给定二分图$G = (V, E)$，$E$的每一子集能够连接一些$V_1, V_2$中的点，若满足$V_1, V_2$中不存在度数超过1的元素，则称此为一次<strong>匹配</strong>。若一次匹配中连接起的$V_1$中的点的集合等于$V_1$，则称这是一次<strong>完全匹配</strong>。与二分图的匹配相对应的模型有求职、婚姻等。</p><p>了解了匹配的概念，我们自然会想到完全匹配需要什么条件，而Hall婚配定理则是对此的探讨。</p><p>二分图$G = (V, E)$存在完全匹配当且仅当对于所有$V_1$的子集$A$，都有$|N(A)| \geq |A|$。（此处$V_1$和$V_2$的地位是不对称的）</p><p>由存在完全匹配推出结论并不难，因为任意A中元素$u$唯一地对应$V_2$中的$v$，后者的集合是A的邻域的子集，其元素个数等于$A$的元素个数不大于$A$的邻域的元素个数。下面证明其逆命题，我们的思路是采用第二数学归纳法，将V中元素较大的情况缩减至V中元素较小的情况。</p><p>归纳前提：$|V|=1$时结论显然成立。</p><p>归纳假设：$|V|\leq k$时假设结论成立，下证明$|V|= k+1$时结论成立。</p><p>取$V_1$的恰含j个元素的子集A（A是任意的），由已知，存在两种情况：(1)$|N(A)| &gt; |A|$（对任意A情况均如此）与(2)$|N(A)| = |A|$，下分类讨论</p><p>(1)任取一个A，将其中一个元素与其对应元素配对（即剔除出$V_1$与$V_2$），余下的元素满足大前提及归纳假设，求证得证。</p><p>(2)将A与其对应集合配对，下用反证法证明余下的元素满足大前提（若不满足，其加上A之后也不会满足，故矛盾）也满足归纳假设，求证得证。</p><p>//此处应补充上图示</p><p>霍尔婚配定理的不足之处在于，它是一个存在性证明而非构造性证明，无法据其给出求出完全匹配的算法。</p><p>//霍尔婚配定理是否足够强呢？</p><p>(proper) subgraph</p><h1 id="图表示与图同构"><a href="#图表示与图同构" class="headerlink" title="图表示与图同构"></a>图表示与图同构</h1><p>邻接表、邻接矩阵, incidence matrix（前向星）</p><p>同构：关注不变量——环、度、子图结构，或者从补图入手</p><h1 id="图的连通性"><a href="#图的连通性" class="headerlink" title="图的连通性"></a>图的连通性</h1><p>割点（cut vertices）</p><p>从连通分量到强连通分量</p><p>k-connected</p><p>$\kappa(n) \leq \lambda (n) \leq min_{v \in V} deg(v)$</p><p>路径的条数（矩阵乘法）</p><h1 id="Euler路径与Hamilton路径"><a href="#Euler路径与Hamilton路径" class="headerlink" title="Euler路径与Hamilton路径"></a>Euler路径与Hamilton路径</h1><p>欧拉路径存在的充要条件</p><p>欧拉回路存在的充要条件</p><p>哈密顿回路：不能存在deg=1的点；deg=2的点至多一个</p><p>完全图（包括无向完全图与竞赛图）必有哈密顿回路</p><h1 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h1><p>dijkstra算法</p><h1 id="平面图"><a href="#平面图" class="headerlink" title="平面图"></a>平面图</h1><p>基本方法（如判定$K_{3, 3}$非平面图）</p><p>欧拉公式</p><p>degree of region</p><p>平面图中e，v相关的不等式</p><p>找和$K_5, K_{3, 3}$同构的子图</p><h1 id="图染色"><a href="#图染色" class="headerlink" title="图染色"></a>图染色</h1><p>找最大团</p><p>图染色的模型：考试安排表</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想知道图有哪些好玩的应用吗？&lt;/p&gt;
&lt;p&gt;想知道图有哪些奇妙的种类吗？&lt;/p&gt;
&lt;p&gt;想知道怎样科学地研究我们生活中的电路和考试安排表吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;来学图论吧！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;①有向图、复杂图、环等奇妙关系的丰富组和！&lt;/p&gt;
&lt;p&gt;②解锁打电话、找关系、打比赛、画分子、爬网站、焊电路板等趣味模型！&lt;/p&gt;
&lt;p&gt;③用图论来获得缤纷色彩、最短路径等谜题的答案！&lt;/p&gt;
&lt;p&gt;④所有的算法与复杂度都能尽情研究！&lt;/p&gt;
&lt;p&gt;⑤在权重扩展包中探索新的玩法！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好评发售中！&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="课程笔记" scheme="https://nessoffice.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【数学之美】离散数学及其应用：第九章 关系</title>
    <link href="https://nessoffice.github.io/2019/06/22/Discrete_Mathematics-CH09/"/>
    <id>https://nessoffice.github.io/2019/06/22/Discrete_Mathematics-CH09/</id>
    <published>2019-06-22T11:22:08.000Z</published>
    <updated>2019-06-30T13:07:22.597Z</updated>
    
    <content type="html"><![CDATA[<p>这章的主题是关系——我们关注的不是单个的元素，而是<strong>元素间</strong>的性质。</p><a id="more"></a><h1 id="关系的概念"><a href="#关系的概念" class="headerlink" title="关系的概念"></a>关系的概念</h1><h2 id="关系的定义"><a href="#关系的定义" class="headerlink" title="关系的定义"></a>关系的定义</h2><p>什么是关系呢？关系是集合论里的词，它是用笛卡尔积给出的。我们先来看一个简单的例子，比如我们有六只猫，三公三母，有哪些可能的配偶方案呢？我们先把猫放到集合里，令 公猫集 = {Wang, Miao, Aichiyu}，母猫集 = {qwq，bwb，dwd}。这时候我们考虑笛卡尔积。{Wang, bwb}，这表明Wang和bwb存在关系（’Wang’ is related to ‘bwb’），更确切的说，存在二元关系。</p><p>笛卡尔积给出的是有序元素，所以关系也是有序的。“关系”这个词看着很别扭，因为自然语言中的“关系”不仅是“有关系”的意思。但要在数学上研究元素间的关系，我们就得把“关系”看作一个集合，由形如$A \times B$的式子给出的集合的子集，比如说，R = { {Wang, qwq}, {Wang, bwb}, {Miao, bwb} }。这就是一个“关系”（relation）了。</p><p>不必管R有什么意义，因为它的意义是我们赋予的。我们可以定义$(a, b) \in R \Rightarrow$ a不喜欢b，也可以做相反的定义，都可以。关系也不仅限于猫猫狗狗上，只要是元素，都可以用笛卡尔积给它们搞出个关系。这样“关系”就能很丰富了，比如满足不等式的两元素间的关系，函数原像与像的关系，等等。这里谈到的“关系”是我们由经验中的“关系”抽象而出的，仅表示两元素间存在“关系”，而并未指明这样的“关系”是什么“关系”。（真是绕）</p><h2 id="关系的性质"><a href="#关系的性质" class="headerlink" title="关系的性质"></a>关系的性质</h2><p>知道了R的定义，我们可以来考察它的性质了。根据实际研究的需要，我们主要考察R是否有以下四种性质：</p><p>1.reflexive。即$\forall a \in A, (a, a) \in R, R \subseteq A \times A$。观察$R = {(a, b) | a &lt; b, a, b \in N}$和$R = {(a, b) | a \leq b, a, b \in N}$的区别很容易理解这条性质。</p><p>2.symmetric。即$\forall a, b,  (a, b) \in R \rightarrow (b, a) \in R$。</p><p>3.antisymmetric。即$\forall a, b,  (a, b) \in R \wedge (b, a) \in R \Rightarrow a = b$。（在猫猫匹配的例子中，如果R是antisymmetric的话那可真是悲哀）</p><p>4.transitive。即$\forall a, b, c, (a, b) \in R \wedge (b, c) \in R \rightarrow (a, c) \in R$。</p><p>transitive的画风看起来和上面那些很不一样，我们之后再来考虑它。（这一节中有一些叫你判断R是否transitive的例题，方法的话枚举中间元素较为方便）</p><p>需要注意，antisymmetric和symmetric并不是互斥的，它们研究问题的方向可以说完全不同。“关系”中还有其他和对称性沾边的性质，比如asymmetric，它和antisymmetric其实很像，只是限制了$\forall a, (a, a) \not \in R$（对了，这条性质就是irreflexive）。要确定这些研究方向各不相同而有所交集的性质间的关系并非那么容易的，不过，这是一个值得研究的问题吗？</p><p>这一节中还会有一些组和问题，比如，给定$|A| = n$，问antisymmetric的R有多少个。这类题在理解了R的定义之后非常好做。上面例子的答案为$2^n \cdot 3^{n \cdot (n-1)}$。捆绑的思想。</p><h2 id="关系间的运算"><a href="#关系间的运算" class="headerlink" title="关系间的运算"></a>关系间的运算</h2><p>既然关系是一个集合，我们可以利用集合中的运算研究关系和关系间有什么关系。在这里，$\cup, \cap, \oplus, -$都可以直接继承集合中的运算。</p><p>然后因为关系是多元组，它还有自己独特的计算：$\circ$。如果把关系表示为矩阵的话，那么这一项便可以类比矩阵乘法。具体写来，是这样的：$R \subseteq A \times B, S \subseteq B \times C, (a, b) \in R \wedge (b, c) \in S \rightarrow (a, c) \in S \circ R$。（这个符号真反人类……明明运算和$R \times S$很像，但硬是要反过来写，不懂）</p><p>还有需要注意的是，$R^{-1}$不是使得$R \circ R^{-1} = E$成立的集合，它更像是$R^T$，这些记号需要注意。</p><p>然后定义了这个”乘法“(composite)之后，我们就可以来关注transitive这条性质了。比如有一条定理，讲的是R满足transitive和$R^n \subseteq R$这一条等价。证明的话，右边推左边按性质就好了，左推右数归就好。至于这条定理有何意义？（至少我不清楚）</p><h1 id="n元关系-待补充"><a href="#n元关系-待补充" class="headerlink" title="n元关系[待补充]"></a>n元关系[待补充]</h1><p>上面讲的关系都是二元关系，形如$A \times B$。类似的，我们可以定义n元关系。</p><p>对n元关系我们就不考察它的性质了，反正它还是元素笛卡尔积得到的集合，研究n元的情形没什么必要。</p><p>需要考察的是它的应用：比如数据库中，一个条目，比如说学生，包含了很多子数据：姓名、学号、GPA……那么我们可以把姓名×学号×GPA×…得到的元素视作一段关系的元素，也就是数据库中的项。这样一来，一个数据库就对应一种关系。我们要进行各式各样的数据库操作：添加，删除，排序……这些该如何定义呢？</p><p>（关注select和projection的分别。）</p><h1 id="关系的表示"><a href="#关系的表示" class="headerlink" title="关系的表示"></a>关系的表示</h1><p>前面我们都是抽象地”感受“关系的，这样想问题或许不容易理解。我们试着将其化归到已经学过的可爱的数学元素上，好让它更直观一些。</p><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>简单地在关系和0-1矩阵上做个一一映射，就能用矩阵来表示关系啦。</p><p>用矩阵来表示关系可以让reflexive, symmetric, antisymmetric的判断变得很简单，但是判断transitive还是一如既往的麻烦。</p><p>用矩阵表示也让composite（乘法）更容易算了（注意0-1矩阵乘法的规则）。这在之后研究transitive上是好的。</p><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>矩阵规模好大，但又好稀疏，用矩阵表示要写好多0，好烦，怎么破？用邻接表呗。（前向星，多好的名字啊）</p><h2 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h2><p>随便找道例题体会一下即可，这种表示法更为直观。</p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h2><p>我们觉得满足性质的关系是好的，比较漂亮。不满足性质的关系就没那么漂亮。那么，怎么把不漂亮的关系补成漂亮的关系呢？（为什么一定要补呢？置$R = \varnothing$多方便啊？）称补出来的为闭包（很显然，笔者的定义是不严谨的，但很直观）。</p><p>reflexive, symmetric都很好补，而antisymmetric补不出来。看上去要研究的只剩transitive了。</p><p>可这并不容易，需要先定义一些其他的概念。</p><h2 id="传递闭包"><a href="#传递闭包" class="headerlink" title="传递闭包"></a>传递闭包</h2><p>我们先来回顾一下何谓传递性，不用关系中的术语，而是以图论的角度来思考。一个有向图，它有点和边，于是可以得到从一点a出发的”可到达的“点的集合（设其中任意一点为b），也得到了它要到那些点的路径及路径长度。而传递性，表明从a到任意的的b最短距离为2，也就是能直连通。</p><p>但是目前的图不一定使得连通的两点能够直连通啊，所以要补边（边和关系中的元素一一对应），也就是考虑构造传递闭包。</p><p>上面是较直观的感受，用数学语言该如何转译呢？a可达b，即$\exists k, (a, b) \in R^k$。于是这个(a, b)需要添加到闭包中。yy一下，我们得到了一种获得传递闭包的方式：$R^* = \bigcup\limits_{k = 1}^{\infty} R^k$。</p><p>然后如果路径太长，长过顶点数，这其中肯定是有环的，可以把环剪掉。所以$R^* = \bigcup\limits_{k = 1}^{n} R^k$。</p><p>这个算法的复杂度是$O(n^4)$，还不错？不过要算好多乘法好累，有没有稍微简单一点的算法呢？有的，Warshall’s Algorithm。</p><p>Warshall算法的思路是这样的：如果有长度超过2的路径，那么这条路径必然要经过中间的节点，于是可以通过枚举中间节点来构造传递闭包。（想到Floyd算法了吗？恰好，Floyd算法的全称正是Floyd-Warshall算法）yy一下，对着书上的例题手工模拟一番，便能学会这个算法了。（正确性证明考虑数归）</p><h1 id="等价关系"><a href="#等价关系" class="headerlink" title="等价关系"></a>等价关系</h1><p>什么是等价关系呢？我们来看看具体的例子吧：比如$\equiv$，它就是一个等价关系，$1 \equiv 5(mod 4)$。其中1和5本身并不相等，但是在mod 4这个条件下，它们是等价的，是可互换的。故，等价关系，指在给定的条件下，元素满足同样的性质。</p><p>等价关系要满足什么性质呢？其实这是我们自己归纳出来的。比如说$\equiv$，它reflexive，symmetric，transitive。然后满足这三点的关系，那么，我们就下个定义：满足reflexive，symmetric，transitive的关系就叫等价关系。（这一定义并非先验的，为什么等价和这三个性质有联系可能不好理解，但为什么要尝试理解它呢？）</p><p>满足等价关系的元素可以归到一类里，称等价类。同余等价类就是很好的例子。</p><p>定义了等价类，我们可以选取等价类中的一个元素，比如说a，来表示这个类，记作[a]。于是乎可以得到三种等价的表述：$a R b \Leftrightarrow [a] = [b] \Leftrightarrow [a] \cap [b] \not = \varnothing$。</p><p>由等价类间的互不交，可由等价类在原集合上做划分（partition）。</p><p>然后对于计数问题，如问有多少种等价关系这样的问题，可以考虑等价类的数目来做。</p><h1 id="偏序关系"><a href="#偏序关系" class="headerlink" title="偏序关系"></a>偏序关系</h1><p>这节讲的是偏序关系。偏序，偏序，顾名思义，和两个要素息息相关，其一为“偏”，其二为“序”，“偏”又是建立在“序”的基础上的，指的是并非所有元素间均可比较。与偏序关系对应的是全序关系。无论是偏序还是全序，它们都得要能排序，也就是能比较才行。什么样的关系是可排序的呢？</p><p>$\leq, |, \subseteq$，这些看似不同的运算都有着相似的特点：reflexive, antisymmetric, transitive。我们看到这样的关系是可比的。于是，我们用$\preccurlyeq$表示这样的偏序关系，也就是满足以上三条性质的关系。经历了等价关系的洗礼，读者应当能够接受这种表达。</p><p>定义了偏序关系，我们接着来定义一种常用的排序方式：字典序。//待补充</p><p>Hasse图：用以直观表示偏序关系的图//待补充</p><p>maximum, minimal, greatest, least, (greatest) lower bound(GLB), (least) upper bound(LUB)//待补充</p><p>lattice(a partially ordered set in which every pair of elements has both a least upper bound and a greatest lower bound)</p><p>topological sorting</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这章的主题是关系——我们关注的不是单个的元素，而是&lt;strong&gt;元素间&lt;/strong&gt;的性质。&lt;/p&gt;
    
    </summary>
    
    
      <category term="课程笔记" scheme="https://nessoffice.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【数学之美】离散数学及其应用：第八章 计数进阶</title>
    <link href="https://nessoffice.github.io/2019/06/22/Discrete_Mathematics-CH08/"/>
    <id>https://nessoffice.github.io/2019/06/22/Discrete_Mathematics-CH08/</id>
    <published>2019-06-22T06:19:07.000Z</published>
    <updated>2019-06-30T13:07:29.593Z</updated>
    
    <content type="html"><![CDATA[<p>虽然这章名为“计数进阶”，但其内容和“计数”关系似乎不是很大。除了生成函数是标准的“计数”内容，“递推”“分治”看起来和“计数”都没啥关系。另外容斥定理讲得也比较浅。</p><a id="more"></a><h1 id="递推关系"><a href="#递推关系" class="headerlink" title="递推关系"></a>递推关系</h1><h2 id="递推关系模型-需补充"><a href="#递推关系模型-需补充" class="headerlink" title="递推关系模型[需补充]"></a>递推关系模型[需补充]</h2><p>从兔子数列到牛数列</p><p>汉诺塔</p><p>满足特定条件的01串（如，不包括连续两个0的01串）</p><p>（卡塔兰数的一种情形）n个数相乘的顺序总数</p><h2 id="递推算法-需补充"><a href="#递推算法-需补充" class="headerlink" title="递推算法[需补充]"></a>递推算法[需补充]</h2><p>讲座问题</p><p>动态规划</p><h1 id="线性递推"><a href="#线性递推" class="headerlink" title="线性递推"></a>线性递推</h1><h2 id="齐次"><a href="#齐次" class="headerlink" title="齐次"></a>齐次</h2><p>所谓线性齐次常系数递推关系（linear homogeneous recurrence relations with constant coefficients），指的是形如$a_n = c_1 a_{n-1} + c_2 a_{n-2} + … c_k a_{n-k}$的递推关系。</p><p>提到“线性齐次常系数递推关系”我们就会提特征方程与特征根，它们是用以解递推式的利器。</p><p>特征根是个非常有效但也让人摸不着头脑的东西。它本身有何意义？下面笔者粗浅地谈谈自己对其的认识。</p><h3 id="二阶递推式-需完善"><a href="#二阶递推式-需完善" class="headerlink" title="二阶递推式[需完善]"></a>二阶递推式[需完善]</h3><p>如果递推式形如$a_n = Aa_{n-1} + Ba_{n-2}$，$a_n$该如何解呢？我们考虑能否用特殊的$a_n$凑出答案，比如，$a_n = x^n$，这样？把它代入原递推式，我们得到一个二次方程$x^2 - Ax - B = 0$，如果它有不同的解$x_1, x_2$，诶，好，$a_n = x_1^n$或者$a_n = x_2^n$看上去都可以。</p><p>但是啊，$a_n = Aa_{n-1} + Ba_{n-2}$是由$a_1, a_2$完全确定的。如果$a_1 \not = x_1$，那不就出问题了吗？其实，前面说$a_n = x_1^n$“可以”，那么$a_n = Cx_1^n + Dx_2^n$也是“可以”的。这样便能够通过给定的$a_1, a_2$解一解C、D，$a_n$的通解也就出来了。</p><p>因为$x^2 - Ax - B = 0$和$a_n$有着密切的联系，我们称前者为“特征方程”。</p><p>以上是特征方程有两个相异根的情形，如果相同则如何呢？不一定存在$C$使得$a_1 = Cx_1$且$a_2 = Cx_1^2$啊！在这个条件下，我们令$a_n = Cx_1^n + Dnx_1^n$。可以证明，这样的$a_n$满足条件//为什么想到要这样做？</p><h3 id="n阶递推式"><a href="#n阶递推式" class="headerlink" title="n阶递推式"></a>n阶递推式</h3><p>与上面类似的，我们能想到无重根的n阶递推式的通解形如$a_n = \sum\limits_{i = 1}^k \alpha_i r_i^n$，其中$r_i$为特征方程的解。</p><p>至于有重根的n阶递推式，它则形如$a_n = \sum\limits_{i = 1}^k(\sum\limits_{j = 0}^{m_i} \alpha_{(i, j)} n^j r_i^n)$，其中$r_i$为特征方程的解，$m_i$为重数。</p><p>证明呢？不管了(¬､¬)</p><p>有重根的n阶递推式</p><h2 id="非齐次-需完善"><a href="#非齐次-需完善" class="headerlink" title="非齐次[需完善]"></a>非齐次[需完善]</h2><p>所谓线性非齐次常系数递推关系（linear nonhomogeneous recurrence relations with constant coefficients），指的是形如$a_n = c_1 a_{n-1} + c_2 a_{n-2} + … c_k a_{n-k} + F(n)$的递推关系。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>找特解，而后化归到齐次。（这些方程都这种套路，得归纳一下）</p><p>特解怎么找呢？比如$a_n = 3a_{n-1} + 2n$，我们可以从结构上猜出$a_n = Cn$。而对于$a_n = 5a_{n-1} - 6a_{n-2} + 7^n$，我们也可以猜一个$a_n = C \cdot 7^n$。但是如果是$a_n = 5a_{n-1} - 6a_{n-2} + 3^n$，$a_n = C \cdot 3^n$就不管用了，要$a_n = C \cdot n^2 \cdot 3^n$才行（为什么又是这个形式？我不知道）。</p><p>一般的，有下面的定理。</p><h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p>若$a_n = c_1 a_{n-1} + c_2 a_{n-2} + … c_k a_{n-k} + F(n)$，$F(n)$形如$(b_t n^t + b_{t-1} n^{t-1} + … + b_1 n + b_0) s^n$，其中b、s均为常数。递推关系的特征方程$x^n - c_1 x^{n-1} - c_2 x^{n-2} - … c_k x^{n-k} = 0$的解中s的重数为m，则特解的形式形如$a_n = n^m (p_t n^t + p_{t-1} n^{t-1} + … + p_1 n + p_0) s^n$。</p><p><del>我不会，就不证了</del>例子：$a_n = 6a_{n-1} - 9a_{n-2} + F(n)$，当$F(n)$分别取$F(n) = 3^n, F(n) = n 3^n, F(n) = n^2 2^n, F(n) = (n^2 + 1) 3^n$，求$a_n$的通解。</p><p>应用：如求$a_n = \sum n^k$。</p><h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><p>研究分治算法时，一个值得关注的对象是时间复杂度。下面举几个大家耳熟能详的例子。</p><p>例子：矩阵乘法、二进制乘法（汇编乘法？）、二分查找、归并排序</p><p>上面的例子看似相似，但其算法复杂度可以很不一样！最后的公式会依据递推关系中的常数专门进行分类讨论，而且结论虽然能推，但是并不好记。//如何认识这一结论？</p><p>关于复杂度的推导，我们可以先简化问题，因为只要得到$f(n) = O(g(n))$就好了，可以对n进行“适当”的放大。这里，我们考虑$n = b^k$。</p><h2 id="f-n-的复杂度估计-需完善"><a href="#f-n-的复杂度估计-需完善" class="headerlink" title="f(n)的复杂度估计[需完善]"></a>f(n)的复杂度估计[需完善]</h2><h3 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h3><p>对于形如$f(n) = af(n/b) + c$的递推式，有</p><p>………………..$a = 1 \Rightarrow f(n) = O(log n)$</p><p>………………..$a &gt; 1 \Rightarrow f(n) = O(n^{log_b a})$</p><p>………………..$a &lt; 1 \Rightarrow f(n) = O(1)$</p><p>第一项很好理解，第二项是怎么得到的呢？其实直接得到的是$f(n) = O(a^k)$，而通过换底公式能得到$a^k = n^{log_b a}$，因为我们喜欢把n放到真数的位置。下面也是要用到这个转换的。</p><h3 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h3><p>对于形如$f(n) = af(n/b) + cn^d$的递推式，有</p><p>………………..$a = b^d \Rightarrow f(n) = O(n^d log n)$</p><p>………………..$a &lt; b^d \Rightarrow f(n) = O(n^d)$</p><p>………………..$a &gt; b^d \Rightarrow f(n) = O(n^{log_b a})$</p><h2 id="典例：最近点对问题-需完善"><a href="#典例：最近点对问题-需完善" class="headerlink" title="典例：最近点对问题[需完善]"></a>典例：最近点对问题[需完善]</h2><p>计算几何的一个<del>毒瘤</del>经典例题，初看非常的抽象，下面我试着以直观的方式说明一下如何用分治法解决这个问题。</p><p>首先分治呢，要先“分”，而后“治”。“分”的话二分比较常见，但二分要在有序集里才好进行。考虑以x坐标对这些点进行排序，然后取中间的点作为分界就好了。</p><p>下面的思路有些跳跃，我们从最后的算法出发来反推，这样可能更容易理解些。</p><p>分治法大框架的伪代码如下，一些细节先不必理解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">closest</span><span class="params">(Point p[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(high - low == <span class="number">1</span> <span class="keyword">or</span> <span class="number">2</span>)...</span><br><span class="line">    <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> d1 = closest(p, low, mid);</span><br><span class="line">    <span class="keyword">double</span> d2 = closest(p, mid + <span class="number">1</span>, high);</span><br><span class="line">    <span class="keyword">double</span> d = min(d1, d2);</span><br><span class="line">    d = merge(...);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面框架的细节主要是这个：d = min(d1, d2)。为什么要先算d呢？</p><p>这实质上是用于提高效率的。你想，“分”做好了，就是左右两边的最近点对距离都已经分别算出来了，“治”要怎么做呢？枚举左边的点和右边的点的距离么？这样还是$O(n^2)$，算法的复杂度还是没有降低呀！于是我们得限制枚举的点的数量。聪明的Preparata和Shamos发现，如果先算出d1、d2和d，那么用要枚举点的话，只要在下图中两条红线间的区域间（x坐标距mid为d的区域内）枚举即可。</p><p><img src="/2019/06/22/Discrete_Mathematics-CH08/closest_distance1.png" alt></p><p>就是说，这里用到了剪枝：把一些分居左右而距离必定超过d的点对剪掉。这个剪枝还是比较宽的，但它容易想到呀，如果要更深入地剪就要深入探究点的结构了，太复杂啦！我们不考虑。</p><p><img src="/2019/06/22/Discrete_Mathematics-CH08/closest_distance2.png" alt></p><p>可是，看这张图，即便上面有剪枝，枚举量还是太大了呀，如何缩减呢？我们遇到的问题是这些剩下的点还是无序的，只得暴力枚举，而没有有效的降低枚举量的技巧。于是，聪明的Preparata和Shamos又把剩下的点有序化了，并利用“两点间距离不能大于d”继续剪枝。请看伪代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">merge</span><span class="params">(Point p[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high, <span class="keyword">double</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;<span class="comment">// the size of the array "temp"</span></span><br><span class="line">    Point temp[];<span class="comment">// the points between the red lines</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//branch-cutting 1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = low;i &lt;= high;i++)</span><br><span class="line">        <span class="keyword">if</span>(p[i].x &gt;= p[mid].x - d)</span><br><span class="line">        <span class="keyword">if</span>(p[i].x &lt;= p[mid].x + d)</span><br><span class="line">        temp[len++] = p[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// the merge part</span></span><br><span class="line">    sort(temp, temp + len, cmp_y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;i + j &lt; len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp[i+j].y - temp[i].y &gt; d) <span class="keyword">break</span>;<span class="comment">// branch-cutting 2</span></span><br><span class="line">            d = min(d, dist(temp[i], temp[i+j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面“branch-cutting 2”这一行，它很容易理解，但是否足够有效呢？是否存在某组数据使得“the merge part”的运算量退化到$n^2$呢？幸运的是，它足够有效！而且运算量至多是7n！请看下面的图示。</p><p><img src="/2019/06/22/Discrete_Mathematics-CH08/closest_distance3.png" alt></p><p>假设我们正枚举到$P1$。Preparata和Shamos证明了，至多有7个$P2$满足$P2.y - P1.y \leq d$。因为前面在左右两边已经”分“过了，故有closest(left), closest(right) &gt;= d，即在“一边”的点两两距离大于d。这个结论非常有用！因为前面已经构造出了以2d为边长的长方形作为我们选点的区域，我们再在这个长方形里画小的正方形，再把P1放进去。能够发现，在图中所示的八个虚线区域中，每个区域至多一个点（否则矛盾）。故而“branch-cutting 2”在至多7步后就会退出，这个剪枝足够有效！</p><p>上面的分析还是比较粗略的，因为实际运算时似乎用不着7步，我们能否证明对每个点至多只要4次或5次比较呢？不论如何，总之都是较小的常数就是了。</p><p>接着来分析一下算法复杂度吧。开始的按x排序：O(nlogn)，之后的递推：f(n) = 2f(n/2) + nlogn + 7n（nlogn是按y排序）。解上面的递推式，得f(n) = O(nlogn)//为何网上有说法是nloglogn？</p><p>以反推的方式理解了一下这个算法，我们再来正面地总结一下我们的步骤：</p><p>①准备，按x排序原数组，使之有序；</p><p>②“分”，以中点为界，得到两子域中的最短点距；</p><p>③“治”，依据②中的最短点距d找出需要枚举的点，这里进行了第一次剪枝；</p><p>④“治”，将③中得到的点按y排序，顺序枚举，并通过y的距离进行第二次剪枝；</p><p>以上。</p><p>总而言之，这个算法的步骤还是容易实现的，难的是深入地理解它。这里两个剪枝分开来看都可能是效率不高的，但合在一起就产生了奇妙的相互作用，保证了总体剪枝的有效性。这十分精妙，但也很难想到，而且不好推广。</p><p>另外书上的算法是设了两个数组，分别对x排序与对y排序，之后在后者这一数组中检索，但这样细节是如何处理的呢？我还不知道。</p><p>算法的完整代码见下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span><span class="keyword">double</span> x, y;&#125;Points[maxn], temp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_x</span><span class="params">(Point &amp;lhs, Point &amp;rhs)</span></span>&#123;<span class="keyword">return</span> lhs.x &lt; rhs.x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_y</span><span class="params">(Point &amp;lhs, Point &amp;rhs)</span></span>&#123;<span class="keyword">return</span> lhs.y &lt; rhs.y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(Point &amp;lhs, Point &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>((lhs.x - rhs.x)*(lhs.x - rhs.x) + (lhs.y - rhs.y)*(lhs.y - rhs.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high, <span class="keyword">double</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> mid_x = Points[mid].x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = low;i &lt;= high;i++)</span><br><span class="line"><span class="keyword">if</span>(Points[i].x &gt;= mid_x - d)</span><br><span class="line"><span class="keyword">if</span>(Points[i].x &lt;= mid_x + d)</span><br><span class="line">temp[len++] = Points[i];</span><br><span class="line">sort(temp, temp + len, cmp_y);<span class="comment">//in the book, it's not necessary to sort. Why?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;i + j &lt; len &amp;&amp; (temp[i+j].y - temp[i].y &lt;= d);j++)</span><br><span class="line">d = min(d, dist(temp[i], temp[i+j]));</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">closest</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(high == low) <span class="keyword">return</span> INF;</span><br><span class="line"><span class="keyword">if</span>(high - low == <span class="number">1</span>) <span class="keyword">return</span> dist(Points[low], Points[low+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">double</span> d1 = closest(low, mid);</span><br><span class="line"><span class="keyword">double</span> d2 = closest(mid + <span class="number">1</span>, high);</span><br><span class="line"><span class="keyword">double</span> d = min(d1, d2);</span><br><span class="line"><span class="keyword">return</span> merge(low, mid, high, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...<span class="comment">//scanf</span></span><br><span class="line">sort(Points, Points + n, cmp_x);</span><br><span class="line">...<span class="comment">//printf</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>①分治算法在不同递推式下算法复杂度可能不同，需特殊情况特殊分析。</p><p>②分治算法的精髓在于“分而后治”，“分”是“治”的基础，通过“分”得到的有效信息能够帮助我们降低“治”部分的复杂度。在归并排序中，“分”得到的有效信息是子序列的有序性；在最近点对问题中，“分”得到的有效信息是子区域的最近点对距离。</p><p>③分治算法本身不难理解，但比较难想到，也比较灵活。分析分治算法时“为何这种问题可以用分治处理”。</p><h1 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h1><p>何谓生成函数？这是个比较玄妙的问题，它的定义很简单，但为何要这样定义，及它为何能用来解决组合问题，则常常会给人带来迷惑，下面笔者以个人的理解粗略地讲讲生成函数。</p><h2 id="生成函数的概念"><a href="#生成函数的概念" class="headerlink" title="生成函数的概念"></a>生成函数的概念</h2><p>先来看这样一个例子：$x_1 + x_2 + x_3 = 7$，其中$0 \leq x_1 \leq 2, 2 \leq x_2 \leq 3, 3 \leq x_4 \leq 4$，$x_1, x_2, x_3$为整数。求$(x_1, x_2, x_3)$有多少种可能。</p><p>我们固然可以通过解答树得到答案，但是否有其他更“代数”的做法呢？考虑这个式子：$(1 + x + x^2) \cdot (x^2 + x^3) \cdot (x^3 + x^4)$。它意味着什么？我们把第一个括号中x的指数看作$x_1$的取值，第二三个括号同理。从一二三个括号中各选一项乘起来，恰好对应$x_1 + x_2 + x_3 = k$的一种方法。故$(1 + x + x^2) \cdot (x^2 + x^3) \cdot (x^3 + x^4)$展开式中$x^k$的系数，即$x_1 + x_2 + x_3 = k$的方法数（而指数所对应的便是$x_1 + x_2 + x_3$的取值）。特别的，取k = 7，就得到了上面问题的答案。</p><p>这个方法看上去和暴力枚举并无二致，但事实并非如此。首先，生成函数将组合问题与代数问题连接起来，从而使得组和问题更易表示，而能为计算机所处理（多项式乘法）。其次，这样的算法在运算时更为容易，因为我们更熟练于多项式的乘法而不是列出解答树。</p><p>为何上述做法能建立从组和到代数的一一映射呢？原因在于乘法法则与加法法则——$ax^c + bx^c = (a+b)x^c$，这对应于加法法则；$ax^c \cdot bx^d = ab x^{c+d}$，这对应于乘法法则。如果认为这有些抽象，不妨在上面的例子中找找哪里用到了这两个法则。生成函数之所以能够解决组合问题，原因就在于多项式的运算能有这样和组和相关的性质。</p><p>上面的生成函数$G(x) = (1 + x + x^2) \cdot (x^2 + x^3) \cdot (x^3 + x^4)$是有限项的，容易理解。但是实际运用中我们一般会考虑无穷项的情况，即将$G(x)$写作无穷级数的形式。然后玄学东西又来了：比如$G(x) = \sum\limits_{i = 0}^{\infty} x^i = \dfrac{1}{1-x}$。为什么可以这样做？这样做有什么好处？这些我们将在下文中，结合具体的案例进行探讨，此时先不要被它迷糊了头脑。</p><h2 id="用生成函数证明组和恒等式-需完善"><a href="#用生成函数证明组和恒等式-需完善" class="headerlink" title="用生成函数证明组和恒等式[需完善]"></a>用生成函数证明组和恒等式[需完善]</h2><p>使用生成函数时，我们需要考虑“意义”。这不是指x的意义——x毫无意义，我们引入x只是要利用多项式的运算，因为它是好的。此处的意义指的是我们运算式子中的意义。拿上面的例子来说，$((1 + x + x^2)), (x^2 + x^3)$分别都有意义，它们相乘也是有意义的。谈到”意义“，你可能想到了第六章玄学的”组合证明“。而生成函数与组合证明，它们恰能够结合在一起。</p><p>//二项式定理？</p><p>比如Yanghui恒等式，可以这么证：$(1+ x)^n = (1 + x)^{n-1} + x (1 + x)^{n-1}$，关注左右式中$x^k$的系数即可。</p><p>又比如Vandermonde恒等式，关键的式子是$(1 + x)^{m + n} = (1 + x)^n (1 + x)^m$。</p><p>不难发现，使用生成函数的思路和组合证明的思路是完全一致的。但这个形式看起来就”正经“的多。</p><h2 id="用生成函数解决组和问题"><a href="#用生成函数解决组和问题" class="headerlink" title="用生成函数解决组和问题"></a>用生成函数解决组和问题</h2><h3 id="生成函数的模型"><a href="#生成函数的模型" class="headerlink" title="生成函数的模型"></a>生成函数的模型</h3><p><strong>例1</strong></p><p>$x_1 + x_2 + x_3 = 7$，其中$0 \leq x_1 \leq 2, 2 \leq x_2 \leq 3, 3 \leq x_4 \leq 4$，$x_1, x_2, x_3$为整数。求$(x_1, x_2, x_3)$有多少种可能。</p><p><strong>例2</strong></p><p>八本书，分给三个小孩，每人得到的书不少于两本不多于四本，求总方法数。</p><h3 id="再谈可重复元素的组和"><a href="#再谈可重复元素的组和" class="headerlink" title="再谈可重复元素的组和"></a><strong>再谈可重复元素的组和</strong></h3><p>在讲这个例子前，先要提一提广义二项式定理。</p><p><strong>广义二项式系数</strong>：$C_u^m = \dfrac{u \cdot (u-1) \cdot … \cdot (u - m + 1)} {1 \cdot 2 \cdot … \cdot m}$，其中m为非负整数，u为任意实数。</p><p>特别的，当u为负整数的时候，我们有$C_{-n}^m = (-1)^m C_{n + m - 1}^m$。</p><p><strong>广义二项式定理</strong>：$(1 + x)^u = \sum\limits_{i = 0}^{\infty} C_u^i x^i$。（证明的话，幂级数展开就好）</p><p><strong>例3</strong></p><p>有n种硬币，每种有无穷多个，问取r个硬币有多少种方法。</p><p>第一种硬币可以取0个、1个、2个、……，这样考虑的话，生成函数便是$G(x) = (1 + x + …)^n$。</p><p>但无穷级数相乘很难算。我们为了能够算出结果，假定级数收敛，那么$(1 + x + …) = \dfrac{1} {1 - x}$。则$G(x) = \dfrac{1} {(1 - x)^n}$。</p><p>于是可以使用上面的广义二项式定理了，得$x^r$的系数是$C_{n + r - 1}^r$。</p><p>回过来再考虑生成函数的问题，它为何要是无穷级数？为了方便表示”可重复元素“，也是为了计算上的方便，因为这样就可以在微积分和组合数学之间建立联系了，从而使用微积分中的一些性质。而对于实际的问题，我们都可以在模$x^r$的意义下考虑原式子，这样让人困惑的无穷就消失啦。</p><p>为何能假定上面的式子收敛？<del>我也不知道，好用就行了</del></p><p><strong>例4</strong></p><p>有三种硬币，币值分别为1、2、5，每种都有无穷个，求取r元有多少种方法？</p><h2 id="用生成函数解决排列问题-需完善"><a href="#用生成函数解决排列问题-需完善" class="headerlink" title="用生成函数解决排列问题[需完善]"></a>用生成函数解决排列问题[需完善]</h2><h2 id="用生成函数解决递推问题-需完善"><a href="#用生成函数解决递推问题-需完善" class="headerlink" title="用生成函数解决递推问题[需完善]"></a>用生成函数解决递推问题[需完善]</h2><p>考虑斐波那契数列的生成函数：$G(x) = \sum\limits_{i = 0}^{\infty} f_i x^i$，$G(x) = x + \sum\limits_{i = 2}^{\infty} f_i x^i = x + \sum\limits_{i = 2}^{\infty} (f_{i-1} + f_{i-2}) x^i = x + x\sum\limits_{i = 0}^{\infty} f_i x^i + x^2 \sum\limits_{i = 0}^{\infty} f_i x^i = x + xG(x) + x^2 G(x)$，则$G(x) = \dfrac{x} {1 - x - x^2}$，因式分解再裂项，就得到我们常见的结果了。</p><p>为什么生成函数这么奇妙？因为它巧妙地将递推关系用来消项。//<del>然后我也讲不出什么道道了</del></p><p>这里的G(x)看起来是很抽象的，有没有办法让它表现得具体一点呢？您好，有的。我们来算一下$G(1/10) = \dfrac{10}{89} = 0.1123595506…$，不难发现小数点后第i项就是斐波那契数列第i项（仅限前几项，因为后面的要进位）。</p><p>如此，我们便可以用生成函数在小数和数列间建立联系啦，也可以用生成函数得到一些好玩的小数。</p><h1 id="容斥原理-需补充"><a href="#容斥原理-需补充" class="headerlink" title="容斥原理[需补充]"></a>容斥原理[需补充]</h1><p>内容</p><p>素数个数（关注计算复杂度）</p><p>满射的个数</p><h2 id="错排问题"><a href="#错排问题" class="headerlink" title="错排问题"></a>错排问题</h2><p>后面的部分<a href="https://www.cnblogs.com/c1299401227/p/5349727.html" target="_blank" rel="noopener">引自网络</a>，略有删改。（不知是否这位老哥原创的）</p><p>$\forall i, f(i) \not = i, i, f(i) \in \{ 1, 2, …, n \};\forall i \not = j, f(i) \not = f(j)$，求符合要求的函数个数D(n)。</p><p>核心递推公式：</p><p>$D(n) = (n-1) [D(n-2) + D(n-1)]$</p><p>初始值：$D(1) = 0, D(2) = 1$。</p><h3 id="递推的推导错排公式"><a href="#递推的推导错排公式" class="headerlink" title="递推的推导错排公式"></a>递推的推导错排公式</h3><p>分析i = 1，它有n-1个取值。不失一般性，设$f(1) = 2$。再分析i = 2，若$f(2) = 1$，剩下的个数就是$D(n-2)$。</p><p>下面的一步就好玩了：如果$f(2) \not = 1$，那么剩下的个数是多少呢？注意！$f(2) \not = 1, f(3) \not = 3, …, f(n) \not = n$，这难道不是新的错排，个数是$D(n-1)$？于是，上面的递推式就得到啦！</p><p>下面咱们来推公式。</p><p>根据套路，设$D(n) = n! N(n)$，然后推一推，得//怎么想到要这么做的？</p><p>$nN(n) = (n-1) N(n-1) + N(n-2)$​，然后有</p><p>$N(n-1) - N(n-2) = (-1)^{n-1} / (n-1)!$，相加得</p><p>$N(n) = (-1)^2/2! + … + (-1)^{n-1} / (n-1)! + (-1)^n/n!$</p><p>故</p><p>$D(n) = n! [(-1)^2/2! + … + (-1)^{n-1}/(n-1)! + (-1)^n/n!]$</p><p>此即错排公式。</p><h3 id="用容斥原理的推导"><a href="#用容斥原理的推导" class="headerlink" title="用容斥原理的推导"></a>用容斥原理的推导</h3><p>用容斥原理也可以推出错排公式:</p><p>正整数1, 2, 3, ……, n的全排列有 n! 种，其中第k位是k的排列有 (n-1)! 种;当k分别取1, 2, 3, ……, n时，共有n*(n-1)!种排列是至少放对了一个的，由于所求的是错排的种数，所以应当减去这些排列;但是此时把同时有两个数不错排的排列多排除了一次，应补上;在补上时，把同时有三个数不错排的排列多补上了一次，应排除……重复该一过程，得到错排的排列种数为</p><p>$D(n) = n! - n!/1! + n!/2! - n!/3! + … + (-1)^n<em>n!/n! = ∑(k=2~n) (-1)^k </em> n! / k!$，</p><p>即$D(n) = n! [1/0! - 1/1! + 1/2! - 1/3! + 1/4! + … + (-1)^n/n!]$.</p><h3 id="简化公式"><a href="#简化公式" class="headerlink" title="简化公式"></a>简化公式</h3><p>错排的公式里有n项，计算复杂度是O(n)，有没有简便的近似值呢，像Stirling公式一般？有的，而且不仅仅是近似值：$D(n) = \lfloor n!/e+0.5 \rfloor$。（但是这个公式有何意义呢？计算n!不还得O(n)？）</p><p>以下是证明：</p><p>对$1/e$幂级数展开一波，得$1/e = e^{-1} = 1/0! - 1/1! + 1/2! - 1/3! - ….. + (-1)^n/n! + R_n(-1)$//看不懂</p><p>其中$R_n(-1)$，$R_n(-1) = (-1)^{n+1} \cdot e^u / (n+1), u∈(-1, 0)$</p><p>所以，$D(n) = n! \cdot e^{-1} - (-1)^{n+1} \cdot e^u / (n+1), u∈(-1, 0)$</p><p>而$|n! R_n| = |(-1)^{n+1} \cdot \dfrac{e^u} {n+1}| = \dfrac{e^u} {n+1} ∈ (\dfrac{1} {[e(n+1)]}, \dfrac{1}{n+1})$，可知即使在n=1时，该余项(的绝对值)也小于1/2。</p><h1 id="术语-需审核"><a href="#术语-需审核" class="headerlink" title="术语[需审核]"></a>术语[需审核]</h1><p>递推关系：recurrence relations</p><p>初始条件：initial conditions</p><p>线性常系数(非)齐次递推关系：linear (non)homogeneous recurrence relations with constant coefficients</p><p>关联的齐次递推关系：associated homogeneous recurrence relations（把F(n)去掉得到的递推关系）</p><p>特征方程/特征根：characteristic equation/roots</p><p>分治算法：divide-and-conquer algorithms</p><p>分治算法的递推关系：divide-and-conquer recurrence relation</p><p>最近点对问题：closest-pair problem</p><p>埃氏筛：sieve of Eratosthenes</p><p>错排：derangement</p><hr><p>完稿于2019-05-01</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然这章名为“计数进阶”，但其内容和“计数”关系似乎不是很大。除了生成函数是标准的“计数”内容，“递推”“分治”看起来和“计数”都没啥关系。另外容斥定理讲得也比较浅。&lt;/p&gt;
    
    </summary>
    
    
      <category term="课程笔记" scheme="https://nessoffice.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【数学之美】离散数学及其应用：第六章 计数</title>
    <link href="https://nessoffice.github.io/2019/06/22/Discrete_Mathematics-CH06/"/>
    <id>https://nessoffice.github.io/2019/06/22/Discrete_Mathematics-CH06/</id>
    <published>2019-06-22T06:19:05.000Z</published>
    <updated>2019-06-30T13:07:36.365Z</updated>
    
    <content type="html"><![CDATA[<p>通过学习这一章，你可以了解到：</p><p>①抽屉原理及其应用</p><p>②一些排列组合的情形</p><p>③和排列相关的算法</p><a id="more"></a><h1 id="计数基础"><a href="#计数基础" class="headerlink" title="计数基础"></a>计数基础</h1><p>加法原理与乘法原理，注意它们和集合的关系（前者：$|\bigcup S| = \sum|S|$，后者：$|\prod S| = \prod |S|$），后者又用到了笛卡儿积，可见笛卡儿积在描述对象间关系中的基石地位。</p><p>容斥原理，推广到n元的情况。证明可考虑单个元素在集合中的存在与否。</p><p>碱基和分子生物学的联系</p><p>解答树（让思维更有层次性）</p><h1 id="抽屉原理"><a href="#抽屉原理" class="headerlink" title="抽屉原理"></a>抽屉原理</h1><p>最初的抽屉原理，推广的抽屉原理（公式，正推反推）</p><p>抽屉原理与单射的关系</p><p>抽屉原理的思想：考虑最坏情况</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><h3 id="朋友问题"><a href="#朋友问题" class="headerlink" title="朋友问题"></a>朋友问题</h3><p>证明：假设这世界上只剩n个人了（$n \geq 2$），那么必存在两个人他们的朋友数目相等。（每个人不能是自己的朋友）</p><p>视朋友数为抽屉，人为鸽子，这样看来鸽子数等于抽屉数，抽屉原理没法用了？非也。假设所有人朋友数相同的话，那么每个人的朋友数分别取到0、2、…、n-1，然而0和n-1是有不能同时取到，这样抽屉数就减少了。</p><h3 id="二分图-待补充"><a href="#二分图-待补充" class="headerlink" title="二分图[待补充]"></a>二分图[待补充]</h3><p>15-10</p><h3 id="球队比赛-待补充"><a href="#球队比赛-待补充" class="headerlink" title="球队比赛[待补充]"></a>球队比赛[待补充]</h3><p>//还不是很理解</p><h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><p>n+1个不超过2n的数中必有一数能够整除另一数。（思路：$k = p \cdot 2^k$）</p><h3 id="子列"><a href="#子列" class="headerlink" title="子列"></a>子列</h3><p>证明：$n^2+1$长度的互异实数列中必有长为$n+1$的单调递增子列或是单调递减子列。</p><p>嗯这题看上去比较抽象，简单地列一些数据也不能带来什么帮助。用什么代表抽屉和鸽子也都不好确定，如何切入呢？题目中“互异”这是个重要的条件，否则$n^2+1$个数全相等结论就不成立了。试试反证法吧，如果数列中任意单调递增/递减子列长度都小于等于n，会有矛盾吗？</p><p>下面的一步就需要一些创造力了。对于该数列，我们令$(f(i), g(i))$为以第i项开端的最长递增/递减子列长度构成的二元组。由之前的假设，数列中任意单调递增/递减子列长度都小于等于n，$(f(i), g(i))$的取值就只有$n^2$种可能，故$\exists i \not = j, (f(i), g(i)) = (f(j), g(j))$。但是呢，$a[i] \not = a[j]$（第i个数不等于第j个数），所以要么$f(i) &gt; f(j)$，要么$g(i) &gt; g(j)$。前面的结论不成立，矛盾！</p><h3 id="子列-1"><a href="#子列-1" class="headerlink" title="子列++"></a>子列++</h3><ol><li><p>$x_1, x_2, …, x_n$为整数数列，求证$\exists i \not = j, x_i + x_{i+1} + … + x_j \equiv 0 (mod n)$。</p><p>考虑模的意义下的前缀和就好啦。</p></li><li><p>$x_1, x_2, …, x_N, N = 2^n$中，$a_i \in \{ 1, 2, …, n \}$，求证$\exists i \not = j, x_i \cdot x_{i+1} \cdot … \cdot x_j$为完全平方数。</p><p>考虑前缀积，令$A_k =  \prod\limits_{i = 1}^k a_i = \prod\limits_{i = 1}^n i^{a_{i_k}}$，考虑在模2的意义下的$a_{i_k}$，这就是抽屉了。</p></li></ol><h3 id="Ramsey问题"><a href="#Ramsey问题" class="headerlink" title="Ramsey问题"></a>Ramsey问题</h3><p>（其实就是图的二染色啦）</p><p>证明：任意六个人中，必有三人相互认识，或者相互不认识。</p><p>上例表明R(3, 3) = 6。但是当m、n变大时，R(m, n)的值非常难确定。</p><h1 id="排列组合与二项式定理"><a href="#排列组合与二项式定理" class="headerlink" title="排列组合与二项式定理"></a>排列组合与二项式定理</h1><p>排列与组和的定义，排列与组和间的转换</p><p>技巧：捆绑</p><p>组合数和二项式系数的联系</p><h2 id="组合证明"><a href="#组合证明" class="headerlink" title="组合证明"></a>组合证明</h2><p>玄学东西，和代数证明相对的。比如，通过“式子本身的意义”能证明$C_n^r = C_n^{n-r}$。</p><p>另，通过“式子本身的意义”也能得出$C_n^r$是整数。</p><p>二项式定理，由其可以得出一些结论：$\sum C_n^k = 2^n, \sum (-1)^k C_n^k = 0, \sum 2^k C_n^k = 3^n$。</p><p>杨辉三角，及其中蕴含的递推关系（它的洋名字是“Pascal’s Identity”）</p><p>“杨辉等式”的组合证明：在全集中关注某特定元素，若取到，则为$C_n^{k-1}$，否则为$C_n^k$</p><p>Vandermonde等式：$C_{m+n}^r = \sum\limits_{k = 0}^r C_m^k \cdot C_n^{r-k}$（分组的思想，特别地，有$C_{2n}^n = \sum\limits_{k = 1}^n (C_n^k)^2$）</p><p>无名定理：$C_{n+1}^{r+1} = \sum\limits_{j = r}^n C_j^r$（证明有两种思路：①排序的思想，确定最大元；②杨辉等式）</p><h1 id="排列组合的推广"><a href="#排列组合的推广" class="headerlink" title="排列组合的推广"></a>排列组合的推广</h1><p>可重复元素的排列：$n^r$（模型：r长度字符串的可能个数）</p><p>可重复元素的组和：$C_{n+r-1}^r$（模型：取硬币的方法数，证明的思想在于将无序转换为有序，然后一一对应，计算时需要注意r是元素数而n是盒子数）//待补充</p><p>$x_1+x_2+x_3=11$这样的模型，既可以用栅栏法，也可以看作是可重复元素的组和。（$x_1$可看作是放数的盒子）</p><p>含可重复元素排列的重排数（模型：分发纸牌）</p><h2 id="物块放盒子"><a href="#物块放盒子" class="headerlink" title="物块放盒子"></a>物块放盒子</h2><p>放到盒子里，是不需要考虑顺序的，故这是组和问题而非排列问题。</p><p>不同的物体放不同的盒子（模型：分发纸牌）：可重复元素排列的重排数</p><p>相同的物体放不同的盒子：可重复元素的组和</p><p>不同的物体放相同的盒子（模型：四个学生分三组）：无封闭的公式，但可用第二类斯特林公式计算，记$S(n, j) = \dfrac{1}{j!} \sum\limits_{i = 0}^{j-1}(-1)^i C_j^i (j-i)^n$，则所求即$\sum S(n, j)$。</p><p>相同的物体放相同的盒子（模式：四本相同的教材分三组）：等价于$\sum a_i = n, a_1 \leq a_2 \leq … \leq a_j$的方法数，无封闭的公式。</p><p>需要补充：</p><p>Stirling数相关知识</p><p>球盒问题特殊情形</p><h1 id="生成排列与组和"><a href="#生成排列与组和" class="headerlink" title="生成排列与组和"></a>生成排列与组和</h1><h2 id="字典序"><a href="#字典序" class="headerlink" title="字典序"></a>字典序</h2><p>以排列a[1…n]与b[1…n]为例，前者按字典序比后者小即表明，出现第一个i满足a[i]&lt;b[i]之前，均有j&lt;i且a[j]=b[j]。</p><p>以abd与abs为例，容易发现前者的字典序更小。对于1,2,3的全排列，按字典序顺序有:<br><strong>1,2,3 &lt; 1,3,2 &lt; 2,1,3 &lt; 2,3,1 &lt; 3,1,2 &lt; 3,2,1</strong></p><p>我们不难发现，枚举1,2,3的字典序我们可以先令首位分别为1,2,3，再枚举后两项的字典序，这一做法是递归的。</p><p>从字典序的概念出发，我们可以得到从一个排列出发按字典序生成下一个排列的算法。</p><p>以2,4,3,1为例。我们发现末尾中4,3,1是从大到小排列的，没有下一项，故要考虑末位四项，其中3大于2，替换2与3的位置使首位成为3，后面依次递增，得到3,1,2,4</p><p>由此我们得到一般的算法框架：</p><h2 id="生成排列算法框架"><a href="#生成排列算法框架" class="headerlink" title="生成排列算法框架"></a>生成排列算法框架</h2><ol><li>从后往前，找到第一个令a[i]&lt;a[i+1]的i(即其后是逆序的)</li><li>在a[i+1…n]中找出最小的a[j]使a[j]&gt;a[i]，交换a[i]与a[j]的位置</li><li>令a[i+1…n]呈升序</li></ol><p>在给出具体的代码前，请读者演算362541的字典序下一项，以加深理解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码引自《离散数学基础（第二版）》，清华大学出版社</span></span><br><span class="line"><span class="comment">//参考习题：洛谷P1088</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">next_permutation</span><span class="params">()</span><span class="comment">//a[1...n]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = n<span class="number">-1</span>, j = n;</span><br><span class="line">    <span class="keyword">while</span>(a[i] &gt; a[i+<span class="number">1</span>]) i--;<span class="comment">//part 1</span></span><br><span class="line">    <span class="keyword">while</span>(a[i] &gt; a[j]) j--;<span class="comment">//part 2</span></span><br><span class="line">    swap(a[i], a[j]);</span><br><span class="line">    <span class="keyword">int</span> k = n;i++;<span class="comment">//part 3</span></span><br><span class="line">    <span class="keyword">while</span>(k &gt; i)&#123;swap(a[j], a[i]);k--;i++;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合数生成算法"><a href="#组合数生成算法" class="headerlink" title="组合数生成算法"></a>组合数生成算法</h2><p>这个和二进制对应一下就好了，不必多讲。</p><h2 id="r-组和的生成算法"><a href="#r-组和的生成算法" class="headerlink" title="r-组和的生成算法"></a>r-组和的生成算法</h2><p>还是通过例子先感受一下怎么得到“下一个”r-组和吧：{1, 2, 5, 6}的下一个是？（全集为{1, 2, 3, 4, 5, 6}）</p><p>5、6都“就位”，处于字典序的最终项了。所以下一项得把2换成3，后面再按字典序的开头来，就得到了{1, 3, 4, 5}。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//the code is from Discrete Mathematics and Its Applications</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">next_combination</span><span class="params">()</span><span class="comment">//a[1...r] is the subset</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = r;</span><br><span class="line">    <span class="keyword">while</span>(a[i] == n-r+i)</span><br><span class="line">        i--;</span><br><span class="line">    a[i]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt;= r;j++)</span><br><span class="line">        a[j] = a[j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过学习这一章，你可以了解到：&lt;/p&gt;
&lt;p&gt;①抽屉原理及其应用&lt;/p&gt;
&lt;p&gt;②一些排列组合的情形&lt;/p&gt;
&lt;p&gt;③和排列相关的算法&lt;/p&gt;
    
    </summary>
    
    
      <category term="课程笔记" scheme="https://nessoffice.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【数学之美】离散数学及其应用：第五章 递推与递归</title>
    <link href="https://nessoffice.github.io/2019/06/22/Discrete_Mathematics-CH05/"/>
    <id>https://nessoffice.github.io/2019/06/22/Discrete_Mathematics-CH05/</id>
    <published>2019-06-22T06:19:04.000Z</published>
    <updated>2019-06-30T13:07:14.583Z</updated>
    
    <content type="html"><![CDATA[<p>通过学习这一章，你可以了解到：</p><p>①数学归纳法相关</p><p>②（我不知道）</p><a id="more"></a><h1 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h1><p>在第一章的最后我们也谈了谈数学归纳法，但并没有对其进行详细的探讨。所以这里还得补上。数学归纳法，本质上是一种递归的思想。明白了这一点，我们便能从大学而非高中的视角来看待它。</p><p>其正确性很容易为我们所理解，严谨地说呢，则源自良序性公理，集合中存在最小元。</p><p>数学归纳法是一种很强大的方法，用就是了，不用管对要证的东西理不理解。故较难的情形是在不显然的语境中找出使用数学归纳法的条件，这在下面的区间选择，馅饼战争乃至后文中的霍尔婚配定理上均有所体现。</p><p>因为数学归纳法可以无脑使用，它往往不能揭示所要证的命题背后的逻辑。如$\sum i^3 = [\frac{n(n+1)}{2}]^2$。数归一下就证好了。但为什么有这个式子呢？它是怎么被发现的？这都是数归所无法解答的问题。</p><p>数归被广泛地应用在证明和式，不等式，整除问题及算法分析上。简单的例子能够展现数学归纳法的有力之处，同时给予我们学习的信心；而复杂的例子则能给我们带来思维上的挑战。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>例题1：用数学归纳法证明n元的德摩根律。</p><p>例题4：三联骨牌覆盖问题。</p><p>例题2：用数学归纳法证明选区间问题中贪心算法的全局最优性。</p><p>//证明比较刁钻，也比较有创造性，待补充</p><p>例题3（Odd Pie Fights）：有奇数个两两距离不同的人，他们手中各有一个pie，会朝离自己最近的人扔pie。证明扔完一轮以后存在没被扔到pie的人。</p><p>证明（第二步）：由归纳假设，当人数为2k-1时原命题成立。考虑人数为2k+1的情况。</p><p>记AB间距离最短。考虑A，若他被B以外的人扔了pie，则因扔出的pie总数为2k+1，AB以外的2k-1个人只能被少于2k-1个pie扔到（AB被扔了至少3个），必然有人没被扔到。</p><p>若A只被B且B只被A扔了pie，那么可以先不考虑他们。剩下2k-1个人，由归纳假设，必然有人没被扔到。综上，证毕。</p><p>数学归纳法使用的谬误：要么前提错了，要么归纳不合理。这里要注意，归纳的合理性可能跟n的大小有关系。表面看看很有道理的归纳，可能在n较小的情况下不成立。请看下面的例子：</p><p>我们用数学归纳法证明所有的马都是同一颜色的。n=1，显然。n&gt;1，有归纳假设，前n-1匹马和后n-1匹马同色，而所以$color[head] = color[middle] = color[tail]$，证毕。</p><h2 id="第二类数学归纳法"><a href="#第二类数学归纳法" class="headerlink" title="第二类数学归纳法"></a>第二类数学归纳法</h2><p>在计算几何、博弈论等领域，使用第二类数学归纳法相比第一类更为方便。</p><p>例题1：证明任何大于1的整数可写为素数之积。</p><p>例题2：证明仅有2分和5分邮票就能组成大于等于5分的每种邮资。（思考，不可仅由m，n分邮票组成的最大的邮资是多少？）</p><p>例题3：$G(V, E), |V| = n \geq 3$为有向完全图，其中存在长度大于3的环，证明其中存在长度为3的环。（这个例子主要用于了解如何正确运用良序性公理）</p><h1 id="递归定义-待补充"><a href="#递归定义-待补充" class="headerlink" title="递归定义[待补充]"></a>递归定义[待补充]</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过学习这一章，你可以了解到：&lt;/p&gt;
&lt;p&gt;①数学归纳法相关&lt;/p&gt;
&lt;p&gt;②（我不知道）&lt;/p&gt;
    
    </summary>
    
    
      <category term="课程笔记" scheme="https://nessoffice.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【数学之美】离散数学及其应用：第三章 算法入门</title>
    <link href="https://nessoffice.github.io/2019/06/22/Discrete_Mathematics-CH03/"/>
    <id>https://nessoffice.github.io/2019/06/22/Discrete_Mathematics-CH03/</id>
    <published>2019-06-22T06:19:02.000Z</published>
    <updated>2019-06-29T14:18:11.610Z</updated>
    
    <content type="html"><![CDATA[<p>这章中没有涉及到许多精妙的艰深的算法，它主要是普及基础性的的概念。</p><a id="more"></a><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>这一章我们要学些什么呢~</p><p>①基本操作：搜索（序列中）与排序</p><p>②具体算法：欧几里得算法、集合生成算法、最短路算法</p><p>③算法思想：BF算法、贪心算法</p><p>④算法限制：时空复杂度</p><h2 id="算法的概念"><a href="#算法的概念" class="headerlink" title="算法的概念"></a>算法的概念</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>实际的问题很多都能转化为数学模型，这是我们上一章的所学~转化成了模型之后，就可以用算法来解决问题啦~</p><p>说到算法，一个很好的类比是菜谱，它们的共性很多：都是有限步的可操作步骤的序列。</p><p>算法（algorithm）的名称来源于阿拉伯数学家阿剌子模（Al-Khowarizmi），也可以看作是“对数”（ Logarithm）的重排。</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>线性搜索、二分搜索（限于良序集）……</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>冒泡排序、插入排序……</p><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>贪心算法（Greedy Algorithm）是解决最优化问题（optimization problem）的一种方式，它常常很有效，但有时也会失效（局部最优不一定保证全局最优）。</p><h4 id="找零问题"><a href="#找零问题" class="headerlink" title="找零问题"></a>找零问题</h4><p>考虑这样一个问题：用25毛，10毛，5毛，1毛来找钱的问题，如何使得硬币总量最少呢？贪心即可。</p><p>并非所有的币值的组合都能保障贪心的最优性，如25毛，10毛，1毛，找30毛的时候贪心就会出问题。</p><p>为什么会有这样的不同呢？关键在于小的币值能否总是换成更大的币值。在第一种情况中，如果5毛有2个，那么换成一个10毛答案会更优。故而5毛不能超过1个。而在第二种情况中，10毛可以超过2个，而不换为25毛。</p><h4 id="区间选择问题"><a href="#区间选择问题" class="headerlink" title="区间选择问题"></a>区间选择问题</h4><p>有这么一些区间$[l_1, r_1], [l_2, r_2], …, [l_n, r_n]$，问如何选区间能够使选择的区间尽可能多并保证没有两个区间相交？</p><p>lrj有做过证明，证得不错，这本书的后面也有相关的证明。</p><p>//待补充。</p><h3 id="停机问题"><a href="#停机问题" class="headerlink" title="停机问题"></a>停机问题</h3><p><a href="http://www.matrix67.com/blog/archives/901" target="_blank" rel="noopener">http://www.matrix67.com/blog/archives/901</a></p><h2 id="大O与大-Theta"><a href="#大O与大-Theta" class="headerlink" title="大O与大$\Theta$"></a>大O与大$\Theta$</h2><h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><h3 id="Euclid算法的复杂度"><a href="#Euclid算法的复杂度" class="headerlink" title="Euclid算法的复杂度"></a>Euclid算法的复杂度</h3><p>由裴蜀定理，d可表示为a、b的线性组合</p><p>大家可能听过P/NP问题还有NP完全问题等等概念（Steve Cook，就是这崽子发明的稀奇古怪的名称，NP问题、NP完全问题、NP困难问题这样的名称看着真的难受），这里引m67的一篇博文以飨诸位：<a href="http://www.matrix67.com/blog/archives/105。" target="_blank" rel="noopener">http://www.matrix67.com/blog/archives/105。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这章中没有涉及到许多精妙的艰深的算法，它主要是普及基础性的的概念。&lt;/p&gt;
    
    </summary>
    
    
      <category term="课程笔记" scheme="https://nessoffice.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【数学之美】离散数学及其应用：第二章 基本结构</title>
    <link href="https://nessoffice.github.io/2019/06/22/Discrete_Mathematics-CH02/"/>
    <id>https://nessoffice.github.io/2019/06/22/Discrete_Mathematics-CH02/</id>
    <published>2019-06-22T06:19:01.000Z</published>
    <updated>2019-06-30T13:07:07.471Z</updated>
    
    <content type="html"><![CDATA[<p>通过学习这一章，你可以了解到：</p><p>①集合、函数、序列、前缀和、矩阵</p><p>②（我不知道）</p><a id="more"></a><h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>这里涉及的是康托尔的朴素集合论而非公理集合论。后者是为解决悖论（著名的罗素悖论）而出现的，更为抽象。</p><p>集合有两种表示方法：穷举抑或描述。</p><p>Venn图在证明关于集合的命题中比较直观，关于证明，还可以采取列真值表，等价推导的方法。</p><p>集合是无序的，而有序的概念是“元组”，有了顺序，乘法就有了规范。集合的乘法称笛卡尔积（Cartesian product），它不满足交换律，除非两边相等或有空集。</p><p>谈到笛卡尔，你的第一印象是否会是平面直角坐标系？（抑或是“Cogito ergo sum.”？）事实上，笛卡尔积正是坐标系的基础：$R \times R$的结果便是所有二元组$(x, y)$的集合。推广到更高维也同理。</p><p>正如前面我们提到的模糊逻辑，模糊集合在AI中有广泛的应用。另外，多重集合也用于表示复杂图。</p><h3 id="幂集"><a href="#幂集" class="headerlink" title="幂集"></a>幂集</h3><p>以下是一些关于幂集的结论。</p><p>$x \in P(S) \Rightarrow x \subseteq S$</p><p>$x \in S \Rightarrow \{ x \} \in P(S)$</p><p>$S \in P(S)$</p><p>$P(A) \in P(B) \Rightarrow A \in B, A \in B \not \Rightarrow P(A) \in P(B)$</p><p>$A \subseteq B \Leftrightarrow P(A) \subseteq P(B)$</p><h3 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h3><p>总计五种：交（intersection）、并（union）、补（complement）差（difference）、对称差（symmetric difference）。顺带一提，compliment和complement是易混淆的单词，它们的意思是什么呢？</p><p>集合恒等式：类似逻辑中的等价，证明也类似。</p><p>交集的元素个数，用交与并表示对称差，集合的计算机表示。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>提到函数，我们先要提映射。如同其他的很多概念一样，和图一样，映射也是架构在集合之上的。集合论，是现代数学大厦的基石之一。</p><p>映射相关术语：domain&amp;codomain，image&amp;pre-image（像与原像），range（domain的子集），map。</p><p>映射的类别：one-to-one（单射，亦称injection），onto（满射，亦称surjection），bijection（双射，亦称one-to-one correspondence）。</p><p>映射的逻辑表示如下</p><ul><li>one-to-one：$\forall x \forall y (x \not = y) f(x) \not = f(y)$</li><li>onto：$\forall (y \in B) \exist (x \in A) f(x) = y$</li></ul><p>习题：存在$f : A \rightarrow B$，$|A| = m, |B| = n$。求$f$分别为一般映射、单射（如果是满射，考虑逆映射就好了）以及$f$为partial时满足以上条件可能的f数目。（$key: n^m, A_n^m, (n+1)^m, \sum\limits_{k = 0}^m C_m^k A_n^{m-k}$）</p><p>//最后一项未经验证？</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>书中记了一些不是很常用的记号：$(f_1 + f_2)(x) = f_1(x) + f_2(x), (f_1 f_2)(x) = f_1(x)f_2(x)$。</p><p>$f(S) = \{ t | \exist s \in S (f(s) = t) \}$，以此可以较严谨地证明$f(S \bigcap U) \subseteq f(S) \bigcap f(T)$。</p><p>关于函数复合和反函数，有$(f^{-1} o f)(x) = x$。</p><h3 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h3><p>floor、ceil、fractional……</p><p>这里我们就主要讨论“底与顶”吧，恰好《具体数学》也就其写了一整个章节。</p><p>为什么引入底之后还要引入可以之表示的顶？为了形式上推理的方便，正如我们既有sin也有cos一样。</p><p>$-\lfloor x \rfloor = \lfloor -x \rfloor$不总是成立，但是$- \lfloor x \rfloor = \lceil -x \rceil$。</p><p>如要将$\lfloor x \rfloor$的括号除去，我们可以用不等式（根据n的位置，也有两种形式），或者将它表示出来：$\lfloor x \rfloor = x - \{ x \}$。</p><p>一个真命题：$\lfloor \sqrt x \rfloor = \lfloor \sqrt {\lfloor x \rfloor} \rfloor$</p><p>由其联想到的真命题：$( f(x)为整 \rightarrow x为整) \rightarrow \lfloor f(x) \rfloor = \lfloor f({\lfloor x  \rfloor} ) \rfloor$</p><p>//证明待补充</p><p>由上述命题引出的有用结论：$\lfloor \frac{x + m}{n} \rfloor = \lfloor \frac{\lfloor x \rfloor + m}{n} \rfloor$</p><p>一个假命题：$\lceil \sqrt x \rceil = \lceil \sqrt{\lfloor x \rfloor} \rceil$（思考：它何时为真？）</p><p>实用的问题：$[\alpha, \beta]$中的整数个数？左闭右开如何，左开右闭又如何，左开右开呢？</p><p>有趣的问题：具体数学赌场中的转轮赌轮有1000个（或n个）投币口，标号从1到n，若$\lfloor \sqrt[3]n \rfloor | n$则庄家赔我们五百块，否则我们给庄家一百块。问玩100局是否会被警察抓起来。</p><p>有趣的问题：没有两个谱是相等的；Spec($2$)和Spec($2 + \sqrt 2$)构成正整数的一个划分。</p><p>有趣的问题：隔两人处决一人的约瑟夫问题。</p><p>//细节待补充</p><h2 id="基数"><a href="#基数" class="headerlink" title="基数"></a>基数</h2><h3 id="无限的概念"><a href="#无限的概念" class="headerlink" title="无限的概念"></a>无限的概念</h3><p>无限实际上有两种：潜无限与实无限。前者表明一种趋势，比如微积分中的极限就是一种潜无限：比任意接近都更接近。而后者则是将无限作为一种实体考察，它是一个怪兽一般不符合常识的存在。古希腊人就不承认实无限的存在，他们的证明总是“素数的数量比任意给定的数都大”而非“素数有无穷多个”。另外，芝诺的悖论也令人们对后者感到恐惧。真正以科学而非思辨考察实无限的开拓者，大概就是康托吧。</p><h3 id="无限的大小"><a href="#无限的大小" class="headerlink" title="无限的大小"></a>无限的大小</h3><p>判断无限集合，我们唯一可以信赖的方法便是一一对应，而非“整体大于部分”的原则。这一规则是康托所提出的，它并非先验的，受到了当时（也包括现在）不少人的质疑与排挤，被认为是异端邪说。康托晚年深受精神疾病的折磨，可即便如此，他还是以一己之力将集合论发展到了一定的高度，为现代数学大厦搭好了基石。康托实在是个伟大的人，虽说我对他还并不了解。</p><p>所谓可数，指的是一个集合与有限集或是自然数集具有相同的基数，即可建立二者间的一一映射。</p><p>基数、势，讲的是一个东西，无限集基数相等称为等势。</p><p>先从简单的结论开始吧：证明正整数和整数一样多。（不妨从希尔伯特旅馆的角度再看看这个例子：我们所关注的是每个个体，而非不可描述的整体）</p><p>再来是集合论中经典而又令人惊诧的结论：正整数和正有理数等势；无理数较有理数势更高。</p><p>以上分别用了两种对角线，后者即著名的康托对角线法。</p><p>通过一系列的推导，我们知道整系数多项式是可数的，故代数数——整系数多项式的根是可数的，而超越数是不可数的，即它要比代数数多得多。有趣的是，我们能数的过来的超越数少之又少。//代数数的相关资料？</p><h3 id="Schroder–Bernstein定理"><a href="#Schroder–Bernstein定理" class="headerlink" title="Schröder–Bernstein定理"></a>Schröder–Bernstein定理</h3><p>给定两集合A、B。若存在$A \rightarrow B$与$B \rightarrow A$的单射（即$|A| \leq |B|$且$|B| \leq |A|$），那么|A|=|B|。</p><p>这一定理可用于证明$|(0, 1)| = |(0, 1]|$，构造g:f(x) = x/2是$B \rightarrow A$的单射即可。</p><h3 id="不可计算数"><a href="#不可计算数" class="headerlink" title="不可计算数"></a>不可计算数</h3><p>图灵机的指令数是可数的，而实数是不可数的，故存在不可计算的数，Chaitin常数便是一个，不过我并不知道它为啥不可计算……</p><h3 id="连续统假设"><a href="#连续统假设" class="headerlink" title="连续统假设"></a>连续统假设</h3><p>先看一道例题：从正整数到{0，1，…，9}的所有映射的集合的势与[0, 1]内实数形成的集合的势相等。</p><p>把上面的十进制改为二进制，可以得到$N$的幂集与实数集等势。</p><p>记正整数的势为$\aleph_0$，实数集的势为c，上述结论即$2^{\aleph_0} = c$。如果势是可数的，而且它们按大小可以记成$\aleph_0 &lt; \aleph_1 &lt; …$（所谓一个无穷集“小于”另一者，指的是前者到后者无法得到满射）。那么，连续统假设说的就是$c = \aleph_1$，也即在两者中间没有元素。</p><p>这里连续统假设的语言表述中假设了无穷集的势的集合是离散的，是可数的。</p><p>连续统假设长久没有得到解决，希尔伯特将其作为“第一问题”。之后哥德尔还有科恩证明了CH（continuum hypothesis）在ZF公理系统中不可判定。ZF公理系统是什么？区别于“朴素集合论”的公理体系，规范了一下集合的基本性质等等，具体有八条，至少我不懂。</p><p>连续统假设假设的是$2^{\aleph_0} = \aleph_1$，照这个思路，有“广义连续统假设”（GCH）：$2^{\aleph_i} = \aleph_{i+1}$，这似乎更加困难，不过先贤也已经证明了它在ZF公理系统还有ZFC公理系统中的不可判定。ZFC比ZF多了项选择公理，反正我不懂。</p><p>小声BB一句，这些ZF、ZFC系统的名字第一眼看到感觉比较随便，没有“黎曼几何”“罗巴切夫斯基几何”看着大气，让人感觉这些所谓“公理”有一些随便（个人意见）。</p><p>我有点不明白：为什么$|N| = \aleph_0$呢，即为什么正整数的势是最小的势呢？有没有比可数集更“小”的无限集呢？</p><h3 id="攻玉与其他"><a href="#攻玉与其他" class="headerlink" title="攻玉与其他"></a>攻玉与其他</h3><p>先贴一下m67的文章：</p><p><a href="http://www.matrix67.com/blog/archives/2172" target="_blank" rel="noopener">http://www.matrix67.com/blog/archives/2172</a></p><p><a href="http://www.matrix67.com/blog/archives/4812" target="_blank" rel="noopener">http://www.matrix67.com/blog/archives/4812</a></p><p>然后讲讲文学作品中的“无限”吧。</p><p>谈到基数，弱弱地安利一下刘宇昆的《可数集》。小说将理性与非理性、数学的简单与生活的复杂做了很好的映射，以别出心裁的方式（有些意识流，在这个设定下尤其自然）表现了两个世界的冲突：理性的学术（或者更柏拉图些，“理念”）与非理性的生活。当主人公走在康托的路上，觉察到数学的可怖与不可描述，体味到理念的无稽与诡谲之时，他也只得放弃自己曾经坚守的理性，成为生活的荒诞的一部分，在多种意义上。这篇用大刘的话说，是“从宏大的数学背景上重新审视人生”，颇具“科幻的诗意”。</p><p>谈到无穷，也不能不提博尔赫斯，《小径分岔的花园》《巴别图书馆》《阿莱夫》《沙之书》……不过这边就不展开了。顺便，《可数集》收录在《杀敌算法》里头，而《科幻世界》中的译名是“人生可数集”，我觉得是画蛇添足（原文<em>The Countable</em>）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过学习这一章，你可以了解到：&lt;/p&gt;
&lt;p&gt;①集合、函数、序列、前缀和、矩阵&lt;/p&gt;
&lt;p&gt;②（我不知道）&lt;/p&gt;
    
    </summary>
    
    
      <category term="课程笔记" scheme="https://nessoffice.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【数学之美】离散数学及其应用：第一章 逻辑与证明</title>
    <link href="https://nessoffice.github.io/2019/06/22/Discrete_Mathematics-CH01/"/>
    <id>https://nessoffice.github.io/2019/06/22/Discrete_Mathematics-CH01/</id>
    <published>2019-06-22T06:19:00.000Z</published>
    <updated>2019-06-30T12:09:25.661Z</updated>
    
    <content type="html"><![CDATA[<p>通过学习这一章，你可以了解到：</p><p>①形式逻辑与谓词逻辑相关知识</p><p>②一些证明的方法</p><a id="more"></a><h1 id="命题逻辑"><a href="#命题逻辑" class="headerlink" title="命题逻辑"></a>命题逻辑</h1><p>逻辑中的符号系统：对自然语言的抽象，以便研究符号间的关系。</p><p>通过对复杂的语句进行编码，用逻辑学的方式讨论他们，那么语句本身的特殊性就消失了，含糊与歧义在一定程度上的被消灭了（但整个系统并非完备的，据哥德尔的证明）。这样语篇就被转化为了命题的组合，我们得以更容易地判断它们是否合乎逻辑的。</p><p>命题的定义即可判断真假的陈述句，故若将命题记作变量p，则它有两种取值，那么我们可以把它和二进制，和布尔代数联系起来。但世界上也存在多值逻辑与模糊逻辑。//虽然我根本不懂</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>命题（Proposition），“往矣”“可乎”“此言谬矣”等并非命题。</p><p>否定（Negation）</p><p>合取（Conjunction），$\wedge$，and的抽象。</p><p>析取（Disjunction），$\vee$，or的抽象。</p><p>异或（Exclusive Or），在自然语言向符号系统转化的时候尤其要关注关系是exclusive还是inclusive。</p><p>异或有个很漂亮的应用，博弈论中的Nimm’s Game，它涉及的性质是a^b=0当且仅当a=b，还有异或的交换律，所以这种博弈以所有数的异或和作为判断基准。（我瞎说的）</p><p>异或还有一些简单的性质，在有的题目中可能会用到。如a ^ b = c $\Leftrightarrow$ a ^ c = b，还有a - b $\leq$ a ^ b。这些并不难证明，但要想到它们就有一些难度了。</p><p>蕴含（Implication），关注only if和if的区别，充分条件和必要条件及其他表达。蕴含式的真值规则可以在生活中找到一些很好的例子，如合同，承诺等。</p><p>等价（Equivalent），注意它和$\equiv$还有$\Leftrightarrow$的区别，后两者是等价的。</p><p>真值表（Truth Table），多用于证明，但我不大喜欢这样的证明，感觉不如Venn图直观，也不如简单的推理来得漂亮。</p><p>概念还有运算符顺序、位运算。//运算符顺序为何如此？</p><p>习题1：有100句话，第i句说的是“这些话中恰有i句是假话”（变式：“这些话中至少i句是假话”），求哪些是真话哪些是假话。（lrj在他的鬼书里也有这样递归的鬼问题，但我不会啊qwq）</p><p>习题2：判断$(p \vee \lnot q) \wedge (q \vee \lnot r) \wedge (r \vee \lnot p)$何时为真，何时为假。</p><p>习题3：判断$(p \wedge q \wedge r) \vee (\lnot p \wedge \lnot q \wedge \lnot r)$何时为真，何时为假。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>1.翻译自然语言并判断其间的逻辑性。</p><p>2.对一大串语言能否同时为真做判断。因为语言所涉及的多为一个系统所以这也叫System Specification。如果同时为真，称they are consistent。</p><p>3.在数据库中检索信息，在网络中查找网页。（在吴军老师的书中有进一步的介绍，但我还没好好看）</p><p>4.Puzzles，如说谎者游戏。这些游戏可能能发展小孩的智力。道奇森在这方面有一定的建树，其著作《爱丽丝漫游奇境》就蕴含了作者丰富的数学思想和对儿童的深切的关爱。</p><p>5.表示逻辑电路（香农首次大规模将逻辑与电路连接起来，从而建立了通信理论的大厦）。</p><p>Exercise 15，16，17，//题干太长懒得抄</p><p>习题2：斑马问题（zebra puzzle）</p><p>题解：先冷静下来，放松一下心情。（怪我英语不好，把to the right和on the right意思搞反了，也懒得改过来了，就这么做吧~心路历程而已）</p><p>1.先观察房子颜色，题目中出现了全部五色房子，挪威人住第一间，他右边是蓝房子。房子颜色，经过简单疏理，是黄蓝红绿白或黄蓝绿白红，推出挪威人住黄房子，他是外交官，然后蓝屋子屋主养马。</p><p>2.绿屋子人喝咖啡，而中间屋子人喝奶，所以房子排列只能是黄蓝红绿白。英国人住红房子喝奶。</p><p>3.下面看职业和饮料。𠸄人嗜奶，意人嗜茶，挪威人是外交官，日本人是画家，故而喝橙汁的音乐家是西班牙人，他养狗，不住蓝屋子（马限制），不住红屋子（英国人已占），不住绿屋子（咖啡限制），住白房子。</p><p>4.意大利人喝茶，不住绿屋子，那么他住蓝屋子。排除法得日本人住绿房子，画家，喝咖啡。</p><p>4.再看宠物。摄影师养蜗牛，西班牙人白房子养狗，意大利人蓝屋子主养马，挪威人不是摄影师，那么摄影师是意大利人或英国人，若为前者，则后者是医生，旁边没狐狸，矛盾。所以英国人是摄影师养蜗牛，挪威人养狐狸。排除得日本人养斑马。</p><p>5.英国牛奶，西班牙橙汁，意大利的茶，日本咖啡。排除出来矿泉水挪威。</p><p>疑惑：为什么错误的前提也能推出正确的结论呢？是什么影响了答案的走向与其是否自洽？另外，这个题目是如何构思出的呢？怎样保证在讯息最少的情况下可解呢？</p><h2 id="等价"><a href="#等价" class="headerlink" title="等价"></a>等价</h2><p>等价、同构，将复杂的问题归而为一，充分展现了数学的奇妙与瑰丽。</p><p>等价涉及了一些概念：重言式或永真式，矛盾式，将这些概念和蕴含想结合定义等价会更方便。</p><p>说到等价，势必要讲到一系列定律，其中需要记的有德·摩根律（及其n元形态）、分配律、蕴含到析取合取的转化，而对吸收律等的运用要具备一定观察能力。</p><p>判断命题为真时的取值问题，习题3是个很好的例子。</p><p>上述问题的一个应用是解数独，貌似可以用bfs实现。//但我还不会啊qwq，而且书上那个记号是啥意思咧？</p><p>习题1：探索何谓对偶命题及为何等价的命题能推出其对偶命题也等价。//不会鸭。。</p><p>习题2：Exercise 41，有无更巧妙的构造方法？</p><p>习题3：什么样的取值能使$p \vee \lnot q \vee s, \lnot p \vee \lnot r \vee s,$ $ \lnot p \vee \lnot r \vee \lnot s, \lnot p \vee q \vee \lnot s$ $, q \vee r \vee \lnot s,<script type="math/tex">q \vee \lnot r \vee \lnot s,</script> \lnot p \vee \lnot q \vee \lnot s, p \vee r \vee s, p \vee r \vee \lnot s$中尽可能多的值为真呢？//普遍的算法？</p><p>//NAND，NOR这些都什么东西？干嘛要提它们？</p><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>命题的组和是无穷无尽的，但其真值是有限的。为了将不同形式下真值一致的复合命题归为一类，我们引入范式(normal form)的概念，其中有CNF与DNF两类(C for conjunction)，他们间也可以互相转化。//补充</p><p>不过，许多范式仍然不够漂亮，比方说$p \vee \lnot p \vee (q \wedge \lnot r)$。为了让范式更加规范，我们引入主(full)析取/合取范式的概念，这样范式就和真值表紧密相连了。而任何命题均可转化到范式，由真值表易知。</p><p>欲将复合命题转化为范式，一种做法是列真值表，这是比较容易的。如果得到了主析取范式，利用真值表也能够直接得到主合取范式。</p><p>另一种做法是直接推导。先将部分的$\lnot$（任何不是修饰原子命题的）及$\rightarrow$除去及重复的原子命题。这样原命题便被转化为$p_i, \vee, \wedge$的串，接着再大量使用结合律就好了，同时注意添项。//例子</p><h1 id="谓词逻辑"><a href="#谓词逻辑" class="headerlink" title="谓词逻辑"></a>谓词逻辑</h1><h2 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h2><p>谈到逻辑，一个相当经典的概念便是亚里士多德提出的三段论。然而，仅凭命题逻辑无法从小前提与大前提得出结论，因为前提与结论中有的只是内容而非形式上的联系（还记得么？命题逻辑中的if then前后的语句无需有任何关联。还有，包含未定变元的陈述句亦不成命题）。数学上，我们常要研究对象的性质问题，故需将问题细化，从命题逻辑深入谓词逻辑。</p><p>谓词逻辑中的对象一般是未定式，故在形式上一个谓词命题，P(x)，看上去更接近一个函数，x也有自己的定义域(domain)。看到变元就关注定义域是一个重要而良好的习惯。</p><h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><p>x的定义域是一个集合，其中的元素有的满足性质P，有的并不满足。为了表达定义域中是否存在满足性质的x这一需求，我们再引入量词(quantifier)的概念。常用的量词有$\exists, \forall$，不常见的有$\exists_1$等等。</p><p>量词的引入实则是对符号系统的一种简化，使其能更好地符合我们的思维习惯以提高推理效率。以$\forall x P(x)$为例，它等价于$\bigvee\limits_x P(x), x \in S$。因为这种等价性，含量词的复合命题在取否定有“存在转任意，任意转存在”的规则，这实则就是德摩根律的推广。</p><p>量词的一个重要要素就是它的约束范围，即它与哪一式子结合(bind)。$\forall x P(x) \wedge \forall x Q(x)$与$\forall x (P(x) \wedge Q(x))$在意义上并不一致。前者那样的写法在式子变得更加复杂时很可能引起一定程度混乱，故我们再引入前束范式(prenex normal form)的概念——将所有量词提前，可能产生歧义的变元用不同的记号标识（插一句，我觉得$\forall x (P(x, y) \wedge \forall y Q(y))$这样的写法很反人类）。</p><h2 id="等价-1"><a href="#等价-1" class="headerlink" title="等价"></a>等价</h2><p>涉及量词的等价，往往不能简单粗暴地列真值表了，而是要用推理了。</p><p>习题？证明$\forall x (P(x) \wedge Q(x)) \equiv \forall x P(x) \wedge \forall x Q(x)$和$\exists x (P(x) \vee Q(x)) \equiv \exists x P(x) \vee \exists x Q(x)$，举出$\exists x (P(x) \wedge Q(x)) \not\equiv \exists x P(x) \wedge \exists x Q(x)$还有$\forall x (P(x) \vee Q(x)) \not \equiv \forall x P(x) \vee \forall x Q(x)$的例子。</p><p>另外还有量词命题和无量词命题(null quantification)析取合取（如$\forall P(x) \vee A$）的等价式，一般情况下都是可以直接去括号的，但涉及蕴含的时候要小心点因为蕴含和否定是相关联的。</p><p>谓词和量词的概念就介绍到这里了，不过有了新的记号我们前面的翻译啊什么的也都升级了，毕竟这一章仍是前几章的推广嘛，中心思想仍未变。翻译中值得注意的一种类型是定义域较小的情况。比方说，令全集为生物，P(x)表示“x是狮子”，Q(x)表示“x爱喝茶”。则“所有狮子爱喝茶”是$\forall x (P(x) \rightarrow Q(x))$，而“有狮子爱喝茶”是$\exists x (P(x) \wedge Q(x))$。为什么会这样？其实只要关注狮子以外的动物就好了。</p><p>//书上的习题没怎么做，标*的也就是类似三段论的。</p><h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><p>上面讲的往往都是单个量词的情况，但现实是“更多量词，更多欢乐”。比如说，表示加法结合律，表示$\epsilon - \delta$语言，都要用到量词的嵌套。量词嵌套涉及到顺序的问题，里头的规则很简单：相同的能替换，不同的不能换，这也很好理解，可以在脑海中对所有元素遍历一遍来加深印象。</p><p>有新的概念引入，否定自然也是要实时更新的了，不过规则格外简单：存在变任意，任意变存在，否定移进去。</p><p>有新的概念引入，翻译自然也会更新了，除了和自然语言间转来转去，有了量词嵌套，数学语言也可以加入转换行列了，快来用最新的量词嵌套试试九种最基本的算数性质吧！</p><p>有了嵌套，命题者就可以用更<del>新颖</del>恶意的方式定义$\exists_1$等量词了。比如，好好的$\exists_1 b P(a, b)$会变成$\exists b \forall c (P(a, b) \wedge (b \not = c) \rightarrow \lnot P(a, c))$，更漂亮了对吧。</p><h1 id="推理与证明"><a href="#推理与证明" class="headerlink" title="推理与证明"></a>推理与证明</h1><p>在讲命题逻辑的时候，我们都是根据已有的命题组判断其真假性，涉及到的命题组还只是个封闭的集合。那么，我们能否由已知的命题推出新的命题，比如三段论中的结论？推理规则就要派上用场了，它能让我们进行推理——在假定premises均为真的情况下推出新的命题。</p><h2 id="推理规则"><a href="#推理规则" class="headerlink" title="推理规则"></a>推理规则</h2><p>关于推理规则有一整张表，但是我不喜欢列表，就逐项分析吧。</p><p>1.Modus ponens/tollens，它们和蕴含相关联。前提真则结论真，结论假则前提假，非常好理解。关于后者的证明可以直接感受也可以列真值表也可以用逆否命题来证，个人感觉最后一项比较漂亮，因为它涉及的是化归的思想。而且，使用逆否命题有时候可以让推理变得简单。</p><p>//关于modus ponens的中文命名“假言推理”我并不是很明白。同时这些规则为什么要叫这些名字呢？</p><p>2.Hypothetical syllogism，假言三段论，这就更好理解了。可以把它和析取三段论（Disjunctive syllogism）放一块记。</p><p>3.和析取/合取有关的规则。从单项到合取式是添项（Addition，$p \Rightarrow p \vee q$），从析取式到单项是减项（Simplification，$p \wedge q \Rightarrow p$），还有析取（Conjunction，$p, q \Rightarrow p \wedge q$）。很容易推，因为前提是真的。</p><p>4.Resolution，这个比较特别，两个析取推出一个析取，起到删项的作用。有点像一个元素和他的逆相乘然后抵掉这样的感觉。</p><p>推理规则和永真式是有所联系的，比如$p_1, p_2, …, p_n \Rightarrow q$是有效（valid）推理，那么$\bigwedge\limits_i p_i\rightarrow q$便是永真式。</p><p>一般情况下我们要推理的结论都是可爱的非复合命题，如果它长得比较丑陋，比方说，$p \rightarrow q$，该怎么办呢？不用慌，把p看作新的条件而q看作新的结论就好了。而如果它是析取项，可以考虑Resolution。</p><p><del>5.Fallacy of affirming the conclusion，错误推理。</del>比如，有萌新可能会发现这样的新大陆：$p \rightarrow q, q \Rightarrow p$。这非常的正确！而且它还有好多等价的涉及否定的变形，快来用它们拓展你的推理规则仓库吧！（手动滑稽）</p><p>5.涉及量词的推理，universal/existsential instantiation/generalization，共四个，可以望文生义。为什么要引入它们呢？因为我们具体推理地时候不能抽象地说“存在一个”“对任一”，而要用具体的符号表示“那一个/那一类”。但引入这些东西有时候也会造成推理的错误，但一般通过举出一个具体的例子这一方式还是能发现问题所在的。</p><h2 id="证明初步"><a href="#证明初步" class="headerlink" title="证明初步"></a>证明初步</h2><p>证明，首先有Formal Proof与Informal Proof之分，前者是上一节所要遵守的规范格式，很丑陋，很麻烦，很不人性，故现实中我们一般都采取后者，省掉一些“显然”的步骤来使证明在格式上更漂亮。但是要注意，“显然”有时并不“显然”，蕴含了跳步与可能的错误。为让愚昧的计算机理解智慧的人类的证明，我们只得采取Formal Proof。</p><p>关于证明，这里推荐张景中院士的《数学家的眼光》一书，虽然它主要面向中学生，但其中证明的思路与看待问题的眼光都是相当犀利的。（如果诸位了解同类型的优质读物请务必向我推荐，毕竟我对数学只懂些皮毛而已）</p><h3 id="证明策略"><a href="#证明策略" class="headerlink" title="证明策略"></a>证明策略</h3><ol><li><p>直接法</p><p>1-1：对$\exists$可以分类遍历，对$\forall$则可以分类枚举；</p><p>1-2：正向或反向或正向反向一起用证明（正向曰由因导果或“综合法”，反向曰由果索因或“分析法”）。</p><p>1-3：对$\exists$可以采用构造的方式（典例：证明存在连续10个合数），对$\forall$可以采取找反例的方式；</p></li><li><p>间接法</p><p>如果直接法不好入手（如“无理数”是实数排除“有理数”而生的概念，本身的定义不好用），可以考虑间接法。</p><p>2-1：证明逆否命题。</p><p>2-2：反证法，假设结论不成立，推出矛盾之处。反证法的理论基础是$\lnot p \rightarrow (r \wedge \lnot r)$，其中r是任意矛盾的命题，在$\sqrt 2$的例子中，即“m，n互素”。</p><p>关于反证法有很多漂亮的例子，此处列出一些，以飨读者。</p><p>典例1（数论）：证明$\sqrt 2$为无理数。</p><p>典例2（数论）：证明素数有无穷多个。</p><p>典例3（组和）：证明抽屉原理。</p></li><li><p>归纳</p><p>包括但不限于数学归纳法及其变种（第二类数学归纳法，反向数学归纳法，后者可用于证明n元的基本不等式）。</p><p>归纳（induction）不只是种证明的方法，它更是一种思维方式，“告诸往而知来者”，从特殊到一般的思想。与之相对的是演绎（deduction），从一般到特殊的思想。我们前面所学的推理便是都是演绎的典范。</p></li><li><p>其他</p><p>Vacuous Proof与Trivial Proof，相当没意思：证明条件为假或结论为真，于是$p \rightarrow q$必为真。</p></li></ol><h3 id="证明类别"><a href="#证明类别" class="headerlink" title="证明类别"></a>证明类别</h3><p>证明可以正向也可以反向也可以结合二者，反向的一个例子是Bash Game。</p><h4 id="存在性证明"><a href="#存在性证明" class="headerlink" title="存在性证明"></a>存在性证明</h4><p>对于存在性证明，有构造性的也有非构造性的，非构造性证明往往是分析性质，或是使用数学归纳法，而不会给出求解的算法，如霍尔婚配定理的证明。</p><p>对于“存在可被两种方式写为两立方数和的正整数”，我们可以算出$1729 = 10^3 + 9^3 = 12^3 + 1^3$。顺带一提，1729被称为“拉马努金数”，是一个“有意思的数”。（读者不妨对“有意思的数”展开一些思考，比如想想是否存在最小的正的“没意思的数”）</p><p>非构造性证明的一个漂亮例子是“证明存在无理数x, y使得$x^y$是有理数”。</p><p>对于非构造性证明，书中还给出了博弈论中的Chomp game，也是经典的例子。</p><h4 id="穷举法"><a href="#穷举法" class="headerlink" title="穷举法"></a>穷举法</h4><p>穷举往往是针对有限元的，而且数目不能太多，否则人类做着会烦。但是面对无限元也可以穷举不怂，因为把握精度或许能够将我们所面对无限集转化为“要穷举的”有限集。</p><p>//例子</p><h4 id="唯一性"><a href="#唯一性" class="headerlink" title="唯一性"></a>唯一性</h4><p>平面几何中有很多关于唯一性的证明，要用到同一律，例子有Ceva定理等。</p><p>对于一些新引入的概念我们也常要证明唯一性，如矩阵的逆（若存在）是唯一的，乘法逆元（若存在）在模p的意义下是唯一的。</p><h4 id="等价定理"><a href="#等价定理" class="headerlink" title="等价定理"></a>等价定理</h4><p>涉及一组等价定理的证明，我们可以采取$p_1 \Rightarrow p_2, p_2 \Rightarrow p_3, … , p_n \Rightarrow p_1$这样的策略，减少多余的证明。例子么，以下。</p><p>1.$f(x_1, x_2, … , x_n) = X^T A X$为正定二次型。</p><p>2.$f(x_1, x_2, … , x_n) = X^T A X$正惯性指数为n。</p><p>3.存在可逆矩阵B使得$A = B^T B$。</p><p>4.A的顺序主子式均大于0。</p><h4 id="完备性"><a href="#完备性" class="headerlink" title="完备性"></a>完备性</h4><p>希尔伯特等的乐观主义使他们希望在公理之上构建出至臻至善的数学大厦。他在20年代提出了建立一组公理体系来保证数学“完备性”“独立性”“相容性”的期望。所谓完备性，指的是一切数学命题在原则上可判定真伪。然而哥德尔不完备性定理击碎了这一期望。比如古德斯坦定理，其在皮亚诺公理系统中是不可证的，但用超出这一公理系统的方法则可证明。</p><p>//这一段如出现知识性错误，请指出。</p><h4 id="开放问题"><a href="#开放问题" class="headerlink" title="开放问题"></a>开放问题</h4><p>费马大定理（已解决），3x+1猜想。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>证明是一个大有文章可做的话题，即便是前面讲到的看上去没啥好说的直接法，里头也包含了方方面面的子方法，它们考察的对象各不相同。如在组合中，染色法有很大的作用。在证明和式相等的时候，图形证明则将数学之美展现得淋漓尽致。（如果觉得三角形数正方形数太小儿科，不妨用图形证一证Abel恒等式）</p><p>另外，证明的时候骚话不能多说，像什么“显然”；有的话该说得说，如“不失一般性”。</p><p>上面提到用反证法证明“素数有无穷多个”。不过事实上，这一相对简单的定理能以很多种方法证明，卢昌海于<a href="https://www.changhai.org/articles/science/mathematics/IP.php" target="_blank" rel="noopener">这篇blog</a>中汇总了九种方法（虽说有的有些重复），私以为这一篇的水准相当不错（卢昌海关于数学的科普写得少，但个人感觉都非超好）。这里简单分享一下欣赏完后的感想：后面的大部分方法依据的都是算术基本定理，结合或组和或数论或其他的方法精妙地推出了矛盾。而利用数列的证明还有用欧拉函数的证明看起来与其他方法均不同，较为特殊。好的科普就应该是这样的：拓宽认识问题的角度，并给予读者意料之外的收获（如对$\pi (N)$的粗略估计，各个领域的联通，等等）。</p><h3 id="证明误区"><a href="#证明误区" class="headerlink" title="证明误区"></a>证明误区</h3><p>警惕错误的前提还有错误的推理！一般通过常识还有举例都能够判断结论是否为真，然后挑错就是了。网上时常有神仙一言不合就推倒数学大厦，大家不妨从中找找乐子，顺带锻炼锻炼自己的挑错能力，好使逻辑更严密。</p><p>错误的推理包括但不限于命题逻辑中的错误推理（请参阅《推理规则》第五条），“除以0”等等也应纳入考虑范围。</p><p>还有种证明误区便是循环论证——（隐蔽地）利用结论来推结论。这和前面的错误也相仿，只不过它用的是“未定”的前提而非错误的前提。</p><p>其实，我们所用的语言本身就是循环自指的——字典上为诠释一词的意思必须用其他的词语来描述，来类比。在这样的情况下，用语言来探究哲学的基本问题是否值得？哲学是否只是文字游戏？若不借助文字，我们又如何组织思维？通过内在的感知？这又是否“理性”，是否合乎“逻辑”呢？等等。我对这些问题没有解答的欲望，我只是选择了游世的态度，在空虚的精神王国中回避着一切问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过学习这一章，你可以了解到：&lt;/p&gt;
&lt;p&gt;①形式逻辑与谓词逻辑相关知识&lt;/p&gt;
&lt;p&gt;②一些证明的方法&lt;/p&gt;
    
    </summary>
    
    
      <category term="课程笔记" scheme="https://nessoffice.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【图灵之路】管理的困境——记project-tetris开发的心路历程</title>
    <link href="https://nessoffice.github.io/2019/06/16/Project-Tetris/"/>
    <id>https://nessoffice.github.io/2019/06/16/Project-Tetris/</id>
    <published>2019-06-16T11:50:59.000Z</published>
    <updated>2019-06-16T13:38:59.841Z</updated>
    
    <content type="html"><![CDATA[<p>切身体验，何谓人月神话。同时享受，心态雪崩的感觉……</p><a id="more"></a><h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>整个过程中并非徒劳无功的，我收获了什么呢？友情，一些较软的能力，经验教训。只是在程序设计能力上的收获，简直是负的……或者说我原来的能力就是负的吧。这是个简单的项目，但我在管理上的失误，把简单搞得无比复杂。</p><p>C大程的大作业，有四个选题：学生信息管理系统、CAD、俄罗斯方块、自主选题。搞模拟题搞怕了，不想弄第一个；没深入搞过CAD，第二个也不成；对要玩什么没啥想法，自主选题估计选个题就能憋死。这样看来只有俄罗斯方块能搞了。虽然我不太喜欢玩俄罗斯方块，但也只能选这个啦。俄罗斯方块，有什么可以创新的地方呢……（谈到俄罗斯方块，谈到创新，总会想到《伊莉丝症候群(<em>irisu syndrome</em>)》，想到这个兔子和猫的故事……不过这里头的玩法是和剧情相关联的，和俄罗斯方块还有些差别，而且我对剧情根本没有想法呀）</p><p>先不管这些，直接动手做吧。</p><h1 id="进展"><a href="#进展" class="headerlink" title="进展"></a>进展</h1><p>这个项目的进展……非常迷。题目布置得特别早，故项目的工时很长。</p><p>一开始的两三周先是研究这个libgraphics。通过demo看看它是如何运作的，学习回调函数的用法，学习基本的绘图套路。这个时候的心态尚不是很好。因为这些东西跟环境也有关联。明明知道这个东西这么写是对的，可为何就运行不起来呢？总归是某个小地方出了问题，但就是不知是哪里的问题，就很烦。搞前端的时候也经常碰到这样的问题，trivial，麻烦。</p><p>知道了库该怎么用，接下来该是游戏的设计阶段了（我直接跳过了需求理解的部分）。我的想法是先搞下落、消行这些东西，再来搞tetris的类型，旋转啊那些。于是先把所有tetris简化为1*1的方块。下落便是改变中心点的位置，消行便是检测单行的block数。这些现在看来非常容易实现，但写的时候想法很多，一会感觉可以这么写，写着写着感觉那样会更好，就经常重构代码，一会儿换成这种风格，一会儿又是那种风格。重构一时爽，但重构完后就会发现自己啥也没干，就会开始怀疑自己。这是很不好的。探索固然有趣，但要有规划的探索，那应当更为有趣且有收获。</p><p>上面那些写好后，过了若干周，感觉可以开始设计tetris的结构了。怎么设计呢？考虑邻接矩阵吧。设个数组存邻接点的个数，再设两个数组存邻接点的坐标。好，那先弄个“田”出来吧，这一搞发现出了好多问题……比如在边界上的处理。等等。这些解决方案也是一点一点试出来的，主要是细节没搞清楚，我好像也没仔细记录。</p><p>后面的思路好像比较乱了？每次都不知道自己在搞什么，就东搞搞西搞搞，时间就搞过去了。这或许是需求理解和进度规划上的不明确导致的。</p><p>另外，整个项目没有一气呵成的感觉，往往是干个两三天，停个十几天，再来干两三天。然后中间把锅分出去之后就收不回来了，直到快交作业那星期进度才开始提上来。此时我的psycho-pass陡增。看着屏幕上的代码，时常会感到一阵，持久的，沉重的，虚无。</p><h1 id="个人层面的管理"><a href="#个人层面的管理" class="headerlink" title="个人层面的管理"></a>个人层面的管理</h1><p>首先是心态的管理。一方面是要有信念，对自己的信心，对别人的信心，对emergency的解决方案的信心。同时，需要有足够的管理能力提高对项目的把控能力以支撑信念。以下，是此次项目中没能表现出来的能力。</p><p>组织思路与组织代码。不需要很详细的文档，可以是函数调用关系图，可以是对一个功能在实现前的规划草稿，还有把类似功能的函数集中到一块。在开始想好方案不要改，或者事后再重构。封装常用功能。通过肉眼查重降低冗余度。保留档案。</p><p>文件管理。把不同类型的文件搞到不同的文件夹里面，保持树状结构。文件名规范化（”tetris-ln-190616-2117”），并维护更新信息。</p><p>预设测试情形，想好有哪些功能是需要测试的。每拿到一个新的不同版本的文件测试并做标记（“ranklist——符合预期”，“editbox——异常退出”）。</p><h1 id="ui设计中的管理"><a href="#ui设计中的管理" class="headerlink" title="ui设计中的管理"></a>ui设计中的管理</h1><p>（好吧这个标题和上面的标题下面的标题都不对应，不过这个东西有必要讲讲的）</p><p>ui的设计是所见即所得的，能够给予开发者一定的成就感，但也容易利用这成就感极大地耗散开发者的时间与精力，降低其效率。故ui的设计虽然好玩，但也不能仅仅抱着玩的心态看待，它也是需要分析的。</p><p>怎么分析呢？可以先明确一下一个小的阶段中要达成的效果：设计出ranklist的实现样式。这需要先搞出一个原型，提炼出需要使用的控件，确定好控件的颜色，确定好背景，等等。有了原型，设计的时候能更有针对性，而不是这搞搞那搞搞。</p><p>放置控件时我们也经常会想“欸这个放在这里是不是更好看”“欸这个拉长一点会怎么样”。这些常常会在占去大量的时间，但最终效果相差无几。修参的工作最好集中出一块时间来做，同时在这过程中要保证有效的调试手段，如键入位置信息、颜色信息等，而不能总是关闭-重运行。</p><h1 id="沟通与团队协作"><a href="#沟通与团队协作" class="headerlink" title="沟通与团队协作"></a>沟通与团队协作</h1><p>个人观察发现，三人小组往往会退化为两人小组或是一人小组，尤其在组员间相互不是很熟的情况瞎，因为团队的凝聚力不总是很高。作业做着做着有时候就感觉累了，宁愿自己做也不想把任务分出去，或是对这个项目不上心就把它鸽了。但在tetris这个项目中，团队的凝聚力还是较高的，个人认为原因在于组员间有一定的了解，能够相互理解与体谅，所以退化并没有发生。（如果我前几个星期不是特别忙也对tetris特别感兴趣的话，也许io、加密、ui还有其他部分我都揽过去了？这样项目的结束可能会早一些，但也只会像我高中时候的其他作品一样吧，其间我无法收获管理等其他方面的教训。然后我和她们也不会有更多的交集了，应该。）</p><p>一个团队是否总会发生马太效应？能者往往多劳，故强者愈强，弱者愈弱。“弱者愈弱”指的并非在能力上发生倒退，而是指的不受待见的沮丧，对自身能力的怀疑，这么一种心态。这在计算机学科的学习中是非常危险的，因为实际上，许多课程的。个人常秉持这样的观念：别人的东西看不懂，主要原因不是我太弱（这种话都是事后说的），而是对方写得不够清晰。变量名混乱，代码冗余度高，逻辑清奇（尤其这一点！）都是对方而非自身的过错。我已尽自身一部分所能梳理清楚其逻辑但仍对其总体架构抑或细节实现不甚明了，这反映了对方在对程序的运行逻辑的理解上也不够清晰（至少没有表现出来），故我当见不贤而内自省。</p><p>当然……问题也不尽是别人的问题，很多也是自己的问题。只会写hello world然后被lisp系的语法绕晕难道总是语言设计者的过错？在连最基本的图遍历算法都没写过的情况下看不懂人家的tarjan算法难道应该怪对方的代码不友好？这些问题，确实是自身能力不足所造成的，故我们在骂街之余当积极寻求解决方案。这个过程中尤其要注意解决方案面向的对象。在赛场上可以不加注释，但写题解时还应将各个细节点得清楚明白而不是把AC的代码往上一扔。要读懂这段代码需要什么样的前导知识，这些，我认为都是必要的，是将零散的知识点串成一环的有益疏理，也为对这一知识点尚不熟悉的同学提供了学习的方向。但遗憾的是，至少我很少看见这样的尝试，而与之相悖的做法（扔代码，玄学证明）倒是数见不鲜。</p><p>以上的情形更多发生在个人中，与团队中的情形略有不同。团队降低了沟通的成本（在网上发问，指不定有人会理你），但并没有降低沟通的难度（“你在说什么？”）。在这样的情况下，简单的沟通能够传递一些好的习惯，同时解决一些琐碎的问题；而更深入的沟通呢？至少还没想清楚……这或许还需要在长期的实践中思考才好得出一般性的方法论。</p><p>团队协作无可避免地涉及到交易成本——在软件工程中，集中表现为沟通的成本，理解代码的成本，等等。看自己的代码交易成本往往是比较低的，因为潜意识中对一些细节大脑已经做好了思考，整个程序的脉络也往往较为清晰。但是如果过了几个月，代码逻辑比较复杂还没什么注释，那么看自己的代码交易成本可能就上来了。至于看他人的代码，一般也都要付出高额的交易成本——时间、精力、信心。</p><p>那么如何提升交易的能力呢？我们注意到，项目的一部分的代码是整体性的，是许多点连成的面，很稠密，复杂度很高。虽然理解整个面或许较为困难，但是理解一些要点相对来说会简单一些。（CTF一般都是找关键点，在复杂的题目中）于是可以提取关键点，抓住主要矛盾，逐个击破，同时梳理好打持久战的意识，可能会有一些帮助。</p><h1 id="Leadership"><a href="#Leadership" class="headerlink" title="Leadership"></a>Leadership</h1><p>（我可能不具有这个东西，但理应具有这个东西）</p><p>一般而言，组长对项目的把控等级是最高的，ta决定项目宏观的方向，整体的架构。这些尚是个人层面的。在团队的层面，协调就麻烦了……</p><p>要分工，需要要了解他人的相性，了解其所面临的问题，了解其心理状态。这些都不容易做到。机器式的监督只会降低团队的凝聚力，但深入的了解也并不容易，这需要机遇，需要耐心，等等。</p><p>可能还是solo比较容易吧？</p><p>但把有着坚韧意志的厉害的女孩子一直置于对项目的焦虑与对自我的否定中，这实在不应该吧。</p><p>于是我只能随性地瞎指挥了。结果尚可，只是本来能更好。</p><hr><p>开始于2019-06-07</p><p>完稿于2019-06-16</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;切身体验，何谓人月神话。同时享受，心态雪崩的感觉……&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件工程" scheme="https://nessoffice.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【图灵之路】踏过的坑（2019-06-10更新）</title>
    <link href="https://nessoffice.github.io/2019/06/10/Other-Programming_Pits/"/>
    <id>https://nessoffice.github.io/2019/06/10/Other-Programming_Pits/</id>
    <published>2019-06-10T06:12:59.000Z</published>
    <updated>2019-06-10T15:47:31.172Z</updated>
    
    <content type="html"><![CDATA[<p>伤痕，与并不美好的记忆……</p><a id="more"></a><p>（不定期更新，一般心情好的时候会咕）</p><h1 id="2019-04-15"><a href="#2019-04-15" class="headerlink" title="2019-04-15"></a>2019-04-15</h1><p>Merge的函数题，没有保存变量就直接elem[i] = elem[j++]，导致数据丢失。从22：06：04到23：26：41，提交共十次。</p><h1 id="2019-04-16"><a href="#2019-04-16" class="headerlink" title="2019-04-16"></a>2019-04-16</h1><p>大数阶乘，压位做法。在j从0到len遍历的前提下把res[j] *= i和res[j+1] += res[j] / MOD混在一起写，这样的运算顺序是有误的。从1：36到1：52。</p><p>最近点对问题。将Points_x与Points_y混淆以致造成了难以发觉的错误。疯狂对拍但几无成效，在四个点的情况下还是直接调试更能发现问题。一开始在Merge中使用了n导致超时。从18：30到20：00再到22：00。</p><p>文件名的问题倒是一下就能发现。</p><h1 id="2019-04-17"><a href="#2019-04-17" class="headerlink" title="2019-04-17"></a>2019-04-17</h1><p>有序序列中位数问题，一直纠结于二分，没想到顺序一下就成。思路没打开。</p><h1 id="2019-05-06"><a href="#2019-05-06" class="headerlink" title="2019-05-06"></a>2019-05-06</h1><p>凸包旋转卡壳的算法中，用$&gt;$出现了问题，换成$\geq$则没事了。凸函数不一定严格单调啊。</p><p>调试时候把数组改小了记得做标记……不然看到RE很惭愧。</p><p>括号很多的时候记得检查，否则调试起来心情差。</p><h1 id="2019-05-10"><a href="#2019-05-10" class="headerlink" title="2019-05-10"></a>2019-05-10</h1><p>这一个标题下尽是，愚蠢的问题和糟心的状态……</p><p>5月8日期中考，旁边的人键盘敲得很响，想起了校赛时候的不适应，我的心境仿佛又回到了高中时代……偏执、疑虑、焦躁……今早的离散考试时状态亦复如是。</p><p>得冷静下来。这不仅是关于programming的问题了，它关系我的学习观，关系我对自己与他人的看法。Just admit it, scorn it, surplus it.</p><p>最后，“Cheers to the goddamn life, society, and everything.”</p><p>①他妈的”由裁判实现细节不表“！Sample都跑不起来的代码就交上去，这是计算机学院的学生做的事情吗？但不光是这一项，对dev的不熟悉，对于win7环境的不熟练还有内心世界的混乱都给解题的过程添了不少堵。一项一项的，都给我去死吧！</p><p>猪头临沂大学的漂亮代码是这样得：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span>  KeyType;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  KeyType *elem; <span class="comment">/*elem[0]一般作哨兵或缓冲区*/</span></span><br><span class="line">  <span class="keyword">int</span> Length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">CreatSqList</span><span class="params">(SqList *L)</span></span>;<span class="comment">/*待排序列建立，由裁判实现，细节不表*/</span></span><br></pre></td></tr></table></figure><p>那这个CreatSqList怎么实现呢？从Sample可以看出是要先读长度，然后一项一项读进来。因为参数是(SqList *L)，所以下面都要用-&gt;，直接L.Length就报错。但是实践之后发现只能读Length，读elem就会报错，为何？因为没有分配地址。所以这笔函数要这么写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">CreatSqList</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">L-&gt;elem = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span> *));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;L-&gt;Length);</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= L-&gt;Length;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;L-&gt;elem[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我一万年没有用malloc了，写这个函数的时候就慌得一批，之后想着要分配元素嘛，就写L-&gt;elem = 1000<em>(int </em>)…，但是这样是不行的。因为它elem啊，只是一个指针而已。</p><p>我不喜欢指针所以平时也不怎么用指针，自己写写代码基本不会有这方面的问题，但一到考试就凉透了！5月7日晚”复习“的指针完全没用。</p><p>这些几把考试不让查资料，所以把语法搞清楚很重要。血的教训！</p><p>②快排在5月7日晚上有“复习”，但是考试的时候还是一团乱麻。要理解快排，先要用例子建立直观的概念模型，从简单的例子到复杂的例子。简单的例子不包括重复项如“3 2 4 1 9 0 7”，还有不直观但容易调试的例子如“1 2”“2 1”等，乱七八糟的例子如“1 1 1”。理解之后是处理细节，考虑重复项他喵的该怎么搞，这样这样，基本就没问题了。</p><p>③有理数均值，特判！0/10这样的。要么在输出分母的时候加上去，要么把euclid写得更鲁棒一点，而不要少怀疑sscanf的有效性，虽然我之前的写法也很漂亮。</p><p>④整数分解，又是傻逼题一道……复习还是有一丁点用处的，因为当时也没有用心对待这题。本质就是个dfs，参数里设m——本次要分解的数，last——上次传下来的最大值，d——当前层数。对于;和\n搞个全局变量mark还有其函数专门处理。就这样，然后细节瞎搞。有的地方?:之类能让代码更简洁。</p><p>综上，关键词如下。<strong>高效复习</strong>、<strong>语法</strong>、<strong>模拟</strong>（从易到难、细节）、<strong>代码风格</strong>（优雅、鲁棒）、<strong>心态</strong>……</p><p>层层深入。</p><h1 id="2019-06-10"><a href="#2019-06-10" class="headerlink" title="2019-06-10"></a>2019-06-10</h1><p>今天补CF的状态……实在……一言难尽。题目是<a href="https://codeforces.com/contest/1176/problem/D" target="_blank" rel="noopener">这个</a>，看着很像密码题，它勾起了我关于ACTF的一些回忆……</p><p>一开始先是把题目看错了，不知怎地就把$p_{a_i}$理解成了$p_i$，导致处理$a_i$为质数和$a_i$为合数的方法产生了很大的分离，代码很冗长，而且写完后才发现有细节没想到，要处理非常麻烦。重新看题才发现是自己理解有误，只得把代码推倒重来。</p><p>之后是采用贪心的思路，分别用last_prime与last_composite维护$a_i$为质数/合数时$b_i$的index。但是在处理$a_i$为质数时，没有真正搞清楚变量的真实含义，以致屡出问题。在认识到所谓last_prime本质上是一个index后才对代码的正确性有了更深入的感受。</p><p>但这样还是碰到了一个很诡谲的error……本地测试没有问题，但是提交到服务器上便出错，此记录如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// origin</span></span><br><span class="line"><span class="keyword">while</span>(primes[nodes[last_prime].num] &gt; nodes[i].num)</span><br><span class="line">last_prime--;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polished</span></span><br><span class="line"><span class="keyword">while</span>(nodes[last_prime].num &gt;= <span class="number">200000</span>) <span class="comment">// caution</span></span><br><span class="line">last_prime--;</span><br><span class="line"><span class="keyword">while</span>(primes[nodes[last_prime].num] &gt; nodes[i].num)</span><br><span class="line">last_prime--;</span><br></pre></td></tr></table></figure><p>隐蔽的数组越界。以后在手工模拟是要尤为注意，越界与否，这样的问题。</p><p>在越界的问题上，还碰到了RE的问题。RE是因为题目中给定的n最大规模为2e5，但是输入的是2n，故而该规模需×2。在校赛时也碰到了类似的问题，还需要多加注意。</p><p>之后在跑一个点时出现错误。debug的思路为：判断output和answer中不一样的数，发现answer中一个位置为质数而output中对应的位置为合数。猜想nodes[last_composite].used = 0出现问题。调试发现last_composite对应的位置存在问题！last_prime确实可用贪心维护，但是last_composite并不能用贪心维护！于是手写了一个lower_bound，才得以通过此测试点。</p><p>然而这样还是碰到了TLE的问题。观察测试点发现它有相当多的重复数据。于是此时，lower_bound的复杂度会由二分退化为线性。需要添加记忆化的操作。至此，此题成功AC。</p><p>有何启示？明天再说……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;伤痕，与并不美好的记忆……&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="https://nessoffice.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【图灵之路】如何在CTF中考察算法能力——从ACTF中的rev和crypto谈起</title>
    <link href="https://nessoffice.github.io/2019/05/28/CTF-Algorithm/"/>
    <id>https://nessoffice.github.io/2019/05/28/CTF-Algorithm/</id>
    <published>2019-05-28T11:50:59.000Z</published>
    <updated>2019-05-30T02:43:05.784Z</updated>
    
    <content type="html"><![CDATA[<p>CTF，能和ICPC碰撞出什么样的火花呢？</p><a id="more"></a><h1 id="rev中的算法题"><a href="#rev中的算法题" class="headerlink" title="rev中的算法题"></a>rev中的算法题</h1><p><del>戳我获得题目链接</del></p><p>这次ACTF中，做到这么一个rev：</p><p><img src="/2019/05/28/CTF-Algorithm/question.jpg" alt></p><p>其中a1，a3都是已知的整数数组，a2是要求的整数数组。因为是字节的运算，涉及到的常数初看乱糟糟的，可能会把人看晕掉。我们把这段话用C语言（伪代码，有错请指出）重写一遍使之更清晰先：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> last;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> plain[], <span class="keyword">int</span> key[], <span class="keyword">int</span> cipher[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *ptr_plain = plain;</span><br><span class="line">    <span class="keyword">int</span> *ptr_cipher = cipher;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">37</span>;i++)<span class="comment">// 5476 / 148 = 37</span></span><br><span class="line">    &#123;</span><br><span class="line">        last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">37</span>;j++) <span class="comment">// 148 / 4 = 37</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = *(ptr_plain + j) * *(key + j);</span><br><span class="line">            <span class="keyword">int</span> ans = last + temp % <span class="number">79</span>;</span><br><span class="line">            ans %= <span class="number">79</span>;</span><br><span class="line">            last = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        *ptr_cipher = ans;</span><br><span class="line">        ++ptr_cipher;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这看着并不好搞，直接暴力搜索的复杂度显然不合理，逆推也不好推。想了好久，才想到要是把最后得到的ans的计算方式写出来，能得到一个线性同余方程。37个方程，37个未知数，这不便可以用高斯消元法解决么！于是，我想起了自己从没有写过高斯消元法的板子……</p><p>这道题本身并不难，但我们是否能从其身上得到进一步的启示呢？比如，如何从众多CTFer中筛选出ICPCer？</p><p>这好像是个<del>鬼畜</del>有趣的值得探讨的话题……</p><h1 id="模式异同"><a href="#模式异同" class="headerlink" title="模式异同"></a>模式异同</h1><p>在把这两个竞赛联系起来之前，我们有必要看一看它们间的模式。</p><p>ICPC：根据题目描述，设计出<strong>高效</strong>的算法，通过input计算得output。</p><p>CTF：根据题目的描述，通过<strong>可行</strong>的方法，获得flag。</p><p>在效率上，ICPC较为严格，留给程序的时间多以秒或毫秒为单位。考虑到数据的量级，一般而言O($n^3$)以上的算法都通不过。而CTF对于效率要求较低，更关注正确性。所以一般多项式级别的算法都可以。虽然CTF对效率没有过高的要求，但它也不会纵容无脑的暴力搜索。许多RSA的题目就是很好的例子。</p><p>无脑的暴力搜索的一种方案便是枚举答案，看它是否能够算出flag。在实际的情况中，flag中的各位间应当缺乏联系（迭代的关系也可以，还有什么关系呢？）。这样暴力枚举的复杂度便是组和量级的。故而参赛者只得找出加密/检验算法中的vulnerability，以快速而优雅地解出flag。</p><p>多数CTF题是没有input的，除了crypto（好吧，misc里给的图片算是input吗？）。为了向ICPC看起（虽然也有少量ICPC题目中无输入，这里头很多毒瘤题），我们一般可以在crypto题中加入算法的要素。也不只是crypto，rev、ppc都可以。从这个角度看，这三类题还是共性大于个性的。</p><p>于是，通过设置解密的模式，给参赛者cipher，（文章开头提到的那道rev的模式也是类似的：please enter the flag，然后检测输入的flag是否能通过检测），我们可以检验与赛者的代码阅读理解能力，对算法的理解能力，还有各方面杂七杂八的能力。</p><p>不过，也有另一种思路。</p><h1 id="关注复杂度"><a href="#关注复杂度" class="headerlink" title="关注复杂度"></a>关注复杂度</h1><p>说到复杂度，这次ACTF里还有另外一道rev，说是只要耐心等程序跑完就能拿到flag。用IDA一看，是个递归方程，没有记忆化，复杂度妥妥的O($k^n$)，等它跑完宇宙都凉了（好吧，是热寂，热得凉了）。怎么破呢？很简单，加个记忆化自己跑一遍就完了。</p><p>这个题目能够给我们一些复杂度上的启示：提示与赛者优化算法的复杂度。但是这个方向，私以为比较狭窄。把O($k^n$)和O($n!$)一类优化到多项式级别固然是一种思路，但是复杂度这样大得可怕的算法也不多，尤其是较为有名的。如要控制O($nlogn$)能通过而O($n^2$)不能通过，这也不好操作（除非是和服务器交互然后超时了它不给你flag，不过这样不就<strong>变成</strong>ICPC模式了吗……）。比如，我想这么出题：给定平面上n个点，求两个点间的最大距离。这个数取整再转为16进制再转为字符，就得到了flag。然后，控制n的规模，使得了解凸包的选手能在稍短的时间内跑完得到flag，而只会暴力的选手则在比赛时间内都跑不完。</p><p>理论上这个思路确实可行，但实操起来……假设一场比赛赛程十天，那么十天都跑不完的O($n^2$)中的n要多大？还能不能跑起来？如果能跑起来，还有没有其他的思路？比如用划分一下数据范围多台机子一起跑等等……总之这个方向看上去不是很漂亮，也不能很好地检验算法能力。而要真正检验算法能力，还是O($n^4$)，O($n^5$)更加适合，可问题在于我们也少有接触过这个复杂度量级的算法……</p><p>（以上是关于时间复杂度的，关于空间复杂度还莫得思考）</p><h1 id="解密模式"><a href="#解密模式" class="headerlink" title="解密模式"></a>解密模式</h1><p>上面讲到了解密的模式，我们再来更深入地看一看。</p><p>首先是阅读理解代码，阅读crypto中给出的代码，或是IDA反编译出的伪代码。这些代码的码风和我们自己写的不尽一致，故而阅读理解并不总是很轻松。阅读时，当在草稿上画出函数间的流程图，标记出重要的，还未完全理解的语句。将代码转化为等价的更容易为自己接受的形式。再来是保持清晰的头脑。这样就差不多了，能够对这段代码做了什么，效率如何，产生初步的理解。</p><p>然后是关注关键点了，比如以上的例子中，ida里头那一段代码。它反映了什么知识点？这是很难从代码反推出来的，除非我们已对这一知识点有了一定的认识。我们能做的，只是将代码转化为尽可能多的，等价的形式，从各个角度看能否解出更多的信息。这对于与赛者而言，无疑是充满挑战的。</p><p>而站在命题人的角度，我们能怎么调戏参赛者呢？</p><p>自行设计加密/检验算法想想也很伤脑筋，还是结合已有的算法更能体现CTF的精神。结合已有的算法的时候，不能像ICPC那样关注剪枝啊，数据结构之类，往模板题或是毒瘤题的方向靠拢或许更好。</p><p>比如，这次ACTF就考察了以下方向（这里只列了我会做的555）。<del>戳我获得题目链接。</del></p><p>1.异或的性质，利用它来构造密钥</p><p>2.LFRS（线性迭代加密）的vulnerability</p><p>3.块加密中，每块的加密方式为映射的迭代</p><p>4.其逆映射不是函数（每个象均只有一个原象）的映射</p><p>5.线性同余方程组</p><p>（如果看不了题，可以想想从这些方向出发，能怎么调戏参赛者）</p><p>除了这些方向，我们还可以在CTF中考察什么样的算法呢？</p><p>线性基（类似上面线性同余方程组的检验方法）？尼姆博弈（逐位检验）？欧拉函数？……</p><p>以上的方向还没有归类，或许需要进一步的探讨。</p><hr><p>开始于2019-05-28</p><p>完稿于2019-05-30</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CTF，能和ICPC碰撞出什么样的火花呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="https://nessoffice.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="信息安全" scheme="https://nessoffice.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>
