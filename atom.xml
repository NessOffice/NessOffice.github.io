<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ness</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nessoffice.github.io/"/>
  <updated>2019-05-01T11:07:05.493Z</updated>
  <id>https://nessoffice.github.io/</id>
  
  <author>
    <name>Ness</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【数学之美】离散数学及其应用：第八章 计数进阶</title>
    <link href="https://nessoffice.github.io/2019/05/01/Discrete_Mathematics-CH08/"/>
    <id>https://nessoffice.github.io/2019/05/01/Discrete_Mathematics-CH08/</id>
    <published>2019-05-01T06:19:58.000Z</published>
    <updated>2019-05-01T11:07:05.493Z</updated>
    
    <content type="html"><![CDATA[<p>虽然这章名为“计数进阶”，但其内容和“计数”关系似乎不是很大。除了生成函数是标准的“计数”内容，“递推”“分治”看起来和“计数”都没啥关系。另外容斥定理讲得也比较浅。</p><a id="more"></a><h1 id="递推关系"><a href="#递推关系" class="headerlink" title="递推关系"></a>递推关系</h1><h2 id="递推关系模型-需补充"><a href="#递推关系模型-需补充" class="headerlink" title="递推关系模型[需补充]"></a>递推关系模型[需补充]</h2><p>从兔子数列到牛数列</p><p>汉诺塔</p><p>满足特定条件的01串（如，不包括连续两个0的01串）</p><p>（卡塔兰数的一种情形）n个数相乘的顺序总数</p><h2 id="递推算法-需补充"><a href="#递推算法-需补充" class="headerlink" title="递推算法[需补充]"></a>递推算法[需补充]</h2><p>讲座问题</p><p>动态规划</p><h1 id="线性递推"><a href="#线性递推" class="headerlink" title="线性递推"></a>线性递推</h1><h2 id="齐次"><a href="#齐次" class="headerlink" title="齐次"></a>齐次</h2><p>所谓线性齐次常系数递推关系（linear homogeneous recurrence relations with constant coefficients），指的是形如$a_n = c_1 a_{n-1} + c_2 a_{n-2} + … c_k a_{n-k}$的递推关系。</p><p>提到“线性齐次常系数递推关系”我们就会提特征方程与特征根，它们是用以解递推式的利器。</p><p>特征根是个非常有效但也让人摸不着头脑的东西。它本身有何意义？下面笔者粗浅地谈谈自己对其的认识。</p><h3 id="二阶递推式-需完善"><a href="#二阶递推式-需完善" class="headerlink" title="二阶递推式[需完善]"></a>二阶递推式[需完善]</h3><p>如果递推式形如$a_n = Aa_{n-1} + Ba_{n-2}$，$a_n$该如何解呢？我们考虑能否用特殊的$a_n$凑出答案，比如，$a_n = x^n$，这样？把它代入原递推式，我们得到一个二次方程$x^2 - Ax - B = 0$，如果它有不同的解$x_1, x_2$，诶，好，$a_n = x_1^n$或者$a_n = x_2^n$看上去都可以。</p><p>但是啊，$a_n = Aa_{n-1} + Ba_{n-2}$是由$a_1, a_2$完全确定的。如果$a_1 \not = x_1$，那不就出问题了吗？其实，前面说$a_n = x_1^n$“可以”，那么$a_n = Cx_1^n + Dx_2^n$也是“可以”的。这样便能够通过给定的$a_1, a_2$解一解C、D，$a_n$的通解也就出来了。</p><p>因为$x^2 - Ax - B = 0$和$a_n$有着密切的联系，我们称前者为“特征方程”。</p><p>以上是特征方程有两个相异根的情形，如果相同则如何呢？不一定存在$C$使得$a_1 = Cx_1$且$a_2 = Cx_1^2$啊！在这个条件下，我们令$a_n = Cx_1^n + Dnx_1^n$。可以证明，这样的$a_n$满足条件//为什么想到要这样做？</p><h3 id="n阶递推式"><a href="#n阶递推式" class="headerlink" title="n阶递推式"></a>n阶递推式</h3><p>与上面类似的，我们能想到无重根的n阶递推式的通解形如$a_n = \sum\limits_{i = 1}^k \alpha_i r_i^n$，其中$r_i$为特征方程的解。</p><p>至于有重根的n阶递推式，它则形如$a_n = \sum\limits_{i = 1}^k(\sum\limits_{j = 0}^{m_i} \alpha_{(i, j)} n^j r_i^n)$，其中$r_i$为特征方程的解，$m_i$为重数。</p><p>证明呢？不管了(¬､¬)</p><p>有重根的n阶递推式</p><h2 id="非齐次-需完善"><a href="#非齐次-需完善" class="headerlink" title="非齐次[需完善]"></a>非齐次[需完善]</h2><p>所谓线性非齐次常系数递推关系（linear nonhomogeneous recurrence relations with constant coefficients），指的是形如$a_n = c_1 a_{n-1} + c_2 a_{n-2} + … c_k a_{n-k} + F(n)$的递推关系。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>找特解，而后化归到齐次。（这些方程都这种套路，得归纳一下）</p><p>特解怎么找呢？比如$a_n = 3a_{n-1} + 2n$，我们可以从结构上猜出$a_n = Cn$。而对于$a_n = 5a_{n-1} - 6a_{n-2} + 7^n$，我们也可以猜一个$a_n = C \cdot 7^n$。但是如果是$a_n = 5a_{n-1} - 6a_{n-2} + 3^n$，$a_n = C \cdot 3^n$就不管用了，要$a_n = C \cdot n^2 \cdot 3^n$才行（为什么又是这个形式？我不知道）。</p><p>一般的，有下面的定理。</p><h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p>若$a_n = c_1 a_{n-1} + c_2 a_{n-2} + … c_k a_{n-k} + F(n)$，$F(n)$形如$(b_t n^t + b_{t-1} n^{t-1} + … + b_1 n + b_0) s^n$，其中b、s均为常数。递推关系的特征方程$x^n - c_1 x^{n-1} - c_2 x^{n-2} - … c_k x^{n-k} = 0$的解中s的重数为m，则特解的形式形如$a_n = n^m (p_t n^t + p_{t-1} n^{t-1} + … + p_1 n + p_0) s^n$。</p><p><del>我不会，就不证了</del>例子：$a_n = 6a_{n-1} - 9a_{n-2} + F(n)$，当$F(n)$分别取$F(n) = 3^n, F(n) = n 3^n, F(n) = n^2 2^n, F(n) = (n^2 + 1) 3^n$，求$a_n$的通解。</p><p>应用：如求$a_n = \sum n^k$。</p><h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><p>研究分治算法时，一个值得关注的对象是时间复杂度。下面举几个大家耳熟能详的例子。</p><p>例子：矩阵乘法、二进制乘法（汇编乘法？）、二分查找、归并排序</p><p>上面的例子看似相似，但其算法复杂度可以很不一样！最后的公式会依据递推关系中的常数专门进行分类讨论，而且结论虽然能推，但是并不好记。//如何认识这一结论？</p><p>关于复杂度的推导，我们可以先简化问题，因为只要得到$f(n) = O(g(n))$就好了，可以对n进行“适当”的放大。这里，我们考虑$n = b^k$。</p><h2 id="f-n-的复杂度估计-需完善"><a href="#f-n-的复杂度估计-需完善" class="headerlink" title="f(n)的复杂度估计[需完善]"></a>f(n)的复杂度估计[需完善]</h2><h3 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h3><p>对于形如$f(n) = af(n/b) + c$的递推式，有</p><p>………………..$a = 1 \Rightarrow f(n) = O(log n)$</p><p>………………..$a &gt; 1 \Rightarrow f(n) = O(n^{log_b a})$</p><p>………………..$a &lt; 1 \Rightarrow f(n) = O(1)$</p><p>第一项很好理解，第二项是怎么得到的呢？其实直接得到的是$f(n) = O(a^k)$，而通过换底公式能得到$a^k = n^{log_b a}$，因为我们喜欢把n放到真数的位置。下面也是要用到这个转换的。</p><h3 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h3><p>对于形如$f(n) = af(n/b) + cn^d$的递推式，有</p><p>………………..$a = b^d \Rightarrow f(n) = O(n^d log n)$</p><p>………………..$a &lt; b^d \Rightarrow f(n) = O(n^d)$</p><p>………………..$a &gt; b^d \Rightarrow f(n) = O(n^{log_b a})$</p><h2 id="典例：最近点对问题-需完善"><a href="#典例：最近点对问题-需完善" class="headerlink" title="典例：最近点对问题[需完善]"></a>典例：最近点对问题[需完善]</h2><p>计算几何的一个<del>毒瘤</del>经典例题，初看非常的抽象，下面我试着以直观的方式说明一下如何用分治法解决这个问题。</p><p>首先分治呢，要先“分”，而后“治”。“分”的话二分比较常见，但二分要在有序集里才好进行。考虑以x坐标对这些点进行排序，然后取中间的点作为分界就好了。</p><p>下面的思路有些跳跃，我们从最后的算法出发来反推，这样可能更容易理解些。</p><p>分治法大框架的伪代码如下，一些细节先不必理解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">closest</span><span class="params">(Point p[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(high - low == <span class="number">1</span> <span class="keyword">or</span> <span class="number">2</span>)...</span><br><span class="line">    <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> d1 = closest(p, low, mid);</span><br><span class="line">    <span class="keyword">double</span> d2 = closest(p, mid + <span class="number">1</span>, high);</span><br><span class="line">    <span class="keyword">double</span> d = min(d1, d2);</span><br><span class="line">    d = merge(...);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面框架的细节主要是这个：d = min(d1, d2)。为什么要先算d呢？</p><p>这实质上是用于提高效率的。你想，“分”做好了，就是左右两边的最近点对距离都已经分别算出来了，“治”要怎么做呢？枚举左边的点和右边的点的距离么？这样还是$O(n^2)$，算法的复杂度还是没有降低呀！于是我们得限制枚举的点的数量。聪明的Preparata和Shamos发现，如果先算出d1、d2和d，那么用要枚举点的话，只要在下图中两条红线间的区域间（x坐标距mid为d的区域内）枚举即可。</p><p><img src="/2019/05/01/Discrete_Mathematics-CH08/closest_distance1.png" alt></p><p>就是说，这里用到了剪枝：把一些分居左右而距离必定超过d的点对剪掉。这个剪枝还是比较宽的，但它容易想到呀，如果要更深入地剪就要深入探究点的结构了，太复杂啦！我们不考虑。</p><p><img src="/2019/05/01/Discrete_Mathematics-CH08/closest_distance2.png" alt></p><p>可是，看这张图，即便上面有剪枝，枚举量还是太大了呀，如何缩减呢？我们遇到的问题是这些剩下的点还是无序的，只得暴力枚举，而没有有效的降低枚举量的技巧。于是，聪明的Preparata和Shamos又把剩下的点有序化了，并利用“两点间距离不能大于d”继续剪枝。请看伪代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">merge</span><span class="params">(Point p[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high, <span class="keyword">double</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;<span class="comment">// the size of the array "temp"</span></span><br><span class="line">    Point temp[];<span class="comment">// the points between the red lines</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//branch-cutting 1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = low;i &lt;= high;i++)</span><br><span class="line">        <span class="keyword">if</span>(p[i].x &gt;= p[mid].x - d)</span><br><span class="line">        <span class="keyword">if</span>(p[i].x &lt;= p[mid].x + d)</span><br><span class="line">        temp[len++] = p[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// the merge part</span></span><br><span class="line">    sort(temp, temp + len, cmp_y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;i + j &lt; len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp[i+j].y - temp[i].y &gt; d) <span class="keyword">break</span>;<span class="comment">// branch-cutting 2</span></span><br><span class="line">            d = min(d, dist(temp[i], temp[i+j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面“branch-cutting 2”这一行，它很容易理解，但是否足够有效呢？是否存在某组数据使得“the merge part”的运算量退化到$n^2$呢？幸运的是，它足够有效！而且运算量至多是7n！请看下面的图示。</p><p><img src="/2019/05/01/Discrete_Mathematics-CH08/closest_distance3.png" alt></p><p>假设我们正枚举到$P1$。Preparata和Shamos证明了，至多有7个$P2$满足$P2.y - P1.y \leq d$。因为前面在左右两边已经”分“过了，故有closest(left), closest(right) &gt;= d，即在“一边”的点两两距离大于d。这个结论非常有用！因为前面已经构造出了以2d为边长的长方形作为我们选点的区域，我们再在这个长方形里画小的正方形，再把P1放进去。能够发现，在图中所示的八个虚线区域中，每个区域至多一个点（否则矛盾）。故而“branch-cutting 2”在至多7步后就会退出，这个剪枝足够有效！</p><p>上面的分析还是比较粗略的，因为实际运算时似乎用不着7步，我们能否证明对每个点至多只要4次或5次比较呢？不论如何，总之都是较小的常数就是了。</p><p>接着来分析一下算法复杂度吧。开始的按x排序：O(nlogn)，之后的递推：f(n) = 2f(n/2) + nlogn + 7n（nlogn是按y排序）。解上面的递推式，得f(n) = O(nlogn)//为何网上有说法是nloglogn？</p><p>以反推的方式理解了一下这个算法，我们再来正面地总结一下我们的步骤：</p><p>①准备，按x排序原数组，使之有序；</p><p>②“分”，以中点为界，得到两子域中的最短点距；</p><p>③“治”，依据②中的最短点距d找出需要枚举的点，这里进行了第一次剪枝；</p><p>④“治”，将③中得到的点按y排序，顺序枚举，并通过y的距离进行第二次剪枝；</p><p>以上。</p><p>总而言之，这个算法的步骤还是容易实现的，难的是深入地理解它。这里两个剪枝分开来看都可能是效率不高的，但合在一起就产生了奇妙的相互作用，保证了总体剪枝的有效性。这十分精妙，但也很难想到，而且不好推广。</p><p>另外书上的算法是设了两个数组，分别对x排序与对y排序，之后在后者这一数组中检索，但这样细节是如何处理的呢？我还不知道。</p><p>算法的完整代码见下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span><span class="keyword">double</span> x, y;&#125;Points[maxn], temp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_x</span><span class="params">(Point &amp;lhs, Point &amp;rhs)</span></span>&#123;<span class="keyword">return</span> lhs.x &lt; rhs.x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_y</span><span class="params">(Point &amp;lhs, Point &amp;rhs)</span></span>&#123;<span class="keyword">return</span> lhs.y &lt; rhs.y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(Point &amp;lhs, Point &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>((lhs.x - rhs.x)*(lhs.x - rhs.x) + (lhs.y - rhs.y)*(lhs.y - rhs.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high, <span class="keyword">double</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> mid_x = Points[mid].x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = low;i &lt;= high;i++)</span><br><span class="line"><span class="keyword">if</span>(Points[i].x &gt;= mid_x - d)</span><br><span class="line"><span class="keyword">if</span>(Points[i].x &lt;= mid_x + d)</span><br><span class="line">temp[len++] = Points[i];</span><br><span class="line">sort(temp, temp + len, cmp_y);<span class="comment">//in the book, it's not necessary to sort. Why?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;i + j &lt; len &amp;&amp; (temp[i+j].y - temp[i].y &lt;= d);j++)</span><br><span class="line">d = min(d, dist(temp[i], temp[i+j]));</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">closest</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(high == low) <span class="keyword">return</span> INF;</span><br><span class="line"><span class="keyword">if</span>(high - low == <span class="number">1</span>) <span class="keyword">return</span> dist(Points[low], Points[low+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">double</span> d1 = closest(low, mid);</span><br><span class="line"><span class="keyword">double</span> d2 = closest(mid + <span class="number">1</span>, high);</span><br><span class="line"><span class="keyword">double</span> d = min(d1, d2);</span><br><span class="line"><span class="keyword">return</span> merge(low, mid, high, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...<span class="comment">//scanf</span></span><br><span class="line">sort(Points, Points + n, cmp_x);</span><br><span class="line">...<span class="comment">//printf</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>①分治算法在不同递推式下算法复杂度可能不同，需特殊情况特殊分析。</p><p>②分治算法的精髓在于“分而后治”，“分”是“治”的基础，通过“分”得到的有效信息能够帮助我们降低“治”部分的复杂度。在归并排序中，“分”得到的有效信息是子序列的有序性；在最近点对问题中，“分”得到的有效信息是子区域的最近点对距离。</p><p>③分治算法本身不难理解，但比较难想到，也比较灵活。分析分治算法时“为何这种问题可以用分治处理”。</p><h1 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h1><p>何谓生成函数？这是个比较玄妙的问题，它的定义很简单，但为何要这样定义，及它为何能用来解决组合问题，则常常会给人带来迷惑，下面笔者以个人的理解粗略地讲讲生成函数。</p><h2 id="生成函数的概念"><a href="#生成函数的概念" class="headerlink" title="生成函数的概念"></a>生成函数的概念</h2><p>先来看这样一个例子：$x_1 + x_2 + x_3 = 7$，其中$0 \leq x_1 \leq 2, 2 \leq x_2 \leq 3, 3 \leq x_4 \leq 4$，$x_1, x_2, x_3$为整数。求$(x_1, x_2, x_3)$有多少种可能。</p><p>我们固然可以通过解答树得到答案，但是否有其他更“代数”的做法呢？考虑这个式子：$(1 + x + x^2) \cdot (x^2 + x^3) \cdot (x^3 + x^4)$。它意味着什么？我们把第一个括号中x的指数看作$x_1$的取值，第二三个括号同理。从一二三个括号中各选一项乘起来，恰好对应$x_1 + x_2 + x_3 = k$的一种方法。故$(1 + x + x^2) \cdot (x^2 + x^3) \cdot (x^3 + x^4)$展开式中$x^k$的系数，即$x_1 + x_2 + x_3 = k$的方法数（而指数所对应的便是$x_1 + x_2 + x_3$的取值）。特别的，取k = 7，就得到了上面问题的答案。</p><p>这个方法看上去和暴力枚举并无二致，但事实并非如此。首先，生成函数将组合问题与代数问题连接起来，从而使得组和问题更易表示，而能为计算机所处理（多项式乘法）。其次，这样的算法在运算时更为容易，因为我们更熟练于多项式的乘法而不是列出解答树。</p><p>为何上述做法能建立从组和到代数的一一映射呢？原因在于乘法法则与加法法则——$ax^c + bx^c = (a+b)x^c$，这对应于加法法则；$ax^c \cdot bx^d = ab x^{c+d}$，这对应于乘法法则。如果认为这有些抽象，不妨在上面的例子中找找哪里用到了这两个法则。生成函数之所以能够解决组合问题，原因就在于多项式的运算能有这样和组和相关的性质。</p><p>上面的生成函数$G(x) = (1 + x + x^2) \cdot (x^2 + x^3) \cdot (x^3 + x^4)$是有限项的，容易理解。但是实际运用中我们一般会考虑无穷项的情况，即将$G(x)$写作无穷级数的形式。然后玄学东西又来了：比如$G(x) = \sum\limits_{i = 0}^{\infty} x^i = \dfrac{1}{1-x}$。为什么可以这样做？这样做有什么好处？这些我们将在下文中，结合具体的案例进行探讨，此时先不要被它迷糊了头脑。</p><h2 id="用生成函数证明组和恒等式-需完善"><a href="#用生成函数证明组和恒等式-需完善" class="headerlink" title="用生成函数证明组和恒等式[需完善]"></a>用生成函数证明组和恒等式[需完善]</h2><p>使用生成函数时，我们需要考虑“意义”。这不是指x的意义——x毫无意义，我们引入x只是要利用多项式的运算，因为它是好的。此处的意义指的是我们运算式子中的意义。拿上面的例子来说，$((1 + x + x^2)), (x^2 + x^3)$分别都有意义，它们相乘也是有意义的。谈到”意义“，你可能想到了第六章玄学的”组合证明“。而生成函数与组合证明，它们恰能够结合在一起。</p><p>//二项式定理？</p><p>比如Yanghui恒等式，可以这么证：$(1+ x)^n = (1 + x)^{n-1} + x (1 + x)^{n-1}$，关注左右式中$x^k$的系数即可。</p><p>又比如Vandermonde恒等式，关键的式子是$(1 + x)^{m + n} = (1 + x)^n (1 + x)^m$。</p><p>不难发现，使用生成函数的思路和组合证明的思路是完全一致的。但这个形式看起来就”正经“的多。</p><h2 id="用生成函数解决组和问题"><a href="#用生成函数解决组和问题" class="headerlink" title="用生成函数解决组和问题"></a>用生成函数解决组和问题</h2><h3 id="生成函数的建模"><a href="#生成函数的建模" class="headerlink" title="生成函数的建模"></a>生成函数的建模</h3><p><strong>例1</strong></p><p>$x_1 + x_2 + x_3 = 7$，其中$0 \leq x_1 \leq 2, 2 \leq x_2 \leq 3, 3 \leq x_4 \leq 4$，$x_1, x_2, x_3$为整数。求$(x_1, x_2, x_3)$有多少种可能。</p><p><strong>例2</strong></p><p>八本书，分给三个小孩，每人得到的书不少于两本不多于四本，求总方法数。</p><p><strong>例3</strong></p><p>手上有一元、两元、五元的钞票若干元，求能用多少种方式表示五十元。</p><h3 id="再谈可重复元素的组和"><a href="#再谈可重复元素的组和" class="headerlink" title="再谈可重复元素的组和"></a><strong>再谈可重复元素的组和</strong></h3><p>在讲这个例子前，先要提一提广义二项式定理。</p><p><strong>广义二项式系数</strong>：$C_u^m = \dfrac{u \cdot (u-1) \cdot … \cdot (u - m + 1)} {1 \cdot 2 \cdot … \cdot m}$，其中m为非负整数，u为任意实数。</p><p>特别的，当u为负整数的时候，我们有$C_{-n}^m = (-1)^m C_{n + m - 1}^m$。</p><p><strong>广义二项式定理</strong>：$(1 + x)^u = \sum\limits_{i = 0}^{\infty} C_u^i x^i$。（证明的话，幂级数展开就好）</p><p><strong>例4</strong></p><p>有n种硬币，每种有无穷多个，问取r个硬币有多少种方法。</p><p>第一种硬币可以取0个、1个、2个、……，这样考虑的话，生成函数便是$G(x) = (1 + x + …)^n$。</p><p>但无穷级数相乘很难算。我们为了能够算出结果，假定级数收敛，那么$(1 + x + …) = \dfrac{1} {1 - x}$。则$G(x) = \dfrac{1} {(1 - x)^n}$。</p><p>于是可以使用上面的广义二项式定理了，得$x^r$的系数是$C_{n + r - 1}^r$。</p><p>回过来再考虑生成函数的问题，它为何要是无穷级数？为了方便表示”可重复元素“。</p><p>为何能假定上面的式子收敛？<del>我也不知道，好用就行了</del></p><h2 id="用生成函数解决递推问题-需完善"><a href="#用生成函数解决递推问题-需完善" class="headerlink" title="用生成函数解决递推问题[需完善]"></a>用生成函数解决递推问题[需完善]</h2><p>考虑斐波那契数列的生成函数：$G(x) = \sum\limits_{i = 0}^{\infty} f_i x^i$，$G(x) = x + \sum\limits_{i = 2}^{\infty} f_i x^i = x + \sum\limits_{i = 2}^{\infty} (f_{i-1} + f_{i-2}) x^i = x + x\sum\limits_{i = 0}^{\infty} f_i x^i + x^2 \sum\limits_{i = 0}^{\infty} f_i x^i = x + xG(x) + x^2 G(x)$，则$G(x) = \dfrac{x} {1 - x - x^2}$，因式分解再裂项，就得到我们常见的结果了。</p><p>为什么生成函数这么奇妙？因为它巧妙地将递推关系用来消项。//<del>然后我也讲不出什么道道了</del></p><h1 id="容斥原理-需补充"><a href="#容斥原理-需补充" class="headerlink" title="容斥原理[需补充]"></a>容斥原理[需补充]</h1><p>内容</p><p>素数个数（关注计算复杂度）</p><p>满射的个数</p><h2 id="错排问题"><a href="#错排问题" class="headerlink" title="错排问题"></a>错排问题</h2><p>后面的部分<a href="https://www.cnblogs.com/c1299401227/p/5349727.html" target="_blank" rel="noopener">引自网络</a>，略有删改。（不知是否这位老哥原创的）</p><p>$\forall i, f(i) \not = i, i, f(i) \in \{ 1, 2, …, n \};\forall i \not = j, f(i) \not = f(j)$，求符合要求的函数个数D(n)。</p><p>核心递推公式：</p><p>$D(n) = (n-1) [D(n-2) + D(n-1)]$</p><p>初始值：$D(1) = 0, D(2) = 1$。</p><h3 id="递推的推导错排公式"><a href="#递推的推导错排公式" class="headerlink" title="递推的推导错排公式"></a>递推的推导错排公式</h3><p>分析i = 1，它有n-1个取值。不失一般性，设$f(1) = 2$。再分析i = 2，若$f(2) = 1$，剩下的个数就是$D(n-2)$。</p><p>下面的一步就好玩了：如果$f(2) \not = 1$，那么剩下的个数是多少呢？注意！$f(2) \not = 1, f(3) \not = 3, …, f(n) \not = n$，这难道不是新的错排，个数是$D(n-1)$？于是，上面的递推式就得到啦！</p><p>下面咱们来推公式。</p><p>根据套路，设$D(n) = n! N(n)$，然后推一推，得//怎么想到要这么做的？</p><p>$nN(n) = (n-1) N(n-1) + N(n-2)$​，然后有</p><p>$N(n-1) - N(n-2) = (-1)^{n-1} / (n-1)!$，相加得</p><p>$N(n) = (-1)^2/2! + … + (-1)^{n-1} / (n-1)! + (-1)^n/n!$</p><p>故</p><p>$D(n) = n! [(-1)^2/2! + … + (-1)^{n-1}/(n-1)! + (-1)^n/n!]$</p><p>此即错排公式。</p><h3 id="用容斥原理的推导"><a href="#用容斥原理的推导" class="headerlink" title="用容斥原理的推导"></a>用容斥原理的推导</h3><p>用容斥原理也可以推出错排公式:</p><p>正整数1, 2, 3, ……, n的全排列有 n! 种，其中第k位是k的排列有 (n-1)! 种;当k分别取1, 2, 3, ……, n时，共有n*(n-1)!种排列是至少放对了一个的，由于所求的是错排的种数，所以应当减去这些排列;但是此时把同时有两个数不错排的排列多排除了一次，应补上;在补上时，把同时有三个数不错排的排列多补上了一次，应排除……重复该一过程，得到错排的排列种数为</p><p>$D(n) = n! - n!/1! + n!/2! - n!/3! + … + (-1)^n<em>n!/n! = ∑(k=2~n) (-1)^k </em> n! / k!$，</p><p>即$D(n) = n! [1/0! - 1/1! + 1/2! - 1/3! + 1/4! + … + (-1)^n/n!]$.</p><h3 id="简化公式"><a href="#简化公式" class="headerlink" title="简化公式"></a>简化公式</h3><p>错排的公式里有n项，计算复杂度是O(n)，有没有简便的近似值呢，像Stirling公式一般？有的，而且不仅仅是近似值：$D(n) = \lfloor n!/e+0.5 \rfloor$。（但是这个公式有何意义呢？计算n!不还得O(n)？）</p><p>以下是证明：</p><p>对$1/e$幂级数展开一波，得$1/e = e^{-1} = 1/0! - 1/1! + 1/2! - 1/3! - ….. + (-1)^n/n! + R_n(-1)$//看不懂</p><p>其中$R_n(-1)$，$R_n(-1) = (-1)^{n+1} \cdot e^u / (n+1), u∈(-1, 0)$</p><p>所以，$D(n) = n! \cdot e^{-1} - (-1)^{n+1} \cdot e^u / (n+1), u∈(-1, 0)$</p><p>而$|n! R_n| = |(-1)^{n+1} \cdot \dfrac{e^u} {n+1}| = \dfrac{e^u} {n+1} ∈ (\dfrac{1} {[e(n+1)]}, \dfrac{1}{n+1})$，可知即使在n=1时，该余项(的绝对值)也小于1/2。</p><h1 id="术语-需审核"><a href="#术语-需审核" class="headerlink" title="术语[需审核]"></a>术语[需审核]</h1><p>递推关系：recurrence relations</p><p>初始条件：initial conditions</p><p>线性常系数(非)齐次递推关系：linear (non)homogeneous recurrence relations with constant coefficients</p><p>关联的齐次递推关系：associated homogeneous recurrence relations（把F(n)去掉得到的递推关系）</p><p>特征方程/特征根：characteristic equation/roots</p><p>分治算法：divide-and-conquer algorithms</p><p>分治算法的递推关系：divide-and-conquer recurrence relation</p><p>最近点对问题：closest-pair problem</p><p>埃氏筛：sieve of Eratosthenes</p><p>错排：derangement</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然这章名为“计数进阶”，但其内容和“计数”关系似乎不是很大。除了生成函数是标准的“计数”内容，“递推”“分治”看起来和“计数”都没啥关系。另外容斥定理讲得也比较浅。&lt;/p&gt;
    
    </summary>
    
    
      <category term="课程笔记" scheme="https://nessoffice.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数学_组和" scheme="https://nessoffice.github.io/tags/%E6%95%B0%E5%AD%A6-%E7%BB%84%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>【数学之美】微积分下-苏德矿版：第十一章 级数</title>
    <link href="https://nessoffice.github.io/2019/04/27/Calculus_Vol2-CH11/"/>
    <id>https://nessoffice.github.io/2019/04/27/Calculus_Vol2-CH11/</id>
    <published>2019-04-27T13:22:58.000Z</published>
    <updated>2019-05-01T10:47:52.655Z</updated>
    
    <content type="html"><![CDATA[<p>级数，是用于<strong>表达函数</strong>的<strong>数值计算</strong>的工具。（<del>我口胡的</del>）</p><p>我们要学的级数与数列息息相关，可以说是后者的加强版本。两者从敛散性开始便有了亲密的联系。</p><a id="more"></a><h1 id="级数的概念"><a href="#级数的概念" class="headerlink" title="级数的概念"></a>级数的概念</h1><p>级数，是用于<strong>表达函数</strong>的<strong>数值计算</strong>的工具。（<del>我口胡的</del>）</p><p>我们要学的级数与数列息息相关，可以说是后者的加强版本。两者从敛散性开始便有了亲密的联系。</p><h2 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h2><p>1.n阶Koch雪花的边长与面积。</p><p>这个例子中重要的是分析n阶与n-1阶的递推关系。而分析时则应牢牢抓住一条单独的边。</p><p>结论如下：$C_n=\dfrac{4}{3}C_{n-1}$（每条长为3的边均分裂成了4条长为1的边）</p><p>$S_n=S_{n-1}+\dfrac{3 \cdot 4^{n-2}}{9^{n-1}}S_1$（S1的系数中3表示分裂出三个子图形，4表示边的数目，9表示面积的缩减程度）</p><h2 id="敛散性"><a href="#敛散性" class="headerlink" title="敛散性"></a>敛散性</h2><p>回忆数列的敛散性，我们掌握了夹逼定理、单调有界、取子列、柯西准则等方法。而在这一章中我们会学习更多的方法。</p><p>1.几何级数的敛散性（分四类讨论即可）</p><p>2.调和级数的敛散性</p><p>方法有积分判别法、柯西准则或其变形，还有放缩。</p><p>3.p级数的敛散性</p><p>可用积分判别法或放缩判断。</p><h2 id="计算性质"><a href="#计算性质" class="headerlink" title="计算性质"></a>计算性质</h2><p>1.线性运算法则</p><p>2.级数可改变（增/减/变）其有限项而保持敛散性不变</p><p>3.结合性</p><p>//对于结合性，我还没有理解一些细节</p><p>4.$\sum\limits_{n=1}^{\infty}u_n$收敛，则$\lim\limits_{n \to \infty}u_n=0$。</p><p>4的推论即其逆否定理：$\lim\limits_{n \to \infty}u_n\not=0$或者不存在，则$\sum\limits_{n=1}^{\infty}u_n$必发散。（逆命题的反例：调和数列）</p><p>5.级数收敛的柯西准则//什么时候用呢？</p><h1 id="正项级数敛散性的判定"><a href="#正项级数敛散性的判定" class="headerlink" title="正项级数敛散性的判定"></a>正项级数敛散性的判定</h1><p>负项级数可向正项级数转化，正如负定二次型可向正定二次型转化一样。故此处我们只研究正项级数。</p><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><p>找上界是一种方法。（化归到单调有界定理）</p><p>还可以通过计算$\lim\limits_{n \to \infty}u_n$来判断。</p><p>柯西准则。</p><h2 id="方法2：比较判别法"><a href="#方法2：比较判别法" class="headerlink" title="方法2：比较判别法"></a>方法2：比较判别法</h2><p>比较判别法常用于有三角函数的情况，如sin x, cos x可以替换为x。</p><p>比较判别法有两处可减弱的条件（忽略前有限项，常数），它们强调了问题的主要部分，使原本可能需要的特判不再需要，因而小幅降低了问题的复杂程度。</p><p>例题1：求证$\sum(1-cos\dfrac{a}{n})$收敛。</p><p>例题2：已知$\sum a^2$收敛，求证$\sum \dfrac{|a_n|}{\sqrt{n^2+\lambda}}$收敛。</p><p>例题3：$a_n &lt; b_n &lt; c_n, \sum a_n,\sum c_n$均收敛，求证$\sum b_n$收敛。</p><p>例题4：设$a_n = \int_{0}^{\pi/4}tan^nxdx$，求证$\sum \dfrac{a_n}{n}$收敛。</p><p>较比较判别法更容易使用的是它的极限形式。</p><p>例题5：求证$\sum(\sqrt{n+1}-\sqrt{n})^p ln\dfrac{n+1}{n-1}$收敛。</p><p>例题6：求$\sum [e - (1+ \dfrac{1}{n})^n]^p$的敛散性。</p><h2 id="方法3：达朗贝尔判别法"><a href="#方法3：达朗贝尔判别法" class="headerlink" title="方法3：达朗贝尔判别法"></a>方法3：达朗贝尔判别法</h2><p>达朗贝尔判别法与柯西判别法的作用实际在于将原级数放为几何级数，但在lim = 1时会不起作用，因为存在“波动”的可能性。</p><p>这两项判别式的条件充分而不必要，因极限不存在的级数也可能收敛，如$\sum \dfrac{2+(-1)^n}{2^n}$。</p><p>例题1：求证$\sum \dfrac{ncos^2 n\pi}{2^n}$收敛。</p><p>例题2：判断$\sum \dfrac{n! a^n}{n^n}$的敛散性。</p><p>在例题2中，对于a=e的情况，最后还要结合基本方法，这是道较为灵活的题目。</p><p>例题3：判断$\sum \sqrt[n]{a} - \sqrt{1+\dfrac{1}{n}} $的敛散性。</p><p>答案：$lna = 1/2$时收敛，否则发散。</p><h2 id="方法4：柯西判别法"><a href="#方法4：柯西判别法" class="headerlink" title="方法4：柯西判别法"></a>方法4：柯西判别法</h2><h2 id="方法5：积分判别法"><a href="#方法5：积分判别法" class="headerlink" title="方法5：积分判别法"></a>方法5：积分判别法</h2><p>例题1：判断p级数的敛散性。</p><p>例题2：判断$\sum \dfrac{1}{n(lnn)^p}$的敛散性。</p><p>答案：p&gt;1时收敛，否则发散。</p><p>例题2的变式还有$\sum \dfrac{1}{ln(n!)}, \sum \dfrac{lnn}{n}, \sum \dfrac{sin\dfrac{1}{n}}{lnn}$等，它们都可以转换到上式。</p><p>例题3：求证$\sum \int_n^{n+1}e^{-\sqrt{x}}dx$收敛。</p><p>例题4：求证$\sum \int_0^{1/n} \dfrac{\sqrt x}{1 + x^2} dx$收敛。</p><h1 id="幂级数"><a href="#幂级数" class="headerlink" title="幂级数"></a>幂级数</h1><h2 id="收敛半径"><a href="#收敛半径" class="headerlink" title="收敛半径"></a>收敛半径</h2><p>Abel定理：若$\sum a_n x^n$在$x=x_0$处收敛，则它在满足不等式$x &lt; x_0$的一切x处绝对收敛；若$\sum a_n x^n$在$x=x_0处发散$，则他在满足不等式$x &gt; x_0$的一切x处发散。</p><p>至于证明，将$a_n x^n$转化成为$a_n {x_0} ^n \dfrac{x^n}{ {x_0} ^n}$即可。</p><p>由Abel定理我们可知幂级数的收敛域是关于原点左右对称的，故可引入收敛半径和收敛区间的概念。它们相对收敛域是较弱的概念。</p><p>Cauchy-Hadamard公式与其根式形态。</p><p>注意：若幂级数为缺项级数，不可直接由Cauchy-Hadamard公式求，需应用定义法求。</p><p>//Cauchy-Hadamard公式无极限时候的意义？</p><h2 id="和函数"><a href="#和函数" class="headerlink" title="和函数"></a>和函数</h2><p>简单的变式：对涉及$\dfrac{1}{x^n}$或$x^{2n-1}$这些项的“伪“幂级数，换元即可。</p><p>幂级数的和函数满足连续、可微、可积这样的分析性质，并且微分/积分后收敛半径不变。</p><p>值得注意的是，虽然收敛半径不变，但收敛域是可能发生改变的。$f(x) = \sum \dfrac{x^n}{n^2}$和他的导数及二阶导数在收敛域上的差异就是一个很好的例子。</p><p>唯一性定理：S(x)为幂级数在x=0某邻域的和函数，则其各项系数满足$a_n = \dfrac{S^{(n)}(0)}{n!}$这一关系，这使得幂级数由其和函数的导数唯一地确定下来。</p><p>对幂级数除法的直观感受：$\sum a_n x^n = 1, \sum b_n x^n = 1 - x$，其商收敛半径远小于原式收敛半径。（$R &lt; min(R_a, R_b)$？）</p><p>通过求幂级数的和函数，我们得以从一般到特殊，求出一些幂级数的取值，如$\sum \dfrac{(-1)^n}{n} = ln 2$。</p><p>例题：求$\sum \dfrac{x^n}{2n + 1}$的和函数。</p><p>//幂级数的加减乘除结果的收敛半径满足什么条件？</p><p>//和函数在收敛半径之外为何仍有取值？</p><p>//在算和函数时可能会算错，有什么好用的检错算法呢？（代入边界值貌似行不通？）</p><h1 id="函数展幂级数"><a href="#函数展幂级数" class="headerlink" title="函数展幂级数"></a>函数展幂级数</h1><h2 id="展开"><a href="#展开" class="headerlink" title="展开"></a>展开</h2><p>相较于微积分I中直接的求导，在这里泰勒级数的面貌显然要复杂得多了——要确认收敛半径，还有有$lim R_n (x) = 0$的先决条件（不然，有反例$f(x) = x ? e^{- \frac{1}{x^2}} : 0$）</p><p>习题：求$2x - \dfrac{4}{3!}x^3 + \dfrac{6}{5!}x^5 + …$的收敛域与和函数。</p><p>求基本的五种级数的麦克劳林展开：$e^x, sin x, cos x, ln(1 + x), (1 + x)^a$。</p><p>其中$cos x$可以化归到$sin x$，而$ln(1 + x)$用积分的方法会更加好算。这些是基本的方法，也是在后面的求解中会渗透进去的。至于$(1 + x)^a$，猜出结果再反推回去也未尝不是一种方法。</p><p>$(1 + x)^a$本身在端点处的收敛性与a的取值有关：$a \leq -1$两边开，$a &gt; 0$两边闭，否则左开右闭。另外，这个展开本名是“牛顿二项式展开”。</p><p>有了基本的五种函数的展开还是远远不够的，不过有了它们我们就能推出更多的级数展开了。请先展开$\dfrac{1}{1 + x^2}, arctan x$。</p><p>接着，再展开$\dfrac{1}{\sqrt{1 + x}}, \dfrac{1}{\sqrt{1 - x^2}}, arcsin x$。</p><p>一些多项式的函数也可以展开了：如$\dfrac{x}{1 + x - 2x^2}$。//$\dfrac{1}{x^2 + x + 1}$则如何呢？</p><p>一些复杂的函数，因为可以写成简单函数的组和，也是可展开的。如$\dfrac{1}{4} ln \dfrac{1 + x}{1 - x} + \dfrac{1}{2}arctan x - x$。不过，先求导再求积可能更为方便。</p><p>变式：非标准情况下的幂级数展开，如展成关于$(x - 3), ln \dfrac{x - 1}{x + 1}$的幂级数之类。</p><p>//级数展开的端点值问题？</p><p>//$sin^3 x$如何展开幂级数？这个问题本身是否值得研究？</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>1.计算积分的近似，如$\int \dfrac{sin x}{x}$//$\int \dfrac{x}{sin x}$则如何呢？</p><p>2.计算高阶导数，如$f(x) = e^{x^2}$，求$f^{(n)}(0)$。</p><p>3.导出欧拉公式，联通实数域与复数域。</p><p>4.数值计算，如计算$sin1°$。</p><h1 id="傅里叶级数"><a href="#傅里叶级数" class="headerlink" title="傅里叶级数"></a>傅里叶级数</h1><p>三角解函数的正交性为傅里叶级数的求解各项系数提供了依据，也提供了具体的算法，但是它虽容易接受，却并不容易计算。$a_0$与$a_n$还需要分开讨论，因为$cos 0x$不能积分成$sin 0x$。</p><p>周期函数是否能够展开需要用到迪利克雷定理，条件十分的特殊，相较级数展开也比较弱，但书中并未给出证明。</p><p>计算傅里叶级数的时候要关注函数的奇偶性，因为这样也许可以大大简化计算步骤。</p><p>例题：计算巴塞尔级数的值。</p><p>（假设我们还不会算）首先我们来分析一下，这一节在讲傅里叶级数，所以应该把一个函数展开成傅里叶级数然后再算。为方便起见，算f(0)好了，这样$f(0) = a_0 / 2 + \sum a_n$。我们希望$\sum a_n = \sum \dfrac{1}{n^2}$或是与之结构相似。</p><p>展什么函数好呢？先从简单的情况开始分析吧。试试$f(x) = x(-\pi &lt; x &lt; \pi)$，展开得$f(x) = 2 \sum \frac{(-1)^{n+1}}{n} sin nx$，嗯，根据$b_n^2$的形式可以用一用帕塞瓦尔等式，至此题目就做完啦。</p><p>（不会帕塞瓦尔等式也不要紧）展开$f(x) = x$的过程中我们看到$\int x sinnx dx$在分部积分时会生成系数的$\dfrac{1}{n}$，$\int x^2 cosnx dx$或许就能给出我们梦寐以求的$a_n = \dfrac{1}{n^2}$。那么试试$f(x) = x^2 (-\pi &lt; x &lt; \pi)$，（虽然复杂度已经有些高了hhh）能不能得到$\sum a_n = \sum \dfrac{1}{n^2}$呢？嗯，$a_n = (-1)^n \dfrac{4}{n^2}$，形式相仿！然后瞎搞一通也就做好了……（这样的分析有点马后炮2333）</p><p>如果原函数是在[a, b]而非[-l, l]上呈周期性，比方说，$x - [x]$，并不用有什么特殊的考虑！因为它在[-l, l]也是呈周期性的，$\int_a^b f(x) = \int_{-l}^l f(x)$。所以只要将积分区间换一换即可，答案不会有任何影响。</p><p>如果原函数不是周期函数，我们也可以截取我们想要的部分把它周期化。</p><p>//傅里叶展开的价值</p><p>//已知傅里叶级数求原函数？（或验证结果？）</p><h2 id="帕塞瓦尔等式"><a href="#帕塞瓦尔等式" class="headerlink" title="帕塞瓦尔等式"></a>帕塞瓦尔等式</h2><p>我们可以用它来巩固我们对于级数乘法还有（三角正交）的概念。证明的话也有两种思路，一种是直接拆开，一种是只拆一个f(x)。虽然后者在思想上与前者等价，但它在形式上要简洁得多。</p><p>例题：f(x)可被傅里叶展开，求卷积函数$F(x) = \int_{- \pi}^\pi f(t) \cdot f(t+x) dx$的傅里叶级数。（key：$A_0 = a_0^2 / 2, A_n = a_n^2 + b_n^2, B_n = 0$）</p><h1 id="综合题"><a href="#综合题" class="headerlink" title="综合题"></a>综合题</h1><p>例题1：求级数$\sum \dfrac{(n+1)^2}{n!}$的和。（$key: 5e$）</p><p>例题3：设$0 &lt; P_1 &lt; P_2 &lt; … $，试证$\sum \dfrac{1}{P_n}$收敛$\Rightarrow$$\sum \dfrac{n}{P_1 + P_2 + … + P_n}$收敛。</p><p>例题4：设正项级数$\{ a_n \}$单调增加有上界，证明级数$\sum (1- \dfrac{a_n}{a_{n+1}})$收敛。</p><p>书上未整理的题：2、5、7、13、14</p><p><strong>借级数包装微分中值定理的题</strong></p><p>例题4：设f(x)在x=0的某一邻域内具有二阶连续导数，且$\lim\limits_{x \to 0} \dfrac{f(x)}{x}=0$，证明级数$\sum f(\dfrac{1}{n})$收敛。</p><p>例题5：设偶函数f(x)在x=0处存在二阶导数，且$f(0)=1$，证明级数$\sum [f(\dfrac{1}{n})-1]$收敛。</p><p>//过程待补充</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;级数，是用于&lt;strong&gt;表达函数&lt;/strong&gt;的&lt;strong&gt;数值计算&lt;/strong&gt;的工具。（&lt;del&gt;我口胡的&lt;/del&gt;）&lt;/p&gt;
&lt;p&gt;我们要学的级数与数列息息相关，可以说是后者的加强版本。两者从敛散性开始便有了亲密的联系。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数学_分析" scheme="https://nessoffice.github.io/tags/%E6%95%B0%E5%AD%A6-%E5%88%86%E6%9E%90/"/>
    
      <category term="课程笔记" scheme="https://nessoffice.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【数学之美】微积分下-苏德矿版：第一章 矢量代数与空间解析几何</title>
    <link href="https://nessoffice.github.io/2019/04/27/Calculus_Vol2-CH01/"/>
    <id>https://nessoffice.github.io/2019/04/27/Calculus_Vol2-CH01/</id>
    <published>2019-04-27T13:00:59.000Z</published>
    <updated>2019-05-01T10:47:40.235Z</updated>
    
    <content type="html"><![CDATA[<p>用代数的方法研究几何问题，在三维的坐标系中。</p><a id="more"></a><h1 id="概要及注意"><a href="#概要及注意" class="headerlink" title="概要及注意"></a>概要及注意</h1><p>注意：在讨论解析几何的时候很多情况下要做特判，特判重合、等于零，等等。但出于懒惰与大意还有其他原因，并非每一处需要特判的地方我都有指出，请读者自行注意特殊情况。</p><h1 id="矢量"><a href="#矢量" class="headerlink" title="矢量"></a>矢量</h1><p>要素：大小与方向。矢量起点不固定，故称自由矢量。这为证明提供了一些方便。</p><p>模与零矢量，零矢量的方向，平行的非传递性。</p><p>矢量加法的平行四边形法则，加法交换律与结合律，减法。</p><p>线性组合与分解，线性相关与共面的一致性，尤其是二维与三维情况下。</p><p>用矢量证明三角形三垂线交于一点</p><h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><p>右手系，卦限。</p><p>单位矢量用以表示方向，基</p><p>投影，方向角与方向余弦。</p><p><strong>Caution：求单位向量时不可忘记$\pm$！！</strong></p><p>距离（推导办法：化归+勾股定理）</p><p>方向余弦满足：$\sum cos^2 = 1, \vec{e} = cos \alpha \vec{i} + cos \beta \vec{j} + cos \gamma \vec{k}$。</p><p>$\dfrac{m}{n}$定比分点公式（比$\lambda$定比分点公式要更容易记，可用于求质心坐标）</p><h1 id="矢量运算"><a href="#矢量运算" class="headerlink" title="矢量运算"></a>矢量运算</h1><h2 id="数乘"><a href="#数乘" class="headerlink" title="数乘"></a>数乘</h2><p>独立于矢量，可将数分离。</p><p>结合律、分配律</p><h2 id="点乘"><a href="#点乘" class="headerlink" title="点乘"></a>点乘</h2><p>投影，和投影与投影和</p><p>渊源，基本运算定律，垂直</p><p>从矢量到模的转化</p><p>点乘坐标表达式</p><p>证明余弦定理</p><h2 id="叉乘"><a href="#叉乘" class="headerlink" title="叉乘"></a>叉乘</h2><p>规则，不满足交换律。</p><p>平行（在坐标表达式中也有所体现）</p><p>坐标表达式</p><p>求面积（二维情形与三维情形），求垂直的矢量</p><p>关于面积，代数上的推导自然方便，但感觉上缺少了几何的古典之美，以下是m67的几何推导（二维情形）：</p><p><a href="http://www.matrix67.com/blog/archives/6217" target="_blank" rel="noopener">http://www.matrix67.com/blog/archives/6217</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>混合积</p><p><strong>形式</strong>：$a \cdot (b \times c)$，其展开就是把$b \times c$最上面一行换成$a_1, a_2, a_3$。</p><p><strong>性质</strong>：三向量共面 $\Leftrightarrow$ 混合积 = 0</p><p><strong>几何意义</strong>：以a、b、c为棱的平行六面体体积。（也可以算四面体等）</p><p>二重矢积：$a \times (b \times c) = (a \cdot c)b - (a \cdot b)c$</p><h1 id="平面与直线方程"><a href="#平面与直线方程" class="headerlink" title="平面与直线方程"></a>平面与直线方程</h1><h2 id="平面方程"><a href="#平面方程" class="headerlink" title="平面方程"></a>平面方程</h2><p>先来回忆一下如何确定一个平面。这又很多种方法，其中一种是通过已知一点还有平面的法向量。通过简单的推导，我们能够得到平面的点法式方程：$A(x - x_0) + B(y - y_0) + C(z - z_0) = 0$。（注意推导顺序：已知方程并不好推出为何它表示了点法式）</p><p>将点法式方程进行简单的变式，就得到了平面的一般方程：$Ax + By + Cz + D = 0$。</p><p>平面的一般方程与点法式方程实则相差无几，都是通过法向量来刻画平面的”方向”的，再以常数调整平面的位置。这是非常巧妙的做法，将较难描述的平面通过我们已学过的向量来描述。</p><p>一般方程是一次的，通过一一对应，我们又能够推出平面方程即一次方程，前者是几何概念，后者是代数概念。</p><p>以下是特殊情况：①D = 0；②A = 0；③A = B = 0……</p><p>有了点法式方程我们能处理什么样的问题了呢？一种变式是过三点的平面（三点可得两向量，叉乘得法线）。</p><p>还有“垂直于两平面”这种条件，也可转化为法向量。</p><p>平面的截距式方程，画图比较方便，还有啥用途我就不知道了。</p><p>谈到平面方程，我们还需要考虑平面间的关系：两平面夹角、点到平面距离……点到平面的距离的公式较为美观，但笔者尚不不明白其特殊意义。</p><h2 id="直线方程"><a href="#直线方程" class="headerlink" title="直线方程"></a>直线方程</h2><h3 id="直线的两种方程"><a href="#直线的两种方程" class="headerlink" title="直线的两种方程"></a>直线的两种方程</h3><p>在二维的情况中直线很容易表示，毕竟二维情况下x，y构成了一组映射。但在三维情况下呢？映射不能用了，我们可以选择参数式方程，或“推广”参数方程的思想，构造出点向式方程：$\dfrac{x - x_0}{a} = \dfrac{y - y_0}{b} = \dfrac{z - z_0}{c}$。</p><p>或者，我们可以“两点确定一条直线”，得到两点式方程。</p><p>再或者，我们也可以把直线看作是两个平面的交，这就得到了一般方程。</p><p>注意点向式方程的特殊情形：$a = 0, a = b = 0$的情形。</p><p>点向式虽然看上去只是“一个”方程，但它其实是两个映射的拼接：从x到y的映射与从x到z的映射。把这两个映射分别写出来，再稍加变形，我们可以实现从点向式方程到一般方程的转换。</p><p>一般方程看上去和点向式方程差异挺大，能否将一般方程转化为点向式方程呢？答案是肯定的：将两个平面的法向量作叉乘，即得到直线的方向向量。再任取两个平面的一公共点，如此便好啦。</p><p>其实两点式、参数式、点向式的中心思想都是一样的，不过它们的出发点不同，故使用起来有方便与不方便之分。笔者更为喜欢参数式方程，因为它在表示“直线上的点”上更为方便。看到直线与XXX的“交点”等表述，不妨考虑参数式方程。以下是例题：</p><p>1.证明直线$\dfrac{x+1}{2} = \dfrac{y+1}{-1} = \dfrac{z+3}{3}$落在平面$2x + y - z = 0$上。</p><p>2.求过点$P(-1, 2 ,-3)$且垂直于矢量$a = (6, -2, -3)$还与直线$\dfrac{x-1}{3} = \dfrac{y+1}{4} = \dfrac{z-3}{-5}$相交的直线方程。</p><p>例二可以通过构造过点$P$且以$a$为法向量的平面$\pi$，再来求交点的坐标。不过笔者认为使用参数式方程要容易一些，不光在思维难度上，也在运算上。</p><h3 id="点线面间的关系"><a href="#点线面间的关系" class="headerlink" title="点线面间的关系"></a>点线面间的关系</h3><p><strong>1.求点到直线的距离</strong></p><p>可以通过找到点在直线上的投影（即解$P’$使$P’P \perp M_0P’$，其中$M_0$为直线上任意一点，$M_0P’$即直线方向向量）。</p><p>也可以通过几何分析，确定$h = \dfrac{|PM_0 \times \vec{v}|}{|\vec{v}|}$，其中$M_0$为直线上任意一点，$v$即直线方向向量。</p><p><strong>2.求直线在平面上的投影直线方程</strong></p><p>容易想到的做法是在投影直线上求出两点，但这样要用两次高斯消元，复杂度略高，有无更好的解法呢？</p><p>考虑直线的一般方程。所谓投影直线，必然在给定平面上。而且，它也必然在本身与给定直线形成的平面上。如何确定这个平面呢？考虑其法向量$n$，$n$与原直线垂直，也与给定平面的法向量垂直，故一个叉乘即可得$n$。至此问题的思路便清晰了。</p><p><strong>3.求异面直线间的距离</strong></p><p>求线和线的距离不容易，但是求线到与之平行的面的距离则并不困难，能够将前者转化为后者呢？</p><p>在这样的思路下，我们过直线$L_1$作与$L_2$平行的平面，问题便迎刃而解了。因将得到的线与面的距离平移，就得到两直线间的距离。经整理，得$h = \dfrac{|M_1M_2 \cdot (v_1 \times v_2)|}{|(v_1 \times v_2)|}$。其中$M_1, M_2$一者为直线上的点，一者为构造出的平面上的点（为方便起见，$M_1, M_2$分别可取两直线上的点），$v$是直线方向向量。</p><p>还有线面角、线线角等，就不加赘述了。</p><h3 id="平面束方程"><a href="#平面束方程" class="headerlink" title="平面束方程"></a>平面束方程</h3><p>直线的方程并非唯一的。点向式固然不唯一：点可以任选，方向向量的大小也是任意的，但这些都是小问题。一般方程的不唯一就有意思了：因为任意两个过该直线的互异平面均可得到同一直线，直线可由无穷多对平面定义。那么，能否通过直线找到所有经过它的平面呢？</p><p>先给出结论吧：若记直线的一般方程为$A_1x + B_1y + C_1z + D_1 = 0$ &amp;&amp; $A_2x + B_2y + C_2z + D_2 = 0$，则其经过该直线的平面必可表示为$\lambda(A_1x + B_1y + C_1z + D_1) + \mu(A_2x + B_2y + C_2z + D_2) = A_3x + B_3y + C_3z + D_3$。</p><p>至于为什么这个式子成立，我们可从法向量的角度来看。$\lambda(A_1x + B_1y + C_1z) + \mu(A_2x + B_2y + C_2z)$表示了垂直于直线的平面上的一切向量。又$A_3x + B_3y + C_3z + D_3 = 0$过直线，故其取遍了一切过直线的平面。</p><p>以上的平面束方程中有两个变元，但实际运算时往往取$\lambda = 1$还有$\lambda = 0$以减少未知量个数。</p><p>平面束方程在求解“过直线且满足一定性质”的平面上较为有效。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>问题：我们学到这里能解决哪些问题了呢？</p><p>1.求过一点且垂直于已知直线的直线</p><p>2.……（待补充）</p><h1 id="曲面方程"><a href="#曲面方程" class="headerlink" title="曲面方程"></a>曲面方程</h1><p>面：满足$F(x, y, z) = 0$的点的集合。</p><p>先从球面方程$x^2 + y^2 + z^2 = 1$直观地感受一下曲面方程吧，它类似于二位情况下的曲线方程。</p><h2 id="柱面方程"><a href="#柱面方程" class="headerlink" title="柱面方程"></a>柱面方程</h2><p>啥是柱面呢？可以联想一下“圆柱”：一个圆，沿着一条直线划出的轨迹。这样便引出柱面的定义了：一条直线$L$绕着曲线$\Gamma$运动所形成的轨迹。$L$叫母线，$\Gamma$叫准线。</p><p>在空间中，$F(x, y) = 0$便表示以z轴为母线的柱面方程。这样我们就可以写出“正常的”圆柱的方程啦！</p><p>如果母线不是z轴，而是复杂的情况，如$\vec{v} = a\vec{i} + b\vec{j} + c\vec{k}$，该怎么办咧？先考虑简单的情况：准线在$xOy$上。那么，所得柱面便是将准线沿“斜着的”方向平移即可，对于不在$xOy$平面上的点，可以通过母线将其转换到$xOy$平面上。通过推导，我们得到这样的曲面方程即$F(x - \dfrac{a}{c}z, y - \dfrac{b}{c}z) = 0$。</p><p>平面上的曲线方程放到空间中，都能“进化”成柱面方程，如双曲柱面、抛物柱面、椭圆柱面等等。</p><p>//讲得还不清楚，待补充</p><h2 id="锥面方程"><a href="#锥面方程" class="headerlink" title="锥面方程"></a>锥面方程</h2><p>柱面方程是直线平动产生的，那么直线转动会产生什么呢？类似于柱面的定义，一条直线$L$固定一点绕着曲线$\Gamma$转动所形成的轨迹，这便是锥面。</p><p>如果$\Gamma$在平面$z = h$上，那么锥面方程便是$F(\dfrac{h}{z} x, \dfrac{h}{z} y) = 0$。</p><p>锥面方程的一个例子是椭圆锥面：以$z = c$平面上的椭圆$\dfrac{x^2}{a^2} + \dfrac{y^2}{b^2} = 1$为准线而以原点为顶点的锥面方程，写出来就是$\dfrac{x^2}{a^2} + \dfrac{y^2}{b^2} - \dfrac{z^2}{c^2} = 0$。</p><h2 id="旋转曲面方程"><a href="#旋转曲面方程" class="headerlink" title="旋转曲面方程"></a>旋转曲面方程</h2><p>上一种情况中是直线绕固定点转动，若是直线绕固定轴转动，得到的就是旋转曲面了，这可以很形象地画出来。</p><p>考虑$yOz$平面上的曲线$\Gamma$，其方程为$F(y, z) = 0$。$\Gamma$绕z轴转动得到的旋转曲面方程如何求解呢？考虑$z = c$平面上的$\Gamma$上的一点与旋转后的曲面上的一点，我们要做的便是将后者化归到前者。由观察知，这两点到z轴的距离都相等。于是乎，可得旋转曲面方程$F(\pm \sqrt{x^2 + y^2}, z) = 0$。</p><p>以上是绕一个坐标轴旋转的情况，换为其他坐标轴，解法也大同小异。</p><p>通过旋转曲面我们又能得到一些经典的曲面：单叶双曲面、双叶双曲面。前者可由$x^2 - y^2 = 1$绕y轴得到，后者可由其绕x轴得到。</p><p>旋转曲面方程求解的中心思想便是$\pm \sqrt{x^2 + y^2}$转化为$y$。记住这点，我们可以求一些稍微偏僻一点的题目：如直线$\dfrac{x - 1}{1} = \dfrac{y}{1} = \dfrac{z}{2}$绕z轴旋转所形成的曲面的方程。</p><h1 id="曲线方程"><a href="#曲线方程" class="headerlink" title="曲线方程"></a>曲线方程</h1><p>同理于直线方程的定义，曲线可以通过两个面的交得到，无论是平面还是曲面。特殊地，柱面和准线所在平面的交就能得到准线。（有趣的是，之前我们是用更易描述的曲线得到较难描述的柱面的，现在我们又用约束较少的柱面来解约束更多的曲线了）</p><p>曲线可以用参数方程表示，一个经典的例子便是螺旋线。</p><p>曲线在平面上的投影也是一个重要的课题，其算法是容易接受的，但理解起来并不那么容易。我们先看个简单的例子：</p><p>曲线为$x^2 + y^2 + z^2 = 2, z = 1$，求其于$xOy$平面上的投影。</p><p>算法的第一步是消去z，但这意味着什么呢？其实便是将z=1平面中的形状给拓展成柱面。然后取z=0，就是取柱面的一个截面。总之，就是将z=1平面上的形状投影到z=0上面了。</p><p>理解了上面的例子，再来看一般的情况吧：$F_1(x, y, z) = 0, F_2(x, y, z) = 0$，解得$z = G(x, y)$。对具体的$z = z_0$，$F_1(x_0, y_0, z_0) = F_1(x_0, y_0, G(x_0, y_0)) = F’(x_0, y_0)$，也就是$z = z_0$平面上的曲线。所有这样的曲线形成的柱面的并也就是$F_1(x, y, G(x, y)) = F’(x, y)$。取$z = z_0$，即得其在xOy平面上的投影。</p><p>有面的投影，也可以有体的投影。体的可以通过面的“围成”得到。故在曲面的方程中将等号更为不等号，体的投影便可得到。</p><h1 id="二次曲面"><a href="#二次曲面" class="headerlink" title="二次曲面"></a>二次曲面</h1><p>接触到曲面以后，我们不免要问，基本的曲面有哪些呢？考虑到次数越高往往越麻烦，而一次方程只能够产生平面，我们探索的主要方向是二次曲面。三个变元三种指数（0，1，2）正负两种情况，能够出现多少种组合呢？这里有很多约束条件，要考虑对称，要考虑常数项，比较麻烦。</p><p>//还不会讨论</p><p>书中给出了六类情况：其中“纯二次”的有椭球面、二次锥面、单叶双曲线还有双叶双曲线；含一次项的有椭圆抛物面还有双曲抛物面（马鞍面）。</p><p>了解了这些情况，我们如何从给定的方程中确定形状呢？这是由曲线出发得到曲面的逆过程，并不符合正常的思维规律。故而我们可以逆向思维，考虑什么样的曲线能凑出这个方程，然后再通过“一一对应”确定唯一性。以$\dfrac{x^2}{a^2} + \dfrac{y^2}{b^2} - \dfrac{z^2}{c^2} = -1$为例。将坐标轴做伸缩变换，得到$\dfrac{x^2 + y^2}{b^2}  - \dfrac{z^2}{c^2} = -1$。而这个方程能通过$\dfrac{x^2}{b^2} - \dfrac{z^2}{c^2} = -1$绕z轴旋转得到。通过简单的图象，能够确定这是有两瓣的双曲线旋转成的图形。那么，它就是双叶双曲线了。</p><p>然而，也有不这么好确定的情况：$z = - \dfrac{x^2}{a^2} + \dfrac{y^2}{b^2}$。刚才的方法就不适用啦！这时候可以采取“平面截割法”，比如，用$z = 0, 1, 2, …$割给定的方程，看它在那个平面上的投影如何。再积部分为整体。分别用平行于三个坐标轴的平面割上述曲面，可以形象地感受到“马鞍面”这一名称的名副其实。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用代数的方法研究几何问题，在三维的坐标系中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数学_分析" scheme="https://nessoffice.github.io/tags/%E6%95%B0%E5%AD%A6-%E5%88%86%E6%9E%90/"/>
    
      <category term="课程笔记" scheme="https://nessoffice.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【数学之美】微积分下-苏德矿版：第二章 多元函数微分学</title>
    <link href="https://nessoffice.github.io/2019/04/27/Calculus_Vol2-CH02/"/>
    <id>https://nessoffice.github.io/2019/04/27/Calculus_Vol2-CH02/</id>
    <published>2019-04-27T12:51:59.000Z</published>
    <updated>2019-05-01T10:48:11.319Z</updated>
    
    <content type="html"><![CDATA[<p>我们为什么要学习多元函数的微分学？</p><a id="more"></a><h1 id="极限与连续"><a href="#极限与连续" class="headerlink" title="极限与连续"></a>极限与连续</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>多元函数：一种特殊的映射。比如，$R^2 \rightarrow R$的映射，这里又用到了笛卡尔积！</p><p>关注定义域（二位情况下为一平面）</p><h2 id="平面点集"><a href="#平面点集" class="headerlink" title="平面点集"></a>平面点集</h2><p>邻域（依据距离描述，事实上一维情况中也是用距离描述的）</p><p>点的类别：内点外点与界点，通过邻域来描述</p><p>集的类别：开集与闭集（关注描述方式）</p><p>连通性（通过折线描述）与开区域</p><p>对于上述概念，我们能够发现，开集与闭集（集的类别）是通过内点外点（点的类别）刻画的，而连通性也是由点的相连刻画的。然而，点本身则是依据其他点（邻域）刻画的。在这里，点本身并不重要，重要的是点与点之间的联系。</p><h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><p>二重极限：由任意路径逼近都趋于极限值，方有二重极限。</p><p>累次极限：先x后y或先y后x的趋近极限值，两种算法可能不一，本质是一元极限。</p><p>二重极限中的“任意”难以直接确定，但否定只需找出反例即可。故若有函数满足在两条路径下趋向某点的极限值不一，函数在该点没有二重极限。</p><p>举个例子：$f(x, y) = \dfrac{2xy}{x^2 + y^2}$。取$y = kx$，可说明其在$(0, 0)$处无极限。</p><p>虽说二重极限似乎比累次极限更“苛刻”更“强”一些，但事实并非如此，$f(x, y) = xsin \dfrac{1}{y} + y sin \dfrac{1}{x}$便是一个非常好的例子。</p><p>有定理：若两累次极限与二重极限均存在，则三者相等。</p><p>该定理的推论为：若两累次极限存在但不相等，则二重极限不存在。</p><p>在用定义求二重极限时，通过不等式（如基本不等式）还有齐次化的方法有时能够在一定程度上简化问题。</p><h2 id="连续"><a href="#连续" class="headerlink" title="连续"></a>连续</h2><p>//二元函数的连续性较之一元更为难以判断，是否有判断连续的方法？</p><p>二元函数中的连续继承了一元函数中的一些方法：最值、介值、一致连续……</p><h1 id="偏导数与全微分"><a href="#偏导数与全微分" class="headerlink" title="偏导数与全微分"></a>偏导数与全微分</h1><p>介绍偏导数前，先介绍的是“增量”的概念。</p><p>所谓偏导数，理解起来相当容易，不论是在代数上还是几何上。</p><p>值得注意的是：$\dfrac{\partial f(x, y)}{\partial x \partial y} = \dfrac{\partial f(x, y)}{\partial y \partial x}$，当$f_{xy}^{‘’}(x, y)$与$f_{yx}^{‘’}(x, y)$在给定点均连续时。（至于证明，先考虑如何得到二阶导数？可以通过两次一元的中值定理，而这需要构造出一个四元的F，再“算两次”即可）</p><p>至于偏导数的计算，主要有两种策略：先代入另一变量再套公式，或者先套公式再代入，计算复杂度不一。</p><p>全微分，和一元的情况很像，写出来是$df(x, y) = A(x)dx + B(y)dy + o(\rho)$</p><p>关键在于全微分与偏导数的关系：$df(x, y) = \dfrac{\partial f(x, y)}{\partial x}dx + \dfrac{\partial f(x, y)}{\partial y}dy + o(\rho)$，此即全增量公式（这个式子是先假定全微分存在，再令$\Delta y = 0$，则可得到$A = \dfrac{\partial f(x, y)}{\partial x}$，非常奇妙的思路）</p><p>也正和一元的情况一样，可微强于连续：可微必然连续，连续不一定可微。另外，可微还能推出偏导存在。反过来不成立，反例：$f(x, y) = ((x, y) == (0, 0) ? \dfrac{2xy}{\sqrt{x^2 + y^2}} : 0)$。（这一反例与前面的例子略有差异）</p><p>但是偏导函数连续（作为二元函数的连续）能够推出可微（证明也是用的两次一元中值定理），这是判断函数可微的重要方法。</p><p>概念的话，关系比较错综复杂，大致有连续、可导、可微、偏导连续这几项。</p><h1 id="复合函数微分法"><a href="#复合函数微分法" class="headerlink" title="复合函数微分法"></a>复合函数微分法</h1><h2 id="求偏导"><a href="#求偏导" class="headerlink" title="求偏导"></a>求偏导</h2><p>证明（直接代入$\Delta z = (A + \epsilon_1) \Delta u + (B + \epsilon_2) \Delta v, \Delta u = …$）</p><p>算法（类似dfs的算法，变量间的关系是树状结构的，方向是从高层到低层，此之谓链式法则）</p><p>应试中需要关注当变元只有一个的时候，$\partial$得换成d。</p><p>//微分恒等式是如何构造出来的？</p><p>//变换方程的一般算法？</p><h2 id="全微分"><a href="#全微分" class="headerlink" title="全微分"></a>全微分</h2><p>一阶微分形式不变性//二阶情形？联系一元？普遍适用性？</p><h1 id="隐函数微分法"><a href="#隐函数微分法" class="headerlink" title="隐函数微分法"></a>隐函数微分法</h1><p>计算方法：用求导，抑或是用全微分//例子，及全微分在解题时的优越性？</p><p>//自由变量？自变量与因变量？</p><h2 id="隐函数组"><a href="#隐函数组" class="headerlink" title="隐函数组"></a>隐函数组</h2><p>一元情形下并没有这个东西，但多元就有了，为啥捏？因为变量间的关系更加错综复杂了。可以一个方程刻画一个隐函数，也可以两个方程刻画两个隐函数（f、g），故而有了隐函数组的概念。</p><p>求解隐函数组其实很简单，把所有方程都对同一变量求偏导，然后解方程就行了。归纳起来便是雅可比行列式。</p><p>//记号问题</p><h1 id="方向导数与梯度"><a href="#方向导数与梯度" class="headerlink" title="方向导数与梯度"></a>方向导数与梯度</h1><h2 id="方向导数"><a href="#方向导数" class="headerlink" title="方向导数"></a>方向导数</h2><p>方向导数的本质：将两个自由变量化为一个自由变量，即坐标系的一维化</p><p>可微则方向导数必存在，其公式也比较简单。但是这里因为有了新的概念引入，概念间的关系又更复杂了：①可微是方向导数存在的充分而非必要条件；②……</p><p>例子：蚂蚁旅行//这个例子的本质？</p><h2 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h2><p>梯度用于刻画$\dfrac{\partial u}{\partial l}$的最值</p><h1 id="多元函数近似运算"><a href="#多元函数近似运算" class="headerlink" title="多元函数近似运算"></a>多元函数近似运算</h1><h2 id="多元函数泰勒公式"><a href="#多元函数泰勒公式" class="headerlink" title="多元函数泰勒公式"></a>多元函数泰勒公式</h2><p>用“多项式”刻画多元函数。</p><p>n阶泰勒公式（证明：构造新的函数，将多元转化为一元，先配出公式，再考虑余项），关注记号。</p><p>注意：因为偏导连续，故而$\dfrac{\partial^2 f}{\partial x \partial y}= \dfrac{\partial^2 f}{\partial y \partial x} $。</p><p>二元函数拉格朗日中值公式及其推论（偏导为零，函数值不变）</p><h2 id="多元函数的极值"><a href="#多元函数的极值" class="headerlink" title="多元函数的极值"></a>多元函数的极值</h2><h3 id="多元函数极值概念"><a href="#多元函数极值概念" class="headerlink" title="多元函数极值概念"></a>多元函数极值概念</h3><p>极值点能够推出偏导不存在，或是存在而为零（证明前者：利用拉格朗日中值定理，$f(x_0 + h, y_0) - f(x_0, y_0) = hf’(x_0 + \theta h, y_0)$，再加个保号性）</p><p>如何判定驻点是极值点呢？记$A = f^{‘’}_{11}(x_0, y_0), B = f^{‘’}_{12}(x_0, y_0), C = f^{‘’}_{22}(x_0, y_0)$，则</p><p>—————$B^2 - AC &gt; 0$：驻点非极值点</p><p>—————$B^2 - AC &lt; 0$：驻点为(A &gt; 0 ? “极小值” : “极大值”)（A不会为0哒）</p><p>—————$B^2 - AC = 0$：得特判</p><p>证明的话依旧是拉格朗日中值定理：$f(P) - f(P_0) = \dfrac{1}{2!}[f^{‘’}_{11}(x_0 + \theta h, y_0 + \theta k) h^2 + …]$，而$f^{‘’}_{11}(x_0 + \theta h, y_0 + \theta k) = f^{‘’}_{11}(x_0, y_0) + \epsilon_1$，然后后者在$h \rightarrow 0, k \rightarrow 0$时为无穷小量，可以忽略。所以考虑二次函数$Ah^2 + 2Bhk + k^2$，判断一下$\Delta$就能得出$\Delta \not = 0$时候的结论啦（因为$\dfrac{h}{k}$可以任意取值，所以要看在全部区间上二次函数是否同号）。//书上为何在$\Delta &lt; 0$时用了其他方法？</p><p>但是这样还有一个疑问：$\Delta = 0$的时候为什么需要特判呢？这些是佐证需要特判的例子：$f_1(x, y) = x^2 + y^4, f_2(x, y) = -f_1(x, y), f_3(x, y) = x^2 + y^3$在(0, 0)点处。<del>下面我不会了</del></p><h3 id="多元函数的最值"><a href="#多元函数的最值" class="headerlink" title="多元函数的最值"></a>多元函数的最值</h3><p>比之极值，还要考虑边界点（不同于一元的情形，边界点有无穷个）</p><h3 id="条件极值"><a href="#条件极值" class="headerlink" title="条件极值"></a>条件极值</h3><p>还记得以前的线性规划么？这里约束条件也来了，不过不一定是线性的……</p><p>条件极值的简单情形如是：$G(x, y, z) = 0$，求$f(x, y, z)$的最大值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们为什么要学习多元函数的微分学？&lt;/p&gt;
    
    </summary>
    
    
      <category term="数学_分析" scheme="https://nessoffice.github.io/tags/%E6%95%B0%E5%AD%A6-%E5%88%86%E6%9E%90/"/>
    
      <category term="课程笔记" scheme="https://nessoffice.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【图灵之路】常用快捷键与常见命令</title>
    <link href="https://nessoffice.github.io/2019/04/27/Hot_Keys/"/>
    <id>https://nessoffice.github.io/2019/04/27/Hot_Keys/</id>
    <published>2019-04-27T10:59:59.000Z</published>
    <updated>2019-04-27T11:12:21.784Z</updated>
    
    <content type="html"><![CDATA[<p>熟练地掌握快捷键，在很大程度上能够提高使用计算机（不仅仅是编程）的效率。</p><a id="more"></a><p>熟练地掌握快捷键，在很大程度上能够提高使用计算机（不仅仅是编程）的效率。</p><h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><h2 id="常被忽视的按键"><a href="#常被忽视的按键" class="headerlink" title="常被忽视的按键"></a>常被忽视的按键</h2><p>F1：显示帮助</p><p>F2：重命名</p><p>F3：搜索</p><p>home/end：回到行首/行末</p><p>page up/down：向上/下翻一页</p><h2 id="按键组和"><a href="#按键组和" class="headerlink" title="按键组和"></a>按键组和</h2><h3 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h3><p>alt+tab：切换窗口</p><p>ctrl+tab：切换标签页</p><h3 id="选区"><a href="#选区" class="headerlink" title="选区"></a>选区</h3><p>shift+home/end：选中一行</p><p>shift+page up/down：选中一页</p><p>ctrl+shift+home/end：选到文章开头/结尾</p><p>ctrl+shift+arrow：选择下一个单词</p><p>ctrl+L：选中一行（删除时用）</p><h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><p>ctrl+home/end：回到文章开头/结尾</p><p>ctrl+arrow：光标移到下一个单词</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>alt+2（资源管理器中）：创建新文件夹</p><p>win+V：剪切板</p><p>win+R：运行cmd、注册表等</p><p>win+D：显示桌面</p><p>win+shift+S：截屏</p><p>ctrl+Z：撤销</p><p>ctrl+X/C/V：剪切/复制/粘贴</p><p>ctrl+S：保存</p><p>ctrl+‘+’/‘-’：页面放大/缩小</p><p>ctrl+F/H：查找/替换，另外“全部替换”和“下一个”在不同文本编辑器/IDE/浏览器中可能不一</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>fc：用以比较两个文件的差异，对拍的时候很好用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;熟练地掌握快捷键，在很大程度上能够提高使用计算机（不仅仅是编程）的效率。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="https://nessoffice.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【简牍提要】看不见的城市</title>
    <link href="https://nessoffice.github.io/2019/04/27/Calvino-Invisible_City/"/>
    <id>https://nessoffice.github.io/2019/04/27/Calvino-Invisible_City/</id>
    <published>2019-04-27T02:08:42.000Z</published>
    <updated>2019-04-27T11:12:49.831Z</updated>
    
    <content type="html"><![CDATA[<p>黄昏的御花园，暮年的蒙古大帝忽必烈凝神倾听来自威尼斯的青年旅者马可·波罗讲述他旅途中的城市，那些记忆的城市、欲望的城市、符号的城市、轻盈的城市、连绵的城市、所有疆土上亦真亦幻的城市、看不见的城市……</p><a id="more"></a><h1 id="看不见的城市"><a href="#看不见的城市" class="headerlink" title="看不见的城市"></a>看不见的城市</h1><p>书中描写了虚幻而典型的城市，每个城市都是通过场景表述的，是一个横断面，相当凝炼。在这个意义上，所谓“中心思想”应当是不存在的，故每个城市都无法概括。每一篇兼有短篇小说与诗的特点，也都是另一个视角下的生活本身。</p><p>前面的部分看上去还是比较“写实”的：记忆的城市、欲望的城市……但到后面虚构就很明显了：轻盈的城市、连绵的城市……至于人物的对话，这从一开始都是虚的，一切物件：皇宫、地图，也都是虚的，没有马可波罗也没有忽必烈，叙述者就是我们。</p><p>但为什么是城市呢？</p><h1 id="佳句集锦"><a href="#佳句集锦" class="headerlink" title="佳句集锦"></a>佳句集锦</h1><p>关于生活的虚无感：</p><blockquote><p>在帝王的生活中，总有某个时刻，在为征服的疆域宽广辽阔而得意自豪之后，帝王又会因为意识到自己将很快放弃对这些地域的认识和了解而感到忧伤和宽慰；会有一种空虚的感觉，在黄昏时分袭来，带着雨后大象的气味，以及火盆里渐冷的檀香木灰烬的味道；会有一阵眩晕，使眼前绘在地球平面图上的山脉与河流，在黄褐色的曲线上震颤不已；又将报告敌方残余势力节节溃败的战报卷起来，打开从未听人提过姓名的国王递来的求和书的蜡封，他们甘愿年年进贡金银、皮革和玳瑁，以换取帝国军队的保护：这个时候的他，会发现我们一直看得珍奇无比的帝国，只不过是一个既无止境又无形状的废墟，其腐败的坏疽已经扩散到远非权杖所能救治的程度。只有马可·波罗的报告能让忽必烈汗穿越注定坍塌的城墙和塔楼，依稀看到那幸免于白蚁蛀蚀的精雕细刻的窗格。</p></blockquote><p>记忆的城市，迪奥米拉：</p><blockquote><p>倘若九月的黄昏来到此地，白昼渐短，你将看到炸食店门口同时亮起多彩的灯光，听见某处凉台上传来女人的叫声。</p></blockquote><p>梦中的城市，伊西多拉：</p><blockquote><p>这里的建筑都有镶满海螺贝壳的螺旋形楼梯，这里的人能精工细作地制造望远镜和小提琴，这里的外来人每当在两个女性面前犹豫不决时总会邂逅第三个，这里的斗鸡会导致赌徒之间的流血争斗。</p></blockquote><p>欲望的城市，多罗泰亚：</p><blockquote><p>“我很年轻时来到这里，那天早上，许多人匆匆赶往集市，女人都长着一口漂亮的牙齿，直率地望着我的眼睛，三个士兵在高台上吹着小号，到处是车轮滚滚，到处是彩旗飘飘。在那之前，我只知道荒漠和商队车路，而那个多罗泰亚的早上使我觉得今生今世没有比这更美好的感觉。”</p></blockquote><p>（未完待续）</p><hr><p>写于2019.04.27</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;黄昏的御花园，暮年的蒙古大帝忽必烈凝神倾听来自威尼斯的青年旅者马可·波罗讲述他旅途中的城市，那些记忆的城市、欲望的城市、符号的城市、轻盈的城市、连绵的城市、所有疆土上亦真亦幻的城市、看不见的城市……&lt;/p&gt;
    
    </summary>
    
    
      <category term="文学-后现代" scheme="https://nessoffice.github.io/tags/%E6%96%87%E5%AD%A6-%E5%90%8E%E7%8E%B0%E4%BB%A3/"/>
    
  </entry>
  
  <entry>
    <title>【简牍提要】信息简史：地球的神经系统</title>
    <link href="https://nessoffice.github.io/2019/04/26/The_Information-CH05/"/>
    <id>https://nessoffice.github.io/2019/04/26/The_Information-CH05/</id>
    <published>2019-04-26T10:02:42.000Z</published>
    <updated>2019-05-01T12:51:25.340Z</updated>
    
    <content type="html"><![CDATA[<p>将一个难解之谜比作另一个难解之谜……</p><a id="more"></a><h1 id="电气时代与通信"><a href="#电气时代与通信" class="headerlink" title="电气时代与通信"></a>电气时代与通信</h1><p>电流在传播距离上未被发现存在限制，这为远距离通信带来了福音。</p><p>然而福音离降临还面临两类实际问题，一类是工程学领域上的：制造电线、封装电线、储存电流、测量电流……</p><p>还有一类则更像是个逻辑问题而非技术问题：如何将电流转换成字词？</p><p>通信领域的先驱们在面对这个问题时，可能会重新审视曾经的通信技术，它也叫telegraph。</p><h1 id="曾经的Telegraph"><a href="#曾经的Telegraph" class="headerlink" title="曾经的Telegraph"></a>曾经的Telegraph</h1><p>克洛德·沙普在法国大革命时期提出了这个词，意为“远距离书写”。</p><p>他的设计，如同之后提出的许多设计一样，非常精巧，有着机械的精密与美感。</p><p>借助的是视觉信号，所用的器物是沙普信号塔。</p><p>无法传递较长的信息，塔的成本也使得只能telegraph只能在政治、军事而非民事上使用，另中继信号塔的数量对讯息内容也存在影响（联系传话游戏）。</p><p>1793年有法国的议员在报告中呼吁关注信号塔，而1859年，美国的发明家在旅游时为信号塔的宏大、精妙与突如其来的衰亡震撼。</p><blockquote><p>这些信号塔如今陷入了沉默，再不见指示的动作。它们默默矗立在搞出，很快将屈服于时间的侵蚀之手。而电线，尽管外观没有那么雄伟，却遍布整个帝国，用燃烧的火焰将君主的意志传递给在四散在他广袤领土上的六千六百万民众。</p></blockquote><h1 id="电报出世"><a href="#电报出世" class="headerlink" title="电报出世"></a>电报出世</h1><h2 id="社会需求"><a href="#社会需求" class="headerlink" title="社会需求"></a>社会需求</h2><blockquote><p>“远距离传讯是权力和秩序的基本要素。”</p></blockquote><p>而在这个时代，资本家也希望通过远距离通讯获益。他们较政府更有推动力。</p><h2 id="最初的方案"><a href="#最初的方案" class="headerlink" title="最初的方案"></a>最初的方案</h2><p>如何将字词转换成电线中的律动？以字母表作为中间层。</p><p>发明家们的创意设计。（很有意思，高斯和韦伯也合作设计了一种方案）</p><p>在美国，起初发明家和科学家是分离的，前者自行摸索着科学的奥秘，但其对前言科学的发展的无知与无组织性也造成了电报的“重复发明”，合作关系混乱，专利纠纷激烈。有的也有操作过于麻烦等问题，效率不高。</p><h2 id="摩尔斯的方案"><a href="#摩尔斯的方案" class="headerlink" title="摩尔斯的方案"></a>摩尔斯的方案</h2><blockquote><p>“我们国家的邮政信函太慢了……闪电的效果会更好。”</p><p>“构造一种<strong>信号系统</strong>，通过它情报可以得到瞬间传递，这并不困难。”</p><p>虽然对木髓球、气泡或石蕊试纸一无所知，但他意识到信号可以用更简单、更基础、不那么有形的办法来产生，那就是最简单的电路的通和断。</p></blockquote><p>以上是摩尔斯的洞见，他的思想很漂亮，但他缺乏做出能精简地拟合这样思想的机械。韦尔帮助了他，设计了经典的模型：电报“键”，一根控制通断的杠杆。此之谓键式电报。</p><p>键式电报的一段是杠杆，另一端是电磁铁。之后发明家又将电磁铁和杠杆连接起来，这便是“中继器”（relay）。它不止能将衰弱的电流放大，还能够组和多路信号为复合信号。不过这是后话了。</p><h2 id="电报出世以后"><a href="#电报出世以后" class="headerlink" title="电报出世以后"></a>电报出世以后</h2><p>最初的电报讯息并非军事或政治讯息，而是普通的民事讯息。电报的普及也是“自下而上”的，从好玩的公民，到社会各个阶层。</p><p>人们初次收到电报的兴奋：</p><blockquote><p>随着静止的针突然抖动，刺耳的警报声响起，新闻的第一部分传了过来。我们一边兴奋地紧盯着我们朋友向来沉默寡言的面孔以及那神秘的字母盘，一边快速在我们的笔记本记下从大约一百四十多公里外传来的话语。</p></blockquote><p>也有人担心电报对传统报业的冲击，但事实上报业迫不及待地用此项技术来创造价值：因为“电报报道”为新闻贴上了紧急、兴奋等标签。而电报与报纸最终维持了共生的关系，二者互相为彼此提供正反馈。</p><p>电报的流行远远超出了人们的预期，仅过了几年它便跨越了英吉利海峡，当时的《纽约时报》对其高度评价：</p><blockquote><p>这个成果是如此实用，又是如此不可思议……预示着人类未来充满希望的前景……它是人类智力进化过程中一座壮丽的里程碑。而这项成就的实质是什么呢？是思想的传播，物质的生命冲力。</p></blockquote><p>电报给人们带来的振奋普及全球，但它的具体效用体现在当地。</p><p>讯息的传输速度迎来了数量级上的提升，它带来了完全超出人们意料的社会影响。</p><blockquote><p>这就如同一道先前完全不为人知的大坝突然决堤，洪流顿时滚滚而出一般。</p></blockquote><p>比如“天气预报”因电报而成为可能，“电”成了水银的侍女。</p><p>人们的时空观也发生了变化，讯息在传输过程中时间几乎可以忽略不计（但交易成本还是在的），时间从单一的地方时演变为标准时与地方时两套系统，这使得铁路的时间安排成为可行。</p><p>思维上，人们开始能够知道“此时”他地发生了何事。（在此之前，他地发生的事件仅有完成时）</p><p>历史及记录历史的方式也发生了变化，生活的细节得到了保留，这样大量信息的存储可谓史无前例。</p><p>新的生活方式使得新的词语出现，一些旧的词语也被赋予了新意。书中提到了两个笑话：</p><blockquote><p>有位德国妇女带着一盘泡菜走进了卡尔斯鲁厄的电报局，想要“发送”给她在拉施塔特的儿子。</p><p>有位男士带着一份“讯息”来到缅因州班戈区的电报局。操作员在电报键上操作完毕后，就把写有讯息的纸条摁到了钩子上。不了，这位客户投诉说，讯息根本没有被发送除去，因为他明明看到它还挂在钩子上。</p><p>讯息在过去一直被视为指一种有形之物，但这其实从来都是一种假象。</p></blockquote><p>电线在物理上也改变了都市乡间的景观，成为一种怪异的装饰。</p><blockquote><p>人们看到这些电线，不由想到它们所传递的重要的无形货物。使仁罗伯特·弗罗斯特写道：“他们在苍穹下架设线路，字词不论是敲出来还是说出来/在上面奔走时都将如思绪般静寂无声。”</p></blockquote><p>电线在建筑中找不到相似之物，在自然界中也难寻类比。苦心寻找比喻的作家们想到了蛛网以及迷宫。于是新的词语出现了：网络（net-work）。就如同人类的神经网络一样。</p><h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><blockquote><p>在多种意义上，使用电报就意味着用编码(code)书写。</p></blockquote><h2 id="何谓编码"><a href="#何谓编码" class="headerlink" title="何谓编码"></a>何谓编码</h2><p>曾经的人们视莫尔斯电码为一种字母表，但后来人们意识到了它与字母表的不同。它并非是用符号（字母）表示声音，而是用符号（点与划）表示符号（字母）。</p><p>用一种抽象表示另一种抽象，这就是编码。而这，也是数学的本质所在，将意义从一种抽象转换为另一种抽象。</p><h2 id="电报时代的编码"><a href="#电报时代的编码" class="headerlink" title="电报时代的编码"></a>电报时代的编码</h2><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><blockquote><p>使用编码书写出于两种密切相关的动机：为了保密以及为了简明。</p></blockquote><p>前一种需求自古以来便存在，尤其在政治上，“凯撒密码”的渊源便是一个很好的例子。后一个例子则可能是经济社会的发展带来的。电报的成本同文本量成正相关这一特点，迫使人们想出应对的方案。当时，出现了被称为“电报体”的新文风。（网络时代也天天有新文风出现，不过原因则大大不同了）</p><blockquote><p>电报体让任何形式的礼貌说法都无容身之地。“May I ask you to do me the favour”这么一句话，传输五十英里的距离就要六便士。这个可怜的人要把类似温文尔雅的形容词无情地砍掉多少，才能将他的信函开支降到一个合理的水平呢？</p></blockquote><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>信息压缩与加密，正如它们今后将紧密联结在一起，在当时也是同时为人们所采用的。</p><blockquote><p>一套典型的编码系统是用词典中的字词指代整个短语，并将它们按语义和字母的顺序加以排列。比如，所有以B开头的词汇事关面粉市场：baal表示“今日交易量小于昨日”；babble代表“市场景气”；baby代表“西部市场稳定，国内和出口需求中等”；如此等等。当然，这就有必要让发送方和接收方使用同一个词典。</p></blockquote><p>这些方案既非常有趣，也能带来实实在在的经济效益。它们使得密码学，在一定程度上，成为人民群众所喜闻乐见的事物。（可不是嘛，今天也是这样）各式各样的码本层现叠出，显示出编码的生命活力。</p><blockquote><p>密码学一度是，一门隐秘的技术，其奥秘通过私人手稿的方式传播，就和炼金术一样。但如今，编码制作通过印刷术被放到了光天化日之下，激起大众无尽的想象。</p></blockquote><p>这些码本有哪些类型呢？上面提到的“词面变换”是一种，还有“凯撒密码加强版”，“首字母哈希”（将“my health is improving”简写为“mhii”，学生群体常常以这种编码来加密同学名字）。当然，随便的加密还不足以使得成本最小化，而要做到这点，则需要更专门的分析，从数学上，从语言学中，这吸引了许多痴迷数据的人们。</p><blockquote><p>对于编目员、分类员、文字高手、数字命理学者，以及各种各样的收集癖者来说，电报为他们提供了广阔的用武之地。</p></blockquote><p>比如，威廉·克劳森·图厄在其《通用商业电报编码基础》中对短语进行了分组，通过关键词。这不仅是词典编纂学上的奇特成果，也成为了解当时社会的别样史料，同时也能够成为写作的素材来源。</p><h3 id="缺漏"><a href="#缺漏" class="headerlink" title="缺漏"></a>缺漏</h3><p>然而，编码并不总是好的，它虽然简洁且高效，但对冗余的抹除也使得其几乎没有容错性。一个拼写的错误，就可能使整句话的意义截然不同。</p><h2 id="密码学与信息论"><a href="#密码学与信息论" class="headerlink" title="密码学与信息论"></a>密码学与信息论</h2><p>密码的历史相当久远，并不仅限于信息领域，它也可以通过化学方式制造。在信息领域，古典密码学的经典例子有凯撒加密、栅栏加密。</p><p>近代以来，约翰·威尔金斯在一本小册子中，从思辨与数学的角度对密码学，对编码展开了一些思考。他使用有限的符号集来表示整个字母表，通过组合的方式。在书中，他最后引入了一个二元编码：A对应于aaaaa，B对应于aaaab，C对应于aaaba……“两个符号，五个一组，会产生三十二种<strong>差异</strong>”。</p><blockquote><p>任何的差异都是一种二元选择，而任何的二元选择都可以拿来表达思想。在这里，在这份1641年不为人知的匿名专著中，信息论的核心思想浮出了人类思维的表面，却像土拨鼠一样看见了自己的影子，于是又沉没下去，消失长达三百多年。</p></blockquote><h2 id="当时密码学相关人物"><a href="#当时密码学相关人物" class="headerlink" title="当时密码学相关人物"></a>当时密码学相关人物</h2><p>首先是爱伦·坡，他热爱秘密，喜欢神秘，“心灵就是一个密码；它所提供的密文越短，破解起来就越艰难”。</p><blockquote><p>对于爱伦·坡来说，密码制作并不仅是一种对历史或技术的热情，而是一种执着，反映了他对人类是如何与世界交流的认识。</p><p>对他而言，密码是科学和神秘学之间、理性头脑和智者之间的桥梁。密码分析要求具备敏锐的头脑和特殊的精神力量，完全可登大雅之堂，值得在学院中传授。</p></blockquote><p>当然，维多利亚时代最为杰出的密码分析者还是Charles Babbage，他指出：“解密艺术最奇特的一个特性就是，每个人都坚信，自己可以构造出一种无人能解的密码。我也注意到，一个人越聪明，他的这种信念植根就越深。”他破解了当时被誉为“不可破译的密码”——维吉尼亚密码。“如他在其他工作中所做的，他在其中也应用了代数方法，以方程的形式表达密码分析过程。”</p><h2 id="形式逻辑-待补充"><a href="#形式逻辑-待补充" class="headerlink" title="形式逻辑[待补充]"></a>形式逻辑[待补充]</h2><p>为什么在编码的部分提形式逻辑呢？</p><hr><p>开始于2019.04.26</p><p>完稿于2019.05.01</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将一个难解之谜比作另一个难解之谜……&lt;/p&gt;
    
    </summary>
    
    
      <category term="阅读" scheme="https://nessoffice.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>【简牍提要】信息简史：将思想的力量注入齿轮机械</title>
    <link href="https://nessoffice.github.io/2019/04/26/The_Information-CH04/"/>
    <id>https://nessoffice.github.io/2019/04/26/The_Information-CH04/</id>
    <published>2019-04-26T06:56:42.000Z</published>
    <updated>2019-04-26T09:49:20.413Z</updated>
    
    <content type="html"><![CDATA[<p>Charles Babbage与Ada Byron，在蒸汽时代瞥见计算机的才子佳人。</p><a id="more"></a><h2 id="时代背景：数表"><a href="#时代背景：数表" class="headerlink" title="时代背景：数表"></a>时代背景：数表</h2><blockquote><p>埃利·德容古在1762年曾写道：“喔，欣喜若狂的算数家啊！他那么容易满足，既不求锦衣华服，也不求香车宝马。”</p></blockquote><p>德容古本人则以异于常人的热情编纂了三角形数的数表，其以计算准确、精细而臻于完美而为人所称道。</p><p>除去这些“纯粹”的作品，数表也曾有过广泛而实用的实际用途：三角函数表、平方表、立方表、平方根表、倒数表、星历表、利息表……哥伦布就曾因星历表成功脱险。</p><p>虽然大部分数表实际只需要一些公式，但编写数表有着巨大的经济价值。预先计算加上数据存储加上数据检索的成本往往比临时计算的成本来得低。而在当时，“计算员”是个特殊的职业，显示了计算的成本之高。</p><p>17世纪，对数的发明（其发明者是纳皮尔）大大降低了乘法的复杂度，它将乘法转换为加法，给黑暗世界中的计算员们带来了福音。书中对于这项伟大的发明做出了精辟的论述：</p><blockquote><p>在纳皮尔的观念中，存在着一种类比：差之于比，就如同加法至于乘法。这样他的思考从一个维度跨越到了另一个维度，从空间关系跨越到了纯粹的数的关系。通过将这些刻度并排放置，他为计算者找到了一种将乘法转变为加法的实用方法——实质上，这是把一项困难的人物调低为更容易的任务。在某种意义上，这是一种翻译，或一种编码。计算者通过查检对数表，将自然数编码成了对数，而对数表就是码本。在这种新的语言中，计算变得容易了：加法代替了乘法，乘法则代替了求幂。计算完成之后，需要再把结果译回自然数的语言。当然，纳皮尔当时不可能从编码的角度来考虑这个问题。</p></blockquote><p>对数应用广泛，它使得利率的计算成为可能，它也让开普勒凭借更为精确的数据提出了新的观念，从而推动了天文学的发展。</p><h2 id="Charles-Babbage"><a href="#Charles-Babbage" class="headerlink" title="Charles Babbage"></a>Charles Babbage</h2><h3 id="总体印象"><a href="#总体印象" class="headerlink" title="总体印象"></a>总体印象</h3><p>Babbage是个非常难下定义的人，他聪敏过人，有着各个方面的才干，但这些才干很难归到具体的门类中。他绝对称得上是怪才，也是个有趣的人。</p><p>Babbage的兴趣爱好（不完全）：破解密码，开锁，设计灯塔信号系统，观察树木年轮，改善邮政，观察火车，制造大头针……</p><blockquote><p>一个美国人赞颂道：“对于任何会引起其孩童般纯真好奇心的事物，他都渴望探求其中的原理，他甚至会将各种玩具大卸八块以搞清它们如何运作。”</p></blockquote><p>Babbage对数有着狂热的喜爱，他汇编过动物常数表，四处统计家畜的呼吸及心跳，统计了各种语言中双写字母出现的频率，甚至为平面玻璃窗的破裂区分了四百多种原因……他自己也说：</p><blockquote><p>“数有诸多迷人之处，俗人的眼睛无法看见，只有那些可敬的、孜孜以求的艺术之子才能发现。”</p></blockquote><p>虽说Babbage自身有着独到的人格魅力，但他最为世人所知的还是他的差分机。它曾被遗忘，如今又被从历史的遗迹种重拾。差分机，一如Babbage的狂热爱好，和数字息息相关。</p><blockquote><p>之后，Babbage的机器渐渐被人遗忘，在发明史上湮灭无闻。再到后来，它才又被重新发现，其重要意义得到了追认，犹如灯塔在历史长河中熠熠生辉。</p></blockquote><h3 id="青年时代"><a href="#青年时代" class="headerlink" title="青年时代"></a>青年时代</h3><p>除去对机械的爱好外，Babbage亦热爱数学，而在三一学院中失望地发现导师不如自己。在英法交战的拿破仑时代，剑桥的数学相较欧洲大陆已落后不少。尤其牛顿的巨大影响力成了学生们挥之不去的阴影。</p><blockquote><p>然而他们（牛顿、莱布尼茨）各自提出了互不兼容的符号系统，也就是不同的数学语言。而在实际工作中，这种表面上的差异会比实质上的共性更为紧要，毕竟符号和算子才是数学家们天天要面对的。</p></blockquote><p>Babbage也常被语言吸引过去，他也曾尝试发明一种通用语言，但无可避免地受到巨大的阻力而失败了。（因为存储和取值的问题？）</p><blockquote><p>尽管如此，他仍然认为语言是一种人类可以发明出来的东西。在理想情况下，语言应该加以理性化，成为可预测的和机械的，就如同齿轮必须啮合。</p></blockquote><p>Babbage身边多是能与之开怀畅饮或是打惠斯特牌赌每分六便士的朋友。他还搞了个灵异俱乐部，搞了个“精神健全”俱乐部，当然，也有正经的“在身后留下一个更美好的世界”的解析社。</p><p>据Babbage自己的说法，正是在解析社中面对对数表之时，他想到了差分机的可能性。</p><h3 id="差分机"><a href="#差分机" class="headerlink" title="差分机"></a>差分机</h3><p>蒸汽时代驱动力的强大，与计算对数表的繁琐相比，二者简直不是在同一个世纪。为将人类从枯燥中解救出来，Babbage希望将强大的蒸汽之力应用到思考之上。</p><blockquote><p>这时，数就是原料，之后支架滑行、齿轮转动，大脑的工作就这样完成了。</p></blockquote><p>在没有“输入”也没有“输出”概念的时代，已经有了帕斯卡和莱布尼茨的算盘，但它们只是一种被动型的寄存器，而非计算机，不符合Babbage心目中的“自动化”观念。</p><p>当时，鼠标中存在着一些小小的瑕疵，于是出现了勘误，出现了勘误的勘误，又出现了勘误的勘误的勘误，“混乱雪上加霜”。这些都暗示了计算员的不可靠，与“自动化”计算的必要性。</p><p>于是，Babbage设计了差分机，通过差分来程序化且简单地计算高阶的多项式。这在系协商也较容易模拟，但考虑到进位，计算时间就是个不得不纳入考量范围的问题。这里头又有着很多很复杂的东西得考虑。</p><p>不管如何，因为他的个人魅力，因为他广博的学识与深邃的思想，也由于他传奇的经历和有趣的性格，他在人们中取得了信任也取得了肯定（不过主要不是肯定其学术思想）。于是，Babbage在英国的财政大臣中成功圈到了第一桶金。</p><blockquote><p>到了1823年，英国财政部和财政大臣终于也开始对这个发明产生了兴趣。他曾承诺“对数表将如同马铃薯一样便宜，”这样的诱惑他们如何能抵挡？对数表可是能够挽救船只的。就这样，财政部的首脑批准了第一笔一千五百英镑的拨款。</p></blockquote><p>就这样，差分机的工程开始了。但它不可控地变得无比庞大而复杂，要求的拨款也越来越多。与Babbage在社交场上的如鱼得水正相反，差分机进展的举步维艰既使Babbage也是政府人员失去了信心。不过，尽管差分机已被叫停，Babbage的梦想并未终止，因为它早已转变方向，上升到了新的高度。</p><h3 id="分析机"><a href="#分析机" class="headerlink" title="分析机"></a>分析机</h3><p>所谓分析机，实则是一种通用的数学计算机，相较差分机，它的应用范围要广得多。</p><p>在欧洲大陆着手于分析机的工作时，Babbage与Ada展开了密切的合作。在这段合作中，Ada是真正的主导者，尽管她还年轻，尽管Babbage才是社会名流。Ada强调分析机应做的是运算而非计算（形式逻辑？？），她给出了诗意的描述，也设想了实际的应用：计算伯努利数。</p><p>在当时，Ada就提出了<strong>递归</strong>的算法，他们也看到了<strong>变量</strong>的重要性。在当时，他们的语言是store，mill，后来它们变成了内存与cpu。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><blockquote><p>的确，Babbage的兴趣广泛，似乎偏离数学甚远。但其实他的诸多兴趣之下还是隐藏着一条主线，只是他的同时代人甚至他自己都没有察觉。他的种种追求无法归入任何一个范畴，更准确地说，任何一个当时已有的范畴。他真正的研究主题是信息，是信息的通信、编码、处理等。</p></blockquote><p>在这条主线下，Babbage通过构造词典来破解密码，从树木年轮上看到自然对历史的编码，看到了“通话管”的未来，也在乘蒸汽机车时意识到通信速度慢于移动速度的危险……</p><p>分析机无疑是个失败的发明，被人们所遗忘，而又成为重新发现的宝藏，予人以时代错位的感觉。</p><blockquote><p>Babbage的机器的初衷是生成数表，但到头来，其现代形式反而导致数表被废弃。Babbage可曾预计到这一点呢？不过，他的确曾好奇未来的人们将会如何利用他的远见。按他的猜测，至少还要再过半个世纪，才会有人再次尝试构造一台通用计算机器。而事实上，过了将近一个世纪，这项工作所必要的技术基础才准备就绪。</p></blockquote><p>Babbage相较Ada更“谦逊”一些也更“好玩”一些。他从字面上理解“知识就是力量”，相信未来的科学将转向更为无形的电力，相信计算科学在未来将大踏步地前进。他也这样写给后人：</p><blockquote><p>如果有人在未被告诫以我的前车之鉴的情况下试图尝试这项了无指望的工作，并通过完全不同的原理或更简化的机械手段而成功实现了一台可与整个数学分析部分相当的机器，那么我不怕把自己的名誉托付给他，因为他肯定会完全理解我当年努力的性质及其成果的价值。</p></blockquote><p>让我们以这句话结束这一节。</p><blockquote><p>在他去世前几年，他曾对一个朋友说，他乐意放弃剩下不管多少可活的时日，只愿能在五个世纪后的未来生活三天。</p></blockquote><h2 id="Ada-Byron"><a href="#Ada-Byron" class="headerlink" title="Ada Byron"></a>Ada Byron</h2><p>Ada是”爱的结晶，——尽管她生于苦难，长于动乱“，他的父亲这样写道。</p><blockquote><p>Ada是个神童，在数学方面天资聪慧，并受到了家庭教师的鼓励。她在绘画和音乐方面也有天赋，极具创造力，但在内心也极为孤独。在十二岁时，她开始着手发明一种飞行工具……</p></blockquote><p>Ada在17岁时与Babbage相识，在差分机试验品的展览会上。</p><blockquote><p>“她对于数学之美和抽象的热情，尽管过去在历任家庭教师那里得到了零星的满足，在这时却变得更加不可抑制。然而，她的热情却无处释放。”</p></blockquote><p>Ada在19岁时嫁给了一位通情达理而前途无量的贵族William King，并在不久后成为伯爵夫人。平日里，她练习竖琴，参加舞会，感受着上流社会的气息还有科技的日新月异。她时常情绪低落，也时常受疾病缠身。她崇拜自己的丈夫，但也将精神生活的一部分分给了Charles Babbage。</p><p>Ada有着近乎狂傲的绝对的自我肯定，她也有着与之相称的不屈的意志与超群的能力。她的函授教师是De Morgan，后者认为Ada的“这般能力”足以使之成为“原创性的数学研究者”。</p><blockquote><p>（以下摘自Ada写给Babbage的信件）</p><p>我的学习方式异于常人，因此我觉得只有一个异于常人的人才能教会我。</p><p>我希望你能记住我，我是指我对于数学的兴趣。</p><p>你知道，我生来就有点哲学家的气质，并且天生是个非常卓越的思考者。</p><p>（以下是分析机时代的信件）</p><p>我的头脑不是凡间之物，这一点时间将会证明。</p><p>没人知道我那瘦小的系统中潜藏着多少尚未被开发但几乎让人惊叹的能量和力量……</p><p>我觉得，你的先见之明和预见所有可能情况（而不论其可能性大小）的能力不及我的一般……</p><p>我不认为，我父亲作为诗人（事实上或原本可能达到）的成就可以与我将要作为分析师（以及玄学家——这两者在我身上并行不悖）的成就相提并论。</p></blockquote><p>Ada所感兴趣的不只是数学。她也会迷上游戏，并思考其通解。她肯定自己无与伦比的想象力，也圣徒般地相信自己肩负着一种莫名的神圣的使命。她的一些洞见独具只眼，而从这些论述来看，她确实称得上一名哲学家。（科学哲学？）</p><blockquote><p>关于想象力，我们已经谈了很多。我们谈论诗人的想象力、艺术家的想象力，诸如此类；但我倾向于认为，总体而言，我们并不十分明白我们究竟在谈论什么……</p><p>我相信自己拥有一套非常独特的特质组和，恰好让我适合成为一名非凡的发现者，去揭示自然隐秘的真相……这个信念很久以来就一直挥之不去，而慢慢地我也已经接受了这一点。</p></blockquote><p>Ada后来成了一名家庭教师，独自研究欧几里得。不过她还是忘怀不了Babbage与他那“所有机器当中的珍宝”。</p><p>Ada最终死于子宫癌，较Babbage更早过世，她被葬于自己父亲的身边。在她知晓自己时日不多后，她这番向母亲写道：</p><blockquote><p>人们常说“<strong>将来之事会提前投下其阴影</strong>，可是它们有时不也会提前投下其<strong>光芒</strong>吗？”</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Charles Babbage与Ada Byron，在蒸汽时代瞥见计算机的才子佳人。&lt;/p&gt;
    
    </summary>
    
    
      <category term="阅读" scheme="https://nessoffice.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>【简牍提要】边缘人偶记</title>
    <link href="https://nessoffice.github.io/2019/04/25/Biography-Xu_Guoqi/"/>
    <id>https://nessoffice.github.io/2019/04/25/Biography-Xu_Guoqi/</id>
    <published>2019-04-25T13:29:42.000Z</published>
    <updated>2019-04-26T09:49:12.811Z</updated>
    
    <content type="html"><![CDATA[<p>之前zwk说他清代文化史的助教很是推崇这本《边缘人偶记》，我便对其也有了一番兴致。不过扫了一眼评论，看到“利己”“精英”一类的词，顿时兴趣大减，觉得作者的三观可能和我有所抵牾。再来，这标题看着不是很怎么样。然而近来又陷入了“有书不想读”的困境，便想着换换口味。恰巧zwk又把他们助教的强烈推荐讲了一遍。草草翻完，总体感觉还是很不错的，虽然里头的不足相当多。</p><a id="more"></a><h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a><strong>缘起</strong></h1><p>之前zwk说他清代文化史的助教很是推崇这本《边缘人偶记》，我便对其也有了一番兴致。不过扫了一眼评论，看到“利己”“精英”一类的词，顿时兴趣大减，觉得作者的三观可能和我有所抵牾。再来，这标题看着不是很怎么样。然而近来又陷入了“有书不想读”的困境，便想着换换口味。恰巧zwk又把他们助教的强烈推荐讲了一遍。草草翻完，总体感觉还是很不错的，虽然里头的不足相当多。</p><h1 id="边缘记"><a href="#边缘记" class="headerlink" title="边缘记"></a><strong>边缘记</strong></h1><p>看到“边缘人偶记”这个题目的时候，我的第一感觉是“边缘/<strong>人偶</strong>/记”，侧重点在“人偶”上，即一种不自由的、难以承受的、为他人所左右的地狱般的生存状态。看着看着才明白，是“<strong>边缘人</strong>/偶记”，作者给自己贴上了边缘人——在国别的边缘、文化的边缘，研究着“边缘化”的课题等等，这样的标签，虽然说得过去，但不是很符合“边缘人”的语义——它强调的是一种无法融入的、孤独无依的状态。</p><p>但孤独的边缘在作者的语境中占的比重非常小。徐国琦并非没有依托，他只是认为自己没有归属，或者说自己对于文化认同有着疑惑。他”自认“国际公民，能接受各样的饮食文化，在各类地方呆过，研究着“边缘”的学问。这里的“边缘”，更多有一种“交集”的意味。在这层意义上，作者站在了一个相当跨越相当融合相当有高度的位置。</p><h1 id="读书记"><a href="#读书记" class="headerlink" title="读书记"></a><strong>读书记</strong></h1><p>这本书的第一部分，于我看来，相当的乏味。作者对于赤贫的、愚昧的农村中自己的童年生活怀有强烈的反感与不满，也正是这强烈的不满驱使他努力求学，以走向外面的世界。尤其是在记读初中、读高中、读本科的部分中，作者的利己色彩与对精英主义的肯定表现得很明显（不过往好了说，这也算是“毫不做作吧”），这看得我十分的难受。（事实上，可能是先入为主的影响吧，第二次看这章对作者的好感多了很多，不过一个作者能通过作品让原本不喜欢自己的人喜欢自己，还是很厉害的）</p><p>但是到了做研究的部分，我又有了眼前一亮的感觉：徐国琦的学术观点相当犀利，他对他人作品的见解很多也都是一阵见血。徐国琦的著作确是可以称得上“边缘”的——它们都是另辟蹊径而能有所发现的作品。而在追寻“文化认同”还有“共有历史”的角度看，其著作的思想也是处于“边缘”的。</p><p>出的五本书，三本讲一战，但角度分别是从华工、整个中国以及亚洲分别切入的；两本讲中国，讲中国和美国的共有历史，讲中国和奥运会的历史。这些研究的角度都偏向国际化而非坚持东西方中心论。这些专著虽然我并未看过，但从其描述看来似乎值得一读。</p><h1 id="人物记"><a href="#人物记" class="headerlink" title="人物记"></a><strong>人物记</strong></h1><p>”师友记“记的是作者身边的学者朋友或是老师，讲了非常多自己的所闻所感，很是生动。（王玉华那章除外）</p><p>“人物记”记的是一些传奇性的而与作者之间来往的前辈。通过其描述，对费正清、霍布斯鲍姆、许地山并不熟悉的读者能够对其传奇人生有一些感性的认识。</p><p>费正清：在学术界有着无与伦比的历史地位，单枪匹马地建立了一个学科，站在改善两国关系的潮头上。</p><p>霍布斯鲍姆：坚定的马克思主义信仰者，长于叙述，在三流学校一鸣惊人。</p><p>许地山：宗教研究者，文学家，其作品对人们在思想上有影响。为港大招揽了人才。</p><h1 id="内自省"><a href="#内自省" class="headerlink" title="内自省"></a><strong>内自省</strong></h1><p>①这本书非常口语化，文章的水平似乎没有徐国琦自己讲的那么好。尤其是评价人物的语段，还有称颂，特别单一。（感觉不是特别有诚意）</p><p>②教书记竟然不讲自己的教学，搞什么呢！结果风格还是和其他章节一样吗。</p><p>③书中穿插着许多对于世事的评议，尤其在关于国内学术风气的方面，还是比较中肯的。但也比较零散。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前zwk说他清代文化史的助教很是推崇这本《边缘人偶记》，我便对其也有了一番兴致。不过扫了一眼评论，看到“利己”“精英”一类的词，顿时兴趣大减，觉得作者的三观可能和我有所抵牾。再来，这标题看着不是很怎么样。然而近来又陷入了“有书不想读”的困境，便想着换换口味。恰巧zwk又把他们助教的强烈推荐讲了一遍。草草翻完，总体感觉还是很不错的，虽然里头的不足相当多。&lt;/p&gt;
    
    </summary>
    
    
      <category term="阅读" scheme="https://nessoffice.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>【浮生掠影】设计思维讨论课 发散思维工作坊</title>
    <link href="https://nessoffice.github.io/2019/04/18/Design_Thinking-1/"/>
    <id>https://nessoffice.github.io/2019/04/18/Design_Thinking-1/</id>
    <published>2019-04-18T02:05:59.000Z</published>
    <updated>2019-04-26T03:40:30.746Z</updated>
    
    <content type="html"><![CDATA[<p>回形针有多少种用途？</p><a id="more"></a><p><strong>试问：回形针有多少种用途？</strong></p><p>政治：作为外交赠品（工业文明的代表产物，国家现代化进程中的重要见证），联系“回形针外交”</p><p>经济：一般等价物；磨成粉作保健品</p><p>历史：第一手资料</p><p>地理：模拟等高线</p><p>信息：编码，联系“回形针码”和“回语言”</p><p>卫生：掏耳朵、扣指甲</p><p>造型艺术：装饰；摆成其他形状</p><p>音乐：敲击</p><p>军事：戳人眼球（恐怖游戏里可以搞搞这种套路，效果可能比剪刀要好一些）</p><p>物理：油罐车防静电；降温；水果电池</p><p>化学：（铁）湿法炼铜，置换氢气，催化剂，等等</p><p>……</p><hr><p>从回形针本身性质出发，更能得到的是下面若干项；</p><p>而从“用途”出发，联系不同的学科，则可得到上面的若干项，至少我感觉更有趣一些。</p><p>这里可以采取双向的思路。</p><p>具体到一个在一个小领域中回形针有何用途，这也是一个思维发散的过程，可以递归地重复上面的步骤，直至得到“原子化”的难以再细分下去的概念，这时候就可以开始收敛思维了。（dfs到最后一层而后返回）</p><p>但还有很多清奇的思路并不好归类，如给轮胎放气、做书签等。正因其难以穷举，能够产生富于创造性的结果，思维发散才这样的有趣。</p><hr><p>2019年3月28日。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;回形针有多少种用途？&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="https://nessoffice.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="设计" scheme="https://nessoffice.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>【图灵之路】踏过的坑</title>
    <link href="https://nessoffice.github.io/2019/04/16/Programming_Pits/"/>
    <id>https://nessoffice.github.io/2019/04/16/Programming_Pits/</id>
    <published>2019-04-16T06:12:59.000Z</published>
    <updated>2019-04-26T03:40:36.463Z</updated>
    
    <content type="html"><![CDATA[<p>伤痕，与并不美好的记忆……</p><a id="more"></a><h1 id="2019-04-15"><a href="#2019-04-15" class="headerlink" title="2019-04-15"></a>2019-04-15</h1><p>Merge的函数题，没有保存变量就直接elem[i] = elem[j++]，导致数据丢失。从22：06：04到23：26：41，提交共十次。</p><h1 id="2019-04-16"><a href="#2019-04-16" class="headerlink" title="2019-04-16"></a>2019-04-16</h1><p>大数阶乘，压位做法。在j从0到len遍历的前提下把res[j] *= i和res[j+1] += res[j] / MOD混在一起写，这样的运算顺序是有误的。从1：36到1：52。</p><p>最近点对问题。将Points_x与Points_y混淆以致造成了难以发觉的错误。疯狂对拍但几无成效，在四个点的情况下还是直接调试更能发现问题。一开始在Merge中使用了n导致超时。从18：30到20：00再到22：00。</p><p>文件名的问题倒是一下就能发现。</p><h1 id="2019-04-17"><a href="#2019-04-17" class="headerlink" title="2019-04-17"></a>2019-04-17</h1><p>有序序列中位数问题，一直纠结于二分，没想到顺序一下就成。思路没打开。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;伤痕，与并不美好的记忆……&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="https://nessoffice.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>【浮生掠影】2019 浙大校赛 BY NESS @ hash</title>
    <link href="https://nessoffice.github.io/2019/04/14/TuSimple-1/"/>
    <id>https://nessoffice.github.io/2019/04/14/TuSimple-1/</id>
    <published>2019-04-14T11:53:37.000Z</published>
    <updated>2019-05-01T10:32:34.740Z</updated>
    
    <content type="html"><![CDATA[<p>这是今年打的第一场比赛，成绩咱就不管了，总体玩的还是比较开心的。感觉光阴没有虚度，感觉前方还有着希望，而这就够了。</p><p>作为一次经历，一次体验，打比赛在生命中自然是有其价值的，它是一个节点，串起了过往无数日夜的辛劳准备与或狂喜或迷惘的期望。它不一定是结果，也不代表旅程的结束，以我当前的追求来看。它只是一个中点，是生活的增味剂，是另一种形式的酒与诗歌。无用，然而有趣。</p><p>说起比赛，首先想到的还是以往略显单调但也有滋有味的高中生活。想起以前翘课出去打NOIP，参加清华的不知什么考试，还有寒暑假在杭州在上海在环中的日日夜夜。关键并不在成就与从中得到的对自我的肯定，虽说这也是较重要的一环。我更喜欢的是合法翘课的感觉，喜欢的是纯粹出去玩这样一种心境。有一种逃离的快感，叛逆的甜蜜。而我所逃离的是什么呢？是日常？是普通？抑或无趣？在这层意义上，今天我仍然生活在高中时代的心理状态中。</p><a id="more"></a><h1 id="随想"><a href="#随想" class="headerlink" title="随想"></a><strong>随想</strong></h1><p>这是今年打的第一场比赛，成绩咱就不管了，总体玩的还是比较开心的。感觉光阴没有虚度，感觉前方还有着希望，而这就够了。</p><p>作为一次经历，一次体验，打比赛在生命中自然是有其价值的，它是一个节点，串起了过往无数日夜的辛劳准备与或狂喜或迷惘的期望。它不一定是结果，也不代表旅程的结束，以我当前的追求来看。它只是一个中点，是生活的增味剂，是另一种形式的酒与诗歌。无用，然而有趣。</p><p>说起比赛，首先想到的还是以往略显单调但也有滋有味的高中生活。想起以前翘课出去打NOIP，参加清华的不知什么考试，还有寒暑假在杭州在上海在环中的日日夜夜。关键并不在成就与从中得到的对自我的肯定，虽说这也是较重要的一环。我更喜欢的是合法翘课的感觉，喜欢的是纯粹出去玩这样一种心境。有一种逃离的快感，叛逆的甜蜜。而我所逃离的是什么呢？是日常？是普通？抑或无趣？<strong>在这层意义上，今天我仍然生活在高中时代的心理状态中。</strong></p><h1 id="热身赛"><a href="#热身赛" class="headerlink" title="热身赛"></a><strong>热身赛</strong></h1><p>日程的话，早上有个热身赛，九点半开始。在此之前七点半至九点是所谓检录。下午一点正式开赛，打四个小时，直至五点。这样看下来，大半天都被打掉了。晚上其实也主要在想这回事，会有“如果这题做出来就没有遗憾啦”，诸如此类的想法。于是这约莫就是这一天的主旋律了。原先zc嫌时间太久想翘掉的，但见xn没翘也就没翘了。谢天谢地，如果他们两位翘掉了估计我就只能<del>对着屏幕两行泪了</del>跟着翘了。</p><p>虽说这是校赛，但我们对待得真挺随便。没碰代码一个月的我也就随便搞了点板子，没碰代码一个月的zc赛前一天开始调环境。赛前一个月基本完全没准备。赛前一天才开始和xn交流板子行不行。有些过于娱乐了？毕竟经验过少，但毫不慌张并调好心态或许比瞎准备一通发现自己方向错了来得有益，于我看来。</p><p>早上的热身赛真的挺热身，zc花了一大半时间在配环境：sublime、visual studio、code，一个个都试过去了，花了好长时间嘞。还下了大数的模板，也测试了一下。然而下午居然重启电脑了，题目也收回去了！<del>我妹子还没认全呢555</del></p><p>里面有个C题很好玩。就是有十二张图片（ACG作品中的<del>妹子</del>人物），二十四个名字，把名字和图片对应，输出，没有输入。名字都是假名表示的，图片也都是同人画师的作品，搜图难度不小。估计是颜色的问题，不管什么百度搜图谷歌搜图效果都不能看。在p站上查画师效率也不是很高，于是只得慢慢搜名字（<del>一个一个妹子认识过去</del>）。有点烦的一点就是有些名字搜不到，不管在萌百上还是其他网站上，这就会让人比较泄气，怀疑是否漏了谁，从而对答案正确性与自己的努力产生怀疑。搜了一些名字，发现自己御宅指数还真是低，敏感性也比较差，看到”Tohsaka Rin“时脑海中完全没有图象。东方的人物我也认不全。这可能还跟接触的体系有关系吧，我是没啃过生肉的，知道的东西也都很表层，在欣赏ACG作品缺乏联系观，也缺乏对<del>妹子萌点</del>人物特征的宏观认识，对于作画等等的认识也实在是肤浅。想想自己只是个假的肥宅，有些假的难受。</p><p>A题的话，让你判断一个数列是不是peak sequence，简单模拟即可。但我忘掉了和peak sequence相关的知识欸。我好弱啊。</p><p>D题是顺序买书，已知书的总数、每本书的价格和买的本数，买书的策略是贪心，求最大携带的钱数。一开始想能否二分答案，但想想不行，具体哪里不行就讲不清了……之后想到贪心的思路：把前k本都买下来，剩下的钱再不足买剩下任何一本书，那么这个钱数是符合要求的，而且超过它就不符合要求了，可行！就是不知道这个思路该置于知识网络的哪个位置。我对于算法的认识，在微观层面，还是非常容易搞混且相当想当然的，这是一个得改的毛病。</p><p>B题是给出一个括号序列，给出了一套生成序列的规则，让你求第k个序列从第l项到第r项有个多少‘(’。这题当时没人提交（估计都在查C题吧），我初步想法是这样的：序列是无穷的，故要在一个周期内界定它，而后面的序列和前面的序列又可以通过set判重来得到”序列的周期“（二维的概念啊，有意思）。总之就是有点恶心的模拟了，加上模乱搞不知行不行得通……无法实践验证想法，就不细想了。</p><h1 id="比赛本身"><a href="#比赛本身" class="headerlink" title="比赛本身"></a><strong>比赛本身</strong></h1><p>想做题的话，戳<a href="http://acm.zju.edu.cn/onlinejudge/searchProblem.do?contestId=1&amp;titlefrom=0&amp;authorfrom=0&amp;sourcefrom=0&amp;query=The+19th+Zhejiang+University+Programming+Contest+Sponsored+by+TuSimple" target="_blank" rel="noopener">这里</a>qwq。</p><p>比赛开始时还是有些紧张的，中午睡得也不咋样，总之不是特别有状态。开赛后首先看的是B题，而xn在看A题，zc在配环境。B题定义了一类“偶素数”，还有“偶合数”，让求给定的“偶阶乘”最多能拆分为多少个“偶素数”，本质上应该是$2^s || n!, s = \sum\limits_{i = 1}^ \infty \lfloor \dfrac{n}{2^i} \rfloor$的变形。但是数据量级是$10^{1000}$，不写大数不行。于是zc和xn讨论G的时候，我一直在打板子。这个板子是半年前的，记得当时减法没搞，就没管，不想除法里需用到减法，一下就慌起来了。还有大数比较等等也都没有写，心情就比较地烦躁。中间想到用java写，或者写二进制的大数，但都碰上了问题。临结束时瞎写了一通，不知哪儿出问题了。这题也便不了了之了。想来还是有些遗憾。</p><p>除去B题，我第二个看的是J题，当时已有队伍提交了。这题讲的是给定正数n，让找满足$x + n = y$的一组合数x，y，任意输出一组即可。我当时拍脑袋想想x=2n，y=3n不是满足条件嘛，但觉得这样过于简单了。和xn交流后也没发现问题，但交上去就是一个明亮的WA。为什么呢？是流输入的问题么？总之不会是数据范围的问题吧。搁了一会儿后，xn测试时候来了个“1”，输出“2 3”。很明显，错掉了。于是我只能尴尬地换成x=8n，y=9n，这才搞定。此时已经过去45分钟了。</p><p>不光J题开始没过去，E题一开始也卡在这了。背景就不讲了，总之水题一道，但水水的我们过也过不去，就比较烦。zc花了一些力气把dev调教对，然后测试了自己构造的数据没发现什么问题。此前有交流，此后有深思，卡了好一会儿呢。最后又是xndl敏锐地察觉到虽然输入是在$10^9$，即int范围内的，然而我们有用求和，之后规模可能会超，得换long long。果不其然，改了数据类型后顺利拿到了一血。</p><p>后面我看的题是I，涉及到逆元、平均数、方差、选子集，极端数据还达到了恐怖如$2^{40}$的规模。想来不推结论肯定TLE的，但有何结论呢？从没做过跟方差有关的题，对于子集也不知如何高效处理，只能是对着题干空着急，发呆。简单化简了一下方差，搞出来一个线代课上好像曾见过的矩阵，忽然又想道”正定二次型“这个名词，可又死活不知道接下去怎么办了。这题也就弃了。</p><p>其他题我基本没看了，状态很糟。zc主要是搞C，xn主要在搞A。C和A我都没看，听他们说前者是简单模拟，后者用搜索或许可以。然而都TLE掉了。于是zc又给C剪枝，剪一会，交一遍，TLE，然后略有所思又想出来一个剪枝，我打一会儿大数就得起来一下给大佬让座，很是有趣~xn的A也优化了一遍又一遍，最后想试试卡时，在语法上又折腾了老半天，可最后还是没弄出WA。我差不多在两个小时后就没有认真打的念头了。看看人家碗里的气球，互膜互黑，倒也不错。</p><p>于是只能凄凉地拎着三个气球回来了，其中一个被吹走了，一个气放掉了，还有个踩爆了。看着人家手中气球满得都溢出了，不由得感叹自己菜得就像被人家踩爆的气球，何其可怜，多么无助。</p><p>早上刷名单的时候发现wyh也参赛了，寻思人家肯定是solo的。最后在榜上果然赫赫有名，着实是厉害。膜了人家一波，好不愉快。</p><h1 id="现场赛与网络赛"><a href="#现场赛与网络赛" class="headerlink" title="现场赛与网络赛"></a><strong>现场赛与网络赛</strong></h1><p>比赛的形式在很大程度上对发挥会有影响。一直都不喜欢去机房，因为那边的环境，因为那里的键盘。对于这些我都很不习惯。讨厌配环境，讨厌看见稀奇古怪的错误，讨厌程序正确却跑不起来的无力感。<strong>在这类问题上，我一直不愿意走出自己的舒适区。</strong></p><p>此外，现场赛有很多额外的限制，比如不能查东西。查询一般只在对事物有一定认识时才会奏效。查算法一般都是无效的举动。查语法更频繁些，因为这些东西我记不住，而且我觉得它没啥思维深度。查到原题查到相关算法还是少数，是值得高兴的事情，比如之前的趣味C，比如寒假的网络赛中那个让我告别0AC的组合数取模的板子。</p><p>回来今天来。中间，大数的板子搞不出来，zc想用java试一试，但是在语法上就碰到问题了。连大数初始化都搞不起来，更不用谈运算了。事后这些东西一查便知，但当时就是搞不起来。最后xn想卡时，但#include<time.h>之后还是懵了好一会儿，直到在书上查到其用法。（虽然最后还是没有WAhhh）</time.h></p><p>开卷虽然看上去比闭卷更为轻松，但若是对知识体系没有明确的认识，往往只能又慌又无助地乱翻书，效率非常低下。故，在这样的限制下我们当怎么做呢？首先还是要搞清楚自己受了什么样的限制，提前做好准备，有所对策，才不至于在事后后悔。虽然在本次比赛我们也没有可以后悔的理由。</p><p>机房的键盘，真心是叫人难受，敲起来又慢，还没有快感。不过即便是如此，我也还是有需要反省的地方。打字容易出错，快捷键用得还不顺（尤其ctrl不会用），等等。这些相对思维是外部的事物，但做好了能起增益效果。一来是需要有提升的意识，意识到自己和键盘和自然语言间的羁绊还不够深；二来是要有科学的方法，归纳出哪些快捷键是能够提升效率的，归纳出自己在打什么词的时候特别容易出错，在此基础上有所提升。</p><p>最后是环境，这个东西真心无聊，我尤其讨厌。但这是很常见的问题，尽管我并不“喜欢”它，我仍然“需要”解决问题的能力。环境不光是指机器上编译、链接、运行等步骤，还关乎对于软件的熟悉程度。视图、快捷键，等等。一个视图没调出来，尤其对状态有一定影响，因为它将原本连贯的思路与预期切断了。不喜欢用dev，VC++，看着那些复杂的条条框框看得很难受，这些软件有做到以人为本么？作为普通用户（然而，它们本就不是为普通用户设计的），我觉得开发者，是有所不足的。（但是，今天仍有许多学校和教师鼓励使用这些老旧的产品，他们是否需要反思呢？）可既然大环境如此，我也便只能熟悉其架构而无法奢谈转变。如何熟悉呢？或许我需要在机房找找答案。</p><h1 id="合作与对抗"><a href="#合作与对抗" class="headerlink" title="合作与对抗"></a><strong>合作与对抗</strong></h1><p>程序设计的竞赛大抵有两类，一类时段较长，如各类开发比赛，动辄几个月的。另一类时段很短，ICPC是一个，还有像黑客马拉松呀，Game Jam啊，它们关注的是爆发力，竞技性更强些。zc说前者更能体现与赛者的能力，不过后者往往更加紧张刺激一些，打得有趣，看榜也有趣<del>，看别人满桌子气球的样子更有趣</del>。</p><p>而且往往来说呢，第一类比赛的“合作性”会更强些，而后一类的“对抗性”则占了上风。作为一名蒟蒻，我一向是喜欢“通力合作”的，高中时候每回数竞的模拟考都会参与大家的讨论。记得打NOIP前报了个不知什么网络赛，然后就和蒋哥一起合作了。题目今天不记得了，当时感觉和自己的能力还是在一个数量级内的，做得比较有成就感。和蒋哥分享看法，给他看自己的代码然后收到肯定的信号，一起感叹最后一个有多毒瘤。真的很好玩，很有意思，很开心。今天想来，还是宝贵的记忆呢。</p><p>NOIP倒是合作不了了，也就考完后简单谈了谈感受，谈了谈这个输出格式之恶心，谈了谈试卷对于ds之偏爱，其实其他“有意思”的考试考完也是这样的。坐着大巴，背着待会语文考试的答案，拖着辘辘饥肠，等待着原应是KFC结果是“江西小炒”的晚饭，回到期中考的轨道中。<strong>没有若有所失的感觉，只是在平静中，一个阶段已经结束了。</strong></p><p>ICPC倒是在对抗中也体现着合作的。有幸我们还能够交流，能够发现一些隐蔽的问题，也能得到更广的视野，在一定程度上。但是，交流也并不是件简单的事情，它甚至并不“自然”。不过，这些已经是下个标题的主题了。</p><h1 id="沉默与交流"><a href="#沉默与交流" class="headerlink" title="沉默与交流"></a><strong>沉默与交流</strong></h1><p>debug，往往来说，都是件孤独的事情，甚至可以说是反人性的。但是开题并不是孤独的，它代表着希望，虽然希望时常会转化为绝望。为了让希望成为希望，我们需要更全面更深入而非想当然的思考，在一定程度上，交流能做到这点。可交流本身也并不容易。先回顾一下当时吧。</p><p>我们开始的策略还是得当的，不同的人开不同的题，但之后的步骤，我认为我做得并不好。我有B题的思路，但我完全无法将其表述给队友，为什么？在向xn介绍J题的思路时，我用的语气是较为肯定的，绝对的，“2n肯定是合数”，这样的交流有效吗？后来xn开了A题，zc开了C题，我只“大致地”听了听他们的思路，而未对细节有深入的思考。非常失败。</p><p>交流的一方面是传递自己的想法，在这个过程中要尽量避免隐蔽的想当然的想法；另一方面，交流是关于聆听的，而非“听见”：对方的思路是如何展开的？他有什么可能的错误？他没提到什么？</p><p>在交流时，不应是你一句我一句并且交谈没有中心。二或三人交谈时，一方当作为领导者，把握着对话的小主题、中心问题。其他人需要发散思维的广度。提出尽可能多的解决方案，并对其做出一定深度的拓展。然后是围绕可行的方案收敛思维。如是反复。</p><p>对这个话题想的还不多，也没什么条理，先放着吧。</p><h1 id="补题时间"><a href="#补题时间" class="headerlink" title="补题时间"></a><strong>补题时间</strong></h1><p>弱鸡的我的代码在<a href="https://github.com/NessOffice/Sync_Code/tree/master/history/zju2019_SchoolMatch" target="_blank" rel="noopener">这里</a>QAQ，仅供参考。</p><h2 id="A"><a href="#A" class="headerlink" title="A"></a><strong>A</strong></h2><p>比赛时一直被数学题搞得状态不佳，A和C都没看。结果A是2019.04.21AC的，而C是2019.04.20AC的，放了好几天嘞。</p><p>A的大意就是给定一组男人一组女人，每个人都有身高和偏好，其中身高各不相同，偏好为0表示只和比ta矮的人匹配，偏好为1表示只和比ta高的人匹配。问什么样的匹配方案能使总配对数最高。</p><p>看上去有点像什么二分图匹配，也好像可以搜索解决，于是我就不大想做……认真看了看，感觉贪心可以搞，那就试试贪心吧！</p><p>先把所有人按身高排序，然后顺序检索。每时每刻检索到人都是“可匹配的人”中最矮的，如果ta的偏好是0，就可以把ta跳过了；如果ta偏好是1，看看后面第一个和ta匹配的人，配对之。（容易证明，这样的贪心保证了全局最优性，证明的话，考虑如果不是贪心的策略，就替换吧）这里用last[0]与last[1]分别维护上次贪心得到的男/女性的位置，即可保证检索与匹配的复杂度是O(n)，加上排序，O(nlogn)，可行。</p><p>但是自己写的时候有点想当然，last只开了一个。题目里的数据又特别小，没出问题，于是百WA不得其解，之后将自己的思路表述出来才发现这一问题，从中可见有效交流的重要性。</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a><strong>B</strong></h2><p>在4月的16号早上，我开始调整自己的大数模板。先是写了个python的数据生成器，并加了些自己构造的数据，然后是用python调出用以对拍的程序，再是重构（debug_fc.bat，整合了debug_BigNum_py.py等），使这个板子的结构更加清晰。之后加减乘除均通过了测试。在此之后，开始上B的代码，碰到段错误，之后是TLE。</p><p>看了看别人用python写的程序，可谓如梦初醒！我的思路是{ans += n / two;two *= 2;}，但是{n /= 2;ans += n;}完全能实现等价的操作。在数学上，二者是等价的；可是两者在计算上的复杂度并不等价！尤其我的大数除大数中用减法模拟取模或许会占掉很长的时间，而我局限在前一种想法中，没有拓宽思路，这十足是个教训了！另外，我没有在纸上继续推结论，而只是在脑袋里想想，这或许也是个不好但也难改的习惯吧。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a><strong>C</strong></h2><p>题意的话，是给定机器人的行为模式还有房间的结构，求机器人运行k步后捡了多少垃圾。具体不表。</p><p>初看似乎是模拟题，但是k可以高达10e18次，所以复杂度要么是min(f(n, m), k)，要么是O(k^1/3)这类。后者貌似在组和题里更有可能出现，我们就考虑前者吧，由剪枝降低复杂度。但是这个枝怎么减呢？</p><p>题目中的x由中间及其周边五点的值唯一确定，故这五点值若不改变而机器人停留在原位（即机器人什么都没做），它必将循环地无所作为。直接模拟k = 10e18的话，很大一部分时间都是耗在这上面的，所以这种枝一定得剪。</p><p>但光剪徘徊在原地的枝还不够。原地徘徊是一种自环，其他的路径也可能成环（比如，(2, 2) -&gt; (2, 3) -&gt; (2, 2)），要把这些也剪掉。怎么判断走的确实是环（即后面的路径与前面的循环）呢？只要看再走到同一点时ans有无改变即可：若无，则机器人从该点返回该点的路径中没有捡垃圾，也就是它接下来走的路将与此前完全相同。这样，剪枝就分析好了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(vis, <span class="number">-1</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">while</span>(k--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[a][b] == ans) <span class="keyword">break</span>;</span><br><span class="line">    vis[a][b] = ans;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（但是这么漂亮的东西并不是自己想的而是抄来的QAQ）我一开始是用set判a, b, cmd的三元组，发现不对，之后换成map加上经过一点的次数。zc的方法是在捡垃圾里面加上{vis[a] [b] = vis[a-1] [b] = … = 0;}，都WA了。看到一排的WA心情就会发生微妙的改变，要么是变佛，要么是不搞出来不睡觉这样。我是挺佛的，看看人家的剪枝这么优雅就把自己的给丢了，谁知道哪个神仙地方出了bug，这题也不好拿数据对拍。今天想想，光看“该点”的状态还是不够的，因为在路径中间捡完垃圾回到原点，后面仍可能走新的路径，故而要用更“全局”的东西来记录状态，我们应当是错在这点上。</p><p>这题的复杂度我还不会分析。若n、m取最大值，机器人至多在多少步后退出？我还没有想明白。</p><p>下面是D题，题干就不念了，没有输入，要求给出足够好的机器人捡垃圾策略。AC条件为在给定步数内，给定多组随机数据，平均捡垃圾率足够高。</p><p>随便分析了一下，看三进制下算出来的x的值。首位不会为1，所以1打头的都可以填I（同理01111这些也是不可能的）；首位为2的时候yy一下，都填P。然后首位为0时开始转移，依据旁边的点的结构，旁边的点会呈现出什么样的结构呢？</p><p>然后我就不知道了，就咕咕咕啦。</p><h2 id="G"><a href="#G" class="headerlink" title="G"></a><strong>G</strong></h2><p>题目本身比较简单，关键点在于将正负分开来考虑，然后每次贪心即可，详情参考代码。</p><p>问题是为什么会想到将正负分开来考虑呢？</p><h2 id="I"><a href="#I" class="headerlink" title="I"></a><strong>I</strong></h2><p>题意：给定n个点及其权w，给定m组约束关系（即有m对点不能同时选取），令x为$\prod w_i, i \in S$，S为n个点中任选若干点的满足约束关系的子集。问所有x的方差对1e9+7取模的结果。</p><p>题目中n最高达40。这个数量级下直接模拟（2^40）稳超时的。如何压缩时间呢？我一开始是觉得这里头会有什么微妙的数学结论的，就随便推了推，也就把方差展开了一下，结果并没有什么用。</p><p><del>康了康网友的题解</del>意外地发现并查集可以用来解决选子集的问题！考虑这样的数据，n=3，m=0。这时候共有8种选取方式。而8=2^3，我们可以用这样的代码来计算所有x的和及所有的选取方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    sum_x = sum_x * w[i] % MOD;</span><br><span class="line">    num_total = num_total * <span class="number">2</span> % MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的思路像不像生成函数？$\sum x = \prod(1 + w[i])$。”正常“的dfs是把右式中每一项列出来计算，而这里我们是注意到了这个式子本身，从而将右边的式子逐项计算，大大减少了计算复杂度！从O(2^n)到O(n)，这是怎样的突破呀！</p><p>上面的例子是m=0的，如果有约束条件呢？我们就用并查集，看看哪些项可能存在关联，把他们放到一个集子里（这样，集子与集子之间就是相互独立的，可以像前面一样运用乘法法则啦！），前面的方法也要改写成这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(LL i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[i].size() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    temp_x = temp_num = <span class="number">0</span>;</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    sum_x = sum_x * temp_x % MOD;</span><br><span class="line">    num_total = num_total * temp_num % MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tree[i]储存”可能存在关联“的元素，tree[i].size() == 0就表示这个元素被并到其他集子里去所以不需要检索了。dfs是暴力搜索在一个集子里的x的总和和可能的子集数，记作temp_x与temp_num。说到这里，核心的元素应该都阐释清楚了，具体部分可以看代码。最后的ans的计算公式是将方差化简所得到的，此处不表。dfs选子集是通过位运算进行的，此处也不表。模运算中的技巧如求逆元等同样不表。</p><p>这样的代码能应付这题了，下面我们来看看复杂度吧：上面我们对复杂度的认识还只是较为粗浅的，只考虑了一种情况。但并查集真的能在任意情况下对算法起到优化作用吗？考虑下面这组数据：n=4，m=3，约束关系为(1, 2)，(1, 3)，(1, 4)。把它推广下去，则算法的复杂度还是O(2^n)！</p><p>聪明的读者想必注意到了：在并查集内部，其他数都还是没有关联的，能否将之分配到新的集子中呢？若行，则这样的迭代要如何进行呢？对此我尚未想明白，读者诸君若有想法，欢迎联系，共同探讨。</p><p>总结一下经验教训吧：</p><p>①没有想到在模的意义下处理ave、ans（我真傻，真的，我单知道有理数运算可行；我不知道在模的意义下更方便处理），从而无处着手。</p><p>②没有想到存储sum_x2，sum_x来直接得到ans的值，但这应该是小问题，反映的更多是我的经验不足。</p><p>③MOD的处理，对每一个运算都要想是否需要取模，是否为负，特别是读入的时候。</p><p>④1和1ll不是同一个东西！这谁debug出来呀！</p><h2 id="J"><a href="#J" class="headerlink" title="J"></a><strong>J</strong></h2><p>观察了一下其他队伍的情况，相当多的队都是直接AC或是WA一发后在2-5分钟后就能调AC的，少量队伍调了30分钟乃至3小时。相比之下我们的20分钟（中间还放了一放）还是相对顺利的。但是对于边界数据，我的觉察程度还不够敏锐。</p><p>其他题还没补，先放放好了。</p><hr><p>初写于2019.04.14</p><p>完稿于2019.04.25</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是今年打的第一场比赛，成绩咱就不管了，总体玩的还是比较开心的。感觉光阴没有虚度，感觉前方还有着希望，而这就够了。&lt;/p&gt;
&lt;p&gt;作为一次经历，一次体验，打比赛在生命中自然是有其价值的，它是一个节点，串起了过往无数日夜的辛劳准备与或狂喜或迷惘的期望。它不一定是结果，也不代表旅程的结束，以我当前的追求来看。它只是一个中点，是生活的增味剂，是另一种形式的酒与诗歌。无用，然而有趣。&lt;/p&gt;
&lt;p&gt;说起比赛，首先想到的还是以往略显单调但也有滋有味的高中生活。想起以前翘课出去打NOIP，参加清华的不知什么考试，还有寒暑假在杭州在上海在环中的日日夜夜。关键并不在成就与从中得到的对自我的肯定，虽说这也是较重要的一环。我更喜欢的是合法翘课的感觉，喜欢的是纯粹出去玩这样一种心境。有一种逃离的快感，叛逆的甜蜜。而我所逃离的是什么呢？是日常？是普通？抑或无趣？在这层意义上，今天我仍然生活在高中时代的心理状态中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="https://nessoffice.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>【简牍提要】信息简史：两本字典</title>
    <link href="https://nessoffice.github.io/2019/03/28/The_Information-CH03/"/>
    <id>https://nessoffice.github.io/2019/03/28/The_Information-CH03/</id>
    <published>2019-03-28T14:56:42.000Z</published>
    <updated>2019-04-26T09:49:31.637Z</updated>
    
    <content type="html"><![CDATA[<p>这章字面上讲的是具体的字典，但实际也是在讲抽象的词汇，故本章和上一章在逻辑上的关联是比较强的。从口语到书面语，文字量出现了可观的增长，故而为其做出划分是有必要的。词典将文字做了尽可能完备的记录，以便能确定语言的“标准”。</p><p>词典为文字的持久性提供了正式认定，它表明一个字词的意义来自于其他的字词。这意味着所有的字词聚集到了一起而形成了一种互相关联的结构（图），它们相互定义。</p><p>然而，文字也是时刻在发生着改变，如何从这不确定性中确定权威，这是词典编纂者的一大难处。</p><a id="more"></a><p>副标题：我们文字的<strong>不确定性</strong>及我们拼写的<strong>随意性</strong></p><p>这章字面上讲的是具体的字典，但实际也是在讲抽象的词汇，故本章和上一章在逻辑上的关联是比较强的。从口语到书面语，文字量出现了可观的增长，故而为其做出划分是有必要的。词典将文字做了尽可能完备的记录，以便能确定语言的“标准”。</p><p>词典为文字的持久性提供了正式认定，它表明一个字词的意义来自于其他的字词。这意味着所有的字词聚集到了一起而形成了一种互相关联的结构（图），它们相互定义。</p><p>然而，文字也是时刻在发生着改变，如何从这不确定性中确定权威，这是词典编纂者的一大难处。</p><h2 id="字典诞生的条件"><a href="#字典诞生的条件" class="headerlink" title="字典诞生的条件"></a><strong>字典诞生的条件</strong></h2><p>印刷业、商业、交通、语言等等方面的快速发展，呼唤着语言的“标准化”。这种需求是词典诞生的原因。</p><h3 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h3><p>考德里的《字母排表》是信息史上的一座里程碑，但遗憾的是人们对于作者几乎一无所知，甚至连名字都拼不对。关于拼写这件事，书中提到：</p><blockquote><p>随着印刷书的出现和普及，人们逐渐产生了这样一种感觉，即单词的书写形式<strong>理应是</strong>确定的。</p></blockquote><h3 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h3><p>（英语）字典诞生的另一个原因和英语本身的特点相关。</p><p>英语是当时的世界上已是多变，多态而多源的。日耳曼民族、基督教传教士、法国对英语的影响接踵而至。很明显的例子就是日耳曼语中的cow，pig，ox与法语中的beef，pork，mutton。中世纪以来英语特点更是如此，对此也有知识分子持不满态度。</p><blockquote><p>而随着知识分子开始有意识地从拉丁语和希腊语中借用单词来表达英语中原先没有的概念，外来词的数量越来越多。考德里对这种做法感到不悦，他抱怨道：“有些人对于外国化的英语趋之若鹜，却把他们母亲的语言丢到九霄云外。”</p></blockquote><h3 id="人物"><a href="#人物" class="headerlink" title="人物"></a>人物</h3><p>谈及考德里，一下是他的个人简介。</p><p>同情清教的牧师，宣扬平等思想，受教会的排挤。他长期致力于搜集单词，曾出版过指南性著作，在1604年出版了他的简明词汇表。</p><p>致力于维护英语的简洁性到了顽固的地步，重视对常见词的运用，以便受教者能听懂，同时反对英语的外国化。</p><h2 id="字典使用的排序"><a href="#字典使用的排序" class="headerlink" title="字典使用的排序"></a><strong>字典使用的排序</strong></h2><h3 id="字典序"><a href="#字典序" class="headerlink" title="字典序"></a>字典序</h3><p>关于字典序，这种古老而现代的排序方式，书中有这样的论述：</p><blockquote><p>但即便在当时，这种机制在人们看来是不自然的，因为它迫使读者将信息从单词的意义中剥离出来，将单词严格地是为字符串，集中精力于单词的字母组合上。</p></blockquote><p>但当人们接受这种排序方式之后，情况便不一样了。</p><blockquote><p>这样做的效率惊人，因为这种机制可以很容易地扩展到任意规模，并且宏观结构和微观结构一模一样。一个人只要掌握了字母表顺序，就可以丝毫不差地在包含了无论是一千个还是一百万个单词的列表中定位到任意条目，而且在查找过程中无需了解有关单词的意义。</p></blockquote><p>书中还有个巧妙的类比。</p><blockquote><p>从按字母表顺序排列的角度看，单词无非就是一枚枚硬币，可以将其分别投入不同的投币口。</p></blockquote><p>事实上，首份按照字母表编排的目录直至1613年才被制作出来。（但我对印刷的历史并无概念所以不知道这意味着什么）</p><h3 id="“本质序”"><a href="#“本质序”" class="headerlink" title="“本质序”"></a>“本质序”</h3><p>性质接近字典的《尔雅》按照意义将其条目归为不同的主题，埃及人与阿拉伯人则将单词按哲学或教育原则加以组织，对此，作者有言：</p><blockquote><p>这些列表组织的其实不是单词本身，而是整个世界，也就是单词所代表的事物。</p></blockquote><p>莱布尼茨明确区分了这两种排列方式：前者从词到物，而后者从物到词。</p><h2 id="字典面临的难题：意义"><a href="#字典面临的难题：意义" class="headerlink" title="字典面临的难题：意义"></a><strong>字典面临的难题：意义</strong></h2><h3 id="字典释义"><a href="#字典释义" class="headerlink" title="字典释义"></a>字典释义</h3><p>为语言解释意义并不总是件容易的事情，因为这件事本身也要借助语言。</p><blockquote><p>双语词典的目的比单语词典的更为明确，毕竟将拉丁语转化成英语有其价值，而将英语翻译成英语似乎就难以理解了。然而在这里，释义是关键所在。</p><p>我们可以明显看出，他（考德里）在着手编写释义时时心怀警惕的，对于这些释义的可靠性他也并不十分确信。意义甚至比拼写更善变。</p></blockquote><p>简单的释义如同义或是从属关系（a kind of），但有的词的意思很复杂，如vapor，需要运用“三角定义法”。</p><blockquote><p>但仅仅用一个词解释另一个词，不论是同一关系还是种属关系，对于词典编纂者来说，还远远不够。一种词语中单词之间的关系错综复杂(chaos)，这种线性的解释方法根本无法完全应付。</p></blockquote><p>还有其他的难点：抽象单词。</p><blockquote><p>而对于其他表示概念和抽象的单词，因其与感性认识距离更远，考德里需要另寻别的解释方法。他逐渐摸索出了一种方法，即以平实而尽量精炼的语言描述给他的读者。我们可以从中看到他的为难之处，一方面他既要理解某些单词，另一方面还要将他的理解表达出来。</p></blockquote><p>最为棘手的可能是科学中的技术名词。（即便在今日，对它们的解释仍是相当困难的，因为涉及的是不同的语言体系）</p><p>其他的问题也很多，不仅限于单词本身。</p><blockquote><p>不仅是单词，知识也在不断变化，而语言也在时刻进行自我反思。因此，即便在考德里从库特和托马斯哪里照抄东西的时候，从根本上说，他还是在孤军奋战，并没有任何权威可供他咨询。</p></blockquote><p>词典与逻辑也存在着密切的关系：</p><blockquote><p>这时字词必须被当作字词来看待，不同于所代表的事物，代表的只能是其他字词。在20世纪，随着逻辑学的深入发展，这种循环定义的潜在可能性就可谓了一个问题。维特根斯坦就抱怨道……这呼应了三个世纪前牛顿的不满，只是现在的问题更为复杂。</p></blockquote><h3 id="其他释义"><a href="#其他释义" class="headerlink" title="其他释义"></a>其他释义</h3><p>除去编纂字典需要确认意义，推动科学的发展同样需要将单词与意义连接起来。</p><blockquote><p>在当时，科学作为一种探寻自然界及其规律的社会制度还尚未出现，但这时的自然哲学家们已经开始产生对于字句的本质及其意义的特殊兴趣。他们需要比已有字词更贴切的用语。</p></blockquote><p>伽利略发现太阳黑子后首先意识到这里存在一个语言问题（人们一直以来称太阳为“最纯净最清澈之物”），名实不符对思想的冲击。（今天的很多历史遗留也都是错误的，如“阿拉伯数字”这个名头）</p><p>牛顿在开始建筑力学大厦的时候则是使用了障眼法：不去定义时间、空间这些“众所周知”的概念，然而定义它们是他的目的所在。选择“质量”这个词也费了一番功夫，正如书中所说：</p><blockquote><p>可见，没有一个恰当的用语，他就寸步难行。</p></blockquote><h2 id="字典编纂与其中的难题"><a href="#字典编纂与其中的难题" class="headerlink" title="字典编纂与其中的难题"></a><strong>字典编纂与其中的难题</strong></h2><h3 id="早先的字典"><a href="#早先的字典" class="headerlink" title="早先的字典"></a>早先的字典</h3><p>从1613年的考德里，到1616年的布洛卡（他出版了《英语释讲》，较《字母排表》词汇更多），到1656年的布朗特，编写者的认识在不断深化。</p><blockquote><p>他（布朗特）好像已经意识到，自己瞄准的是个活动靶。他在前言中写道，词典编纂者的“工作没有尽头，因为我们的英语具有每天都在变的特性”。布朗特给出的释义比起考德里的要详尽得多，并且他还试图提供词源信息。</p></blockquote><p>虽然开拓者的工作可能有些稚嫩，但这却是有重大意义的。</p><blockquote><p>在最伟大的词典《牛津英语词典》（<em>OED</em>）出版之际，第一版的编辑们却向他那本“薄薄的小册子”致以了敬意。他们称之为“最初的橡籽”，<em>OED</em>这课参天橡树正是从这粒种子成长而来的。</p></blockquote><h3 id="网络时代的OED"><a href="#网络时代的OED" class="headerlink" title="网络时代的OED"></a>网络时代的OED</h3><p>谈到Pluto被除名行星一事对字典的影响，书中的这句话可以和第十四章关于wiki中namespace的论述相映成趣。</p><blockquote><p>从命名的角度看，天上已经快拥挤不堪了。</p></blockquote><p>回到正题。随着网络的发展，传统的字典不能不受到影响。</p><blockquote><p>在他（辛普森，牛津字典编纂组成员）的书桌上，除了单词卡片以外，还有着一根连入英语神经系统的导线。通过这根导线，它可以即时连接上由遍布全球的业余词典编纂者的网络……当词典遇上了互联网，两者都将面貌一新。无论辛普森多么热爱<em>OED</em>的渊源和遗产，也不论他愿意与否，他都正在引领一场革命，改变着<em>OED</em>——它是什么，知道什么，视野如何。考德里是孤军奋战，辛普森则是处于网络之中。</p></blockquote><p><em>OED</em>的目的，一在竭力捕捉语言的流变，二在担负起固化语言的任务。这是非常困难的任务，从丰富多样的拼写，到来源单一的“罕用”词。这期间编辑们反复强调自己只是选择了“当代最常用的拼法”，但仍避免不了武断的决定。</p><p>书中还提到了<em>OED</em>在收录新词等方面的一些历程，这些是趣味性的历史事实，和我们今日的生活也有着千丝万缕的联系，中心思想是关于编辑们对完备性与多样性的追求还有对随意性的否定。</p><h3 id="搜集单词的困难"><a href="#搜集单词的困难" class="headerlink" title="搜集单词的困难"></a>搜集单词的困难</h3><p>从无意识到有意识，初期的词典编纂者充满了雄心壮志。</p><blockquote><p>在考德里，词典是一种历史快照，他的视野无法超出他当时所在的历史阶段。塞缪尔·约翰逊则更为自觉地意识到词典的历史维度，并以此作为理由之一为自己雄心勃勃的计划进行辩护。</p></blockquote><p>Samuel Johnson认为语言曾经是“不受约束”的，故他要把它从无穷无尽的流变中解放出来。</p><blockquote><p>“它（语言）在每一种文学体裁的成长过程中都不可或缺，但它自身却一直以来遭到忽视。它苦于传播过程中的放任自流，以致变得极其纷繁复杂，对于时间和时尚的暴虐也只能逆来顺受，而且还要忍受无知的腐蚀和创新的心血来潮。”</p></blockquote><p>但是，这是非常困难的过程。</p><blockquote><p>直到<em>OED</em>，词典编纂者们才开始试图揭示语言的历史全貌，因而<em>OED</em>成为了一幅历史全景图。进入电子时代后，这项事业的意义愈加彰显无疑。</p></blockquote><p>编纂者开始工作的第一步是寻找单词，并追溯其历史演化。最初的编辑们认为声望卓越而品质出众的书籍是词汇不言而喻的来源，他们征集读者将曾经的作品阅读完毕以将单词一网打尽。他们认为这片领域虽然辽阔，但还是有疆界的，故而有着一一梳理的勇气。</p><blockquote><p>但到了现在，它似乎不再是有限的了。词典编纂者们开始接受语言是无界的事实。他们熟知默里的一句名言：“英语之圆有清晰明确的中心，但没有可以辨识的圆周。”在中心的是那些无人不知的单词。而在边缘，默里认为是俚语、黑话、科学术语以及外来词，对此每个人的认识都各不相同，并且没有一个人的认知可以被认作“标准”。</p></blockquote><p>遗憾的是，默里认为“清晰明确的”中心地带实则也存在着无限性和模糊性。认识到这一点的Samuel Johnson采取的是投降的策略。</p><blockquote><p>但人类的语言世界总会有与世隔绝的地方。一个山谷里讲的语言与相邻山谷里的多少有所差别。而现在尽管山谷之间已经不像以前那样封闭，但山谷的数目却比以往要多。</p><p>如果词典编纂者用以监听语言的耳朵的灵敏度真的有一个极限，那么现在人们也没有找到这个极限所在。</p></blockquote><h3 id="网络时代的词汇"><a href="#网络时代的词汇" class="headerlink" title="网络时代的词汇"></a>网络时代的词汇</h3><p>词汇的增长常常是爆炸式的，科技等领域的发展就是一个明显的原因。词汇的发展源于需求的增长，而一些需求是细胞分裂式的，而另一些则比较微妙。Mondegreen（与网络用于“空耳”有相似）一词就有其历史的缘由：这是一份相当古老的经验，但直至歌曲普及开来以前都不会进入词典（是的，这也是meme）。其他的共同经验，大抵也是如此。（故而语言的未来，在我看来，是非常难以预判的）</p><p>词汇增长的复杂度并非是多项式程度的，也没有很好的计量方式。即便是编纂者不断提高新词入选的门槛，这仍然是一项复杂得可怕的工作。</p><blockquote><p>词汇是对共同经验的一种量度，而后者始于互连通性。在四个世纪里，说英语的人从五百万激增至十亿，但更重要的动力来自这些使用者之间以及当中存在的连接数量。数学家会说，信息不是以几何方式增长，而是以组和方式增长，后者的增长速度远快于前者。</p></blockquote><p>关于词汇，让我们以对它的分析结束这一章吧。</p><blockquote><p>全体单词的集合，也就是词汇，构成了语言的一个符号集。一方面，这是个基础性的符号集，因为按此对于任何一门语言来说，都是可识别的最小的意义单元，而且得到了该语言使用者的普遍认同。但另一方面，它又远不是基础性的，因为随着传播技术的发展，语言中的讯息可以采用比其小得多的符号集加以分解、编码和传输，比如字母、点和划、鼓声的高和低等。这些符号集是离散的，而词汇不是，它更加无序，而且在不断膨胀。事实上，词典编纂被证明是一门不适合精确计量的科学。据说英语这门最庞大、最普遍使用的语言，粗略估计拥有将近一百万个意义单元，但语言学家自己没有什么专门的标尺，将他们试图量化新单词出现的速率时，他们也倾向于向词典寻求帮助。然而，即使是最好的词典也试图逃避这样的责任，毕竟词与非词之间的边界总是模糊的，从中无法划出一条清晰的界线。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h2><p>章节中的一些部分可以和前面的章节或是后面的章节结合起来阅读，此处仅就“两本字典”作结。</p><h3 id="考德里的字典"><a href="#考德里的字典" class="headerlink" title="考德里的字典"></a>考德里的字典</h3><p>①主要是自发的，受社会条件支配</p><p>②在“确认意义”这方面做出了一些尝试</p><p>③采用字典序这一有力的排序方式</p><h3 id="约翰逊字典与OED"><a href="#约翰逊字典与OED" class="headerlink" title="约翰逊字典与OED"></a>约翰逊字典与OED</h3><p>①主要是自觉的，认识到了规范语言的必要性</p><p>②认识到了规范与记录语言的困难之大，采取了不同的对策，达到了不同的效果</p><h3 id="其他论述"><a href="#其他论述" class="headerlink" title="其他论述"></a>其他论述</h3><p>①网络时代词汇量的增长与社会条件相关，以组和方式增长</p><p>②语言并非一个足够离散足够基础的符号集，故编纂词典并不是门可精确计量的科学</p><p>③语言并非“有序”的，其中心同边界一样不确定而会膨胀</p><p>④科学的发展首先需要解决语言的问题（林奈的工作也可以看作这点的例证）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这章字面上讲的是具体的字典，但实际也是在讲抽象的词汇，故本章和上一章在逻辑上的关联是比较强的。从口语到书面语，文字量出现了可观的增长，故而为其做出划分是有必要的。词典将文字做了尽可能完备的记录，以便能确定语言的“标准”。&lt;/p&gt;
&lt;p&gt;词典为文字的持久性提供了正式认定，它表明一个字词的意义来自于其他的字词。这意味着所有的字词聚集到了一起而形成了一种互相关联的结构（图），它们相互定义。&lt;/p&gt;
&lt;p&gt;然而，文字也是时刻在发生着改变，如何从这不确定性中确定权威，这是词典编纂者的一大难处。&lt;/p&gt;
    
    </summary>
    
    
      <category term="阅读" scheme="https://nessoffice.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
</feed>
