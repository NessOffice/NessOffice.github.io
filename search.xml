<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【围炉夜话】神游天外的典型场景，及天外的风景</title>
      <link href="/2019/07/23/Toughts-On_Wondering/"/>
      <url>/2019/07/23/Toughts-On_Wondering/</url>
      
        <content type="html"><![CDATA[<p>总觉得自己不是个心静的人，学习新知识的时候倒是能集中精神一些，但写作业，复习的时候就经常分神，感觉好无聊，宁愿发呆也不想学习。除了复习还有什么时候会分神呢？分神的时候会想些什么呢？这好像也是个有意思的话题。</p><a id="more"></a><p>总觉得自己不是个心静的人，学习新知识的时候倒是能集中精神一些，但写作业，复习的时候就经常分神，感觉好无聊，宁愿发呆也不想学习。除了复习还有什么时候会分神呢？分神的时候会想些什么呢？这好像也是个有意思的话题。</p><p>（我脏话说得越来越多了……不过这篇主要是娱乐向的，可能有些粗糙？但也挺好玩的）</p><p><strong>听听力</strong>：听力好多呀（几十篇），发怵。不行我不能怂我要锻炼自己提升英语水品。点开这篇听力，嗯，我要好好听！（30s后）？？？他在说什么？我天哪这个话题好无聊不想听停停停刚才那句话是什么唉我又想上网冲浪了查单词的时候水一水好了嗯我刚才到底在干嘛呀！我不是在听听力吗！不行不行，静心，静心……我天哪我到底听了什么东西这个部分有提到吗……倒放倒放……诶我怎么又在摸鱼……</p><p><strong>英语阅读</strong>：（看不懂的时候）这鬼文章在写什么？？？这个部分是干嘛用的？？？天哪上一句又在讲什么这篇文章好搓啊越看越恶心我去喝口水冷静一下……嗯刚才看到哪了……我刚才有看吗？？？不行不能这样瞎看，我要认真分析文章结构把这篇狗屎东西做掉。第一段它讲了……我怎么在看第二段？</p><p><strong>做水题</strong>：可持续化是什么东西？什么是权值线段树？今天晚上要吃什么？好饿我想吃零食。这个人博客怎么写成这样啊差评。我去越看说明越看不下去算算算看代码得了。？？？这什么码风呀，o是什么东西k是什么东西你tm变量名也不解释一下搞毛线啊。模拟一下样例好了，先进入这个函数，再来是……？？？不行这个人写的太差了，下一篇。omg怎么又是这种风格……</p><p><strong>做项目</strong>：哇这个功能还能这样实现，太棒了吧！哇这个库这么好的吗！我得用它来重构一遍……舒服……漂亮……（5h过后）我今天都在干嘛啊啊啊啊啊！</p><p><strong>睡觉</strong>：想第一类事情-&gt;想第三类事情-&gt;想第七类事情-&gt;想第二类事情……我怎么还没睡着……热热热热热热死了……哇我怎么还没睡着……</p><hr><p>完稿于2019-07-23</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【围炉夜话】吉静关于朋友的一些胡思乱想，及友链</title>
      <link href="/2019/07/22/Toughts-On_Friends/"/>
      <url>/2019/07/22/Toughts-On_Friends/</url>
      
        <content type="html"><![CDATA[<p>海水退去 露出了漫漫的旷野</p><a id="more"></a><h1 id="高中"><a href="#高中" class="headerlink" title="高中"></a>高中</h1><p>先讲朋友。ljq叫我广交朋友，但我不是很喜欢这样的建议。不是很愿意主动和别人结交。高中时候班主任也经常给我提这样的建议，我也都是“哦哦哦”过去的。你们不是我，也不了解我的平凡的普通的真实的我也不清楚为什么会感到的尴尬。</p><p>我没什么朋友，独来独往了若干年，没觉得这样有什么不好。自己学习，自己探索，自己难过。自己难过比较难受。可能和他人分享会好受些？不觉得。人真的能够理解他人吗？真正地，理解他人的痛苦，彷徨，徘徊与失落？我相信每个人都会有这样的感受，但不相信人能够<strong>理解</strong>他人的这番折磨。没有原因，仅是不相信而已。</p><p>有时候和同学走在一起，会有貌合神离的感觉。感觉大家都不喜欢我。和蒋哥们走一起时都是他们在聊天。感觉自己可有可无。好像是高二的时候吧，因为相关的原因不想吃饭，包括中饭，包括晚饭。饥饿很好，能把我的想法从那些乱七八糟的很烦很不爽的事情上转移到对饥饿本身的体味上。当然饿多了身体也吃不消，白天头会很晕，晚上会睡不着想着想吃东西想吃东西。于是就只能夜自修后去吃夜宵了。吃夜宵的时候，有时翔中会坐过来，这时候往往会感到一种莫名的感动。</p><p>感觉自己比较黏，谁都黏。大家似乎不喜欢这样的我？那我就只黏着自己好了。很多时候会很封闭，不愿意和人来往。宁愿盯着题目毫无思绪地发呆，宁愿一直一直生闷气，也不想去打扰别人。并不是没有尝试过，只是试的次数太多我厌倦了。错的似乎总是自己。我没有道理，我比较偏执。难过的也是自己，虽然别人也不好受？但我体味不到，理解不了。讨厌将心比心，当且仅当我很不很不开心。</p><p>高三时候心理可能正常了一些吧，虽然不是所有时候。晚上喜欢和阿彪聊天，虽然人家经常不理我。”睡觉。“但也不总是不理我。印象比较深的是四月选考结束后的晚上，我因为网络太崩成绩还没查出来，心还悬得很，完全睡不着。聊未来，聊选择，不知聊些什么，不知聊到几点。虽然我们基本都是自说自话，自问自答，但就是能沉浸在这样没有逻辑的对话中，在充满不确定的前方中感到一丝安定（当然，如果之后发现考试崩了，想必我的回味也不会是这个样子吧）。</p><h1 id="大学"><a href="#大学" class="headerlink" title="大学"></a>大学</h1><p>大学里朋友有很多划分：室友、课友、队友……反倒是“同学”用的少了。我用同学指代课友，同学还以为是高中同学。</p><p>这样的划分在“友”字之前更强调对方在己生活中的具体哪一部分（虽然说者不尽都这么想），更强调双方的共同点（或者说共同利益？），更社会了些，没有象牙塔里那么纯真（去他娘的纯真）。虽说是”友“，但终归只是个称谓而已，这很礼也很文明，但似乎也造成了成年人之间的一丝微妙的隔阂。</p><p>虽然结识很多厉害的人也是上大学的一个作用，但真的不喜欢主动。讨厌经营人脉。无聊。一般不会约别人出来。我对未来没什么想法也不想有什么想法。我只想过上平静的生活。</p><p>有时也会被认识，但并不是所有时候都想认识别人，也不是所有人都想认识。至于想认识和不想认识之间的区别，我也不清楚。私以为能力并不是重要因素。或许和开朗的同学更能聊得来吧。</p><p>有时看着大家都成双入对的会有一丝羡慕，但觉得自己并不是个能始终对女孩子负责的人。无意伤害他人，所以还是把可能的悲哀扼杀掉好了。</p><p>生活本就很拧巴。所以有一些隔阂，保持些距离似乎也不错。进了浙大以来心理状况比以前要健康地多了。庆幸自己能觉得自己是个正常人。这和所处的环境必然是有一定关联的。大家有了距离可以不相互打扰，我可以happy coding而不必在高考之外不自觉地考虑班级里年级里的partition问题，这很棒，对我而言。（当然大学的生活境况必然对每个人心理状况的影响是不一样的，起码我觉得自己的室友，碰到的同学，都很nice）</p><p>但下了雨还是希望能有人来给自己送伞呀。</p><h1 id="Cyber"><a href="#Cyber" class="headerlink" title="Cyber"></a>Cyber</h1><p>或许于我而言，朋友并不是个日常性的词汇吧。所谓“朋友圈”，里面却大都是陌生人的生活，真奇怪呀。</p><p>谈及朋友圈，及与之相关的social media，引一段卢昌海的相当有趣的思考：</p><blockquote><p>性格使然， 我较少与人互动， 微博微信都如此。 有时会想， 微信因为是朋友圈， 相互点赞比较频繁， 那里的点赞会不会无形中成为一种类似 “表忠心” 的行为？ 当一条微信被 N - n 个朋友点赞， 那没点赞的 n 个朋友会不会引起微信主人的留意 (尤其在 N ≫ n 时)？ 如果用 Ai 表示没给微信主人的第 i 条微信点赞的人的集合， 则 ∩Ai 会不会被当成 “叛徒” 集合， 那里的人会不会像《古拉格群岛》里那个在需要鼓掌的场合第一个停止鼓掌的人那样， 引起最高级别的留意？</p></blockquote><p>在信息流通渠道更加多样的今日，诚然人们能更加便捷地获取彼此的相关信息，但对于彼此的<strong>理解</strong>却并不较昔日有了同步的加深。相反，对于“友谊”的经营却更便捷，更快速，更细微化了，因为通信方式的变迁。看上去每个人的通信量都增加了故而朋友也更多了？但是人性并没有随之进化呀。表面稠密的friendship graph，实际上，各个edge的weight也并不像看上去的那么大。无往不在的枷锁呀。</p><h1 id="自己"><a href="#自己" class="headerlink" title="自己"></a>自己</h1><p>不怎么打游戏，不怎么看番。</p><p>不怎么关注热点，包括科技，包括社会。</p><p>不敢在social media上说话，不敢水群，没有点赞的习惯。</p><p>不喜欢关于自己的照片。</p><p>不喜欢在所有人面前暴露自己。</p><p>不喜欢大的组织，不喜欢多人小组的退化，不喜欢不被搭理。</p><p>不喜欢碰到认识但是不熟悉的同学的时候被无视的感觉。</p><p>不喜欢应酬，不喜欢恭维与被恭维。</p><p>不喜欢从他人的身上看到自己的镜像。</p><p>等等。</p><p>喜欢刘震云的小说。</p><p>喜欢汤浅政明的动画。</p><p>喜欢《梦日记》。</p><p>喜欢马蒂斯的绘画，《舞》尤其。</p><p>喜欢巴赫的音乐。</p><p>崇尚计算机科学家、数学家，希望对他们有更深一步的了解。</p><h1 id="友链"><a href="#友链" class="headerlink" title="友链"></a>友链</h1><p>以文会友（可不是言在此而意在彼），是个人简单的希冀。当然以下很多都只是单向边……</p><h2 id="自己-1"><a href="#自己-1" class="headerlink" title="自己"></a>自己</h2><p>如果你能看到这个blog这篇随笔，你或许对一些文章的一些部分有一些想法？或许想交流？一种联系方式是与blog相关联的github账号，虽然通过github来交流感觉有一点点的奇怪……但是github是个交友网站不是吗（<del>划掉</del>）。</p><p>抑或，可以用更普遍也更俗套一点的交流方式，social media。鄙人的QQ号是第648647743个evil number（第一个是evil number是0）。邮箱的话也是账号，因为并没有开其他邮箱。</p><p>我的称谓有很多（<del>因为喜欢胡乱取名字</del>），不过现在基本也固定下来只用几个了。作为successors of Alan Turing的我，作为艺术家与诗人的我，日常中的我，你们眼中的我，在不同维度下的同一个体。</p><h2 id="同期"><a href="#同期" class="headerlink" title="同期"></a>同期</h2><p>（排名，自然是不分先后的）</p><p>NCJ：<a href="https://ncj.wiki/" target="_blank" rel="noopener">https://ncj.wiki/</a></p><p>XTXTMTXTX：<a href="https://www.xtxtmtxtx.xyz/" target="_blank" rel="noopener">https://www.xtxtmtxtx.xyz/</a></p><p>chty_syq：<a href="https://chty.coding.me/" target="_blank" rel="noopener">https://chty.coding.me/</a> （那个nerds.pub好像是合作性质的，管理员还有logining等，不过其他我不认识/捂脸）</p><p>zkx06111：<a href="https://zkx06111.github.io/" target="_blank" rel="noopener">https://zkx06111.github.io/</a></p><p>知名退役选手jsb：<a href="https://www.cnblogs.com/jiangshibiao/" target="_blank" rel="noopener">https://www.cnblogs.com/jiangshibiao/</a> （其实只看学长的游记和好番推荐/捂脸）</p><h2 id="先辈"><a href="#先辈" class="headerlink" title="先辈"></a>先辈</h2><p>卢昌海（知名科普作家，偏物理/人文）：<a href="https://www.changhai.org/" target="_blank" rel="noopener">https://www.changhai.org/</a></p><p>matrix67（知名科普作家，数学，曾为OI选手）：<a href="http://www.matrix67.com/blog/" target="_blank" rel="noopener">http://www.matrix67.com/blog/</a></p><hr><p>初稿写于2019-07-21，夜</p><p>终稿改于2019-07-23，昼</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【朝花夕拾】吉静文选 告别</title>
      <link href="/2019/07/18/History-My_Essays-Farewell/"/>
      <url>/2019/07/18/History-My_Essays-Farewell/</url>
      
        <content type="html"><![CDATA[<p>往事如烟。整理昔日的文稿，总会感到一阵时空错位，和悲凉的感觉。</p><a id="more"></a><p>（版权所有，严禁转载。违者自行承担相应法律责任）</p><p>这个集子名《告别》。</p><p>虽然是随笔，但有些偏向于《残垣》那种风格，但色彩基调明显不一样，也更具现实感。</p><h1 id="教室，在夕阳下"><a href="#教室，在夕阳下" class="headerlink" title="教室，在夕阳下"></a>教室，在夕阳下</h1><p>初中的课本皱巴巴的，好多课文感觉都没学过，仔细一看它们又熟悉起来了。书中有蝈蝈和蛐蛐，有星星的变奏曲，它们提醒了我某段早已被遗忘但仍旧温馨的时光。于是彼时的我住进了此时的我的身体里，时间停止了。 </p><h1 id="竞赛时期标准日程"><a href="#竞赛时期标准日程" class="headerlink" title="竞赛时期标准日程"></a>竞赛时期标准日程</h1><p>起床，清醒，吃饭，待命，上课，能懂，不懂，课间，上课，下课，买饭，回寝，玩乐，午睡，起床，清醒……</p><p>这就是我们的一天，这就是我们的一生。</p><h1 id="最后一次春游"><a href="#最后一次春游" class="headerlink" title="最后一次春游"></a>最后一次春游</h1><p>还在路上，就闻到了前方传出浓郁的烤肉的芳香。烟雾那边我们手忙脚乱。烤架咝咝，送下了喷香的羊肉灼口，还有鲜嫩的青菜淌油。椅子上的自来水逐渐泛开了油滴与黑水。酥而脆的五花肉，韧而耐嚼的鸡心，弹来弹去的面筋，不肯抬头的里脊，以及大红的虾与白里透紫的鱿鱼，都发着小泡，点缀着若干孜然、椒盐，跃入食客们的口中，使得香留唇齿。大饮料瓶中的冰可乐不久就被抢灌一空，留下横七竖八的塑料杯狼藉地躺在桌子上。邻桌娴熟的新疆小伙已和一帮人出去开观光车了，余下一个新人懒懒地经营着几串豆腐，收获着数片扇贝。鼓鼓的肚子坐在长椅上悠闲地沉浸于自己的世界，胖胖的老师则在收拾罢餐桌后拉住路过的同学，来来来，再吃一点。烟雾渐渐散去，人群也变得三三两两，时间在这里走向静止。</p><p>我是在返程的大巴上想起这一切的，那时我因过度尽兴而感到有些疲倦。车里不少人睡着了，很安静，静得仿佛一切都在离我而去，包括三年来所有的好奇所有的不甘所有的恼怒所有的欣喜。</p><h1 id="旧照片"><a href="#旧照片" class="headerlink" title="旧照片"></a>旧照片</h1><p>画面上那个肥嘟嘟圆圆脸的表情呆呆的小孩子，穿着肥大的暖暖的棉衣，被高高抱起，在自己的农村老家门前。那是我。</p><p>这组照片包含了很多景点，看得出是全国各地的大好河山。美丽景色的前边只站了一个人，就那么直直地站着，带着说不好是什么的表情，或许是平静吧。那是妈妈，没有皱纹。</p><p>这张照片是在“温州乐园”拍的，那儿我只去过一次。我不记得那次自己玩得如何，但能从照片上明显地看出奇怪的飞行器上大笑着的那位，铁定是玩得很开心的。他眼睛睁得那么大，可以说有些夸张，不过他平日表现高兴也是这样的。那是我爸，我没法和他交流我现在的感受了。</p><p>不知是我几岁时的家庭聚会，标题写着奶奶的生日。这桌布、这光线，看上去都明亮亮的，很舒服。我穿着某件看上去挺漂亮的毛衣，妈妈有些朴实地目视前方，奶奶则略显笨拙地做着这会儿的主人。很温暖啊。</p><p>我不喜欢拍照，爱拍照的人是爷爷，相册弄了一大摞，不过我还没怎么看。我只在题目写不来时把题目拍下来问我爸，或偶尔想拍了拍两张。手机里的相册，如今仍忠实地提醒着我2017年9月的、2017年6月的往事，当时的情景历历在目，我还能感受照片中自己手指的温度。</p><p>照片还有很多，一一说来不免无趣。随意翻略它们，我看到记下了那只我曾爱不释手的恐龙、从前老家暗淡的光线以及其他许多触动心灵的细节。百味杂陈，我无力诉诸语言，也无意借助语言。</p><p>有时想想，世界还是挺残酷的。隔了一层纸的距离，时间就能永驻，任凭纸外的人感伤流涕也毫不改变。当然“永驻”不大可能，原子衰变或是其他物理化学因素可以轻松摧毁那个世界，只是这和我们正常人类不大相干罢了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 创作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【朝花夕拾】吉静文选 游戏笔墨</title>
      <link href="/2019/07/18/History-My_Essays-Collection_Of_Jokes/"/>
      <url>/2019/07/18/History-My_Essays-Collection_Of_Jokes/</url>
      
        <content type="html"><![CDATA[<p>不开心的大背景下难得真正开心的一些时刻。</p><a id="more"></a><p>（版权所有，严禁转载。违者自行承担相应法律责任）</p><p>难得的开心的文字呀。</p><p>（有几篇太羞耻了，不能放上来）</p><h1 id="徐立海讲水浒故事"><a href="#徐立海讲水浒故事" class="headerlink" title="徐立海讲水浒故事"></a>徐立海讲水浒故事</h1><p>话说鲁提辖在街上买了十斤肉，他乘电梯回公寓时，这个肉呢，放在秤上重量变重了，这是为什么呢？因为它受到了一个向上的加速度！所以超重啦！他快到家的时候，又发现这个肉，又变轻了。他就想回去揍镇关西。他快到电梯门口的，肉又变重啦！哎他就觉得，这个肉有鬼，还是不爽，就去把镇关西给打啦！这就是“拳打镇关西”这个故事的由来。</p><h1 id="某活动课"><a href="#某活动课" class="headerlink" title="某活动课"></a>某活动课</h1><p>一对阴鸷的眼睛在里面四处摇头晃脑地打量着，伴随着牛皮男鞋的“哒哒”声空谷回响。发牌的手冷了下来，目光黯淡地看着前方这无尽深渊。校服以外的蓝色在几秒前还欢快嬉笑的身影后停了下来。“玩什么呀？”</p><p>但什么也没发生，那个男人用同样阴冷的语调说道：“玩吧玩吧，放松一下。”然后他走开了。</p><h1 id="三重奏鸣曲"><a href="#三重奏鸣曲" class="headerlink" title="三重奏鸣曲"></a>三重奏鸣曲</h1><p>平静如水的黑夜里，那个角落传出了不安分的声音。声音起初还只是微弱的鼻息，到了某个节点突然被添了过量的燃料一般，变得雄浑有力，宛若有一辆铁皮火车在喉咙间艰难地前行。它先是爬山坡，音调循序渐进升高，余音袅袅；到了山顶稍作停留，便马上坠下，准备一段时间后东山再起。如此往复，经久不息。对床的低音炮听闻火车隆隆，仿佛找到了知己，与之共鸣起来，时而高亢，巍巍乎若山峦；时而低沉，洋洋乎如流水，变化多端，响亮非凡，嗓子好似海绵被压榨般拼命地挤出声音。那边的重感冒也不曾闲着，这小子还宣称自己从不打呼噜的。三个喉咙不分你我不分轩轾不分高下，你方唱罢我登场，欲与天公试比响，共就三重奏鸣之曲，共成三足鼎立之势。哪怕人间至乐，动听不过如此。只是天下没有不散的宴席，不久便只剩下一辆孤独的小火车寂寞而坚毅地爬着山坡。然而这仙乐倒越发至臻至善了：头一秒还是火车蹒跚步，下一秒竟成了瀑布下高山。只是这样的境界不可久驻，它重复了两三回后，嘟嘟，没燃料了。</p><h1 id="灵魂宝石"><a href="#灵魂宝石" class="headerlink" title="灵魂宝石"></a>灵魂宝石</h1><p>阿狼（化名）此刻正在竞赛教室兴致勃勃地玩着手机，此前他正彻夜不眠地目不转睛于那个发光小长方体，而往常这个时间他都在垂下高贵的头颅以补充能量。</p><p>“阿狼，手机还我。”</p><p>就在中翔（化名）夺过他手机的那一刻，阿狼的眼中光芒尽失，他的身体轰然倒塌，他的灵魂仿佛在一瞬间被抽走了，只留下那具面对桌面沉思的躯体。</p><p><strong>续</strong></p><p>阿狼（化名）此刻正在竞赛教室沉睡仿佛与世长辞。娇男（化名）为不打扰他休息，轻轻地把手机放在他桌子上。听闻这手机碰桌的微小声息，不为任何大吵大闹所动的阿狼竟还魂一般立了起来，夺过那手机稳稳地玩了起来。</p><p><strong>续二</strong></p><p>阿狼（化名）此刻正在睡觉，这是因为手机被玩没电了。幸而它正在充电。随着手机电量越来越高，阿狼的眼睛越来越亮。在手机充满电的那一刻，阿狼自然地将手机拿起，解锁密码，玩了起来。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 创作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【朝花夕拾】吉静文选 桃园</title>
      <link href="/2019/07/18/History-My_Essays-The_Utopia/"/>
      <url>/2019/07/18/History-My_Essays-The_Utopia/</url>
      
        <content type="html"><![CDATA[<p>最后一段是借鉴的《兽爪》中的某段剧情：第八集的大战之后，一个服用了“药”的社员拖着半截身子在等死，他请求路过的男主给他一把枪自杀，但他接过枪后却企图射杀男主女主。他们跑掉之后，他想要自杀，却没有子弹了。</p><a id="more"></a><p>（版权所有，严禁转载。违者自行承担相应法律责任）</p><p>最后一段是借鉴的《兽爪》中的某段剧情：第八集的大战之后，一个服用了“药”的社员拖着半截身子在等死，他请求路过的男主给他一把枪自杀，但他接过枪后却企图射杀男主女主。他们跑掉之后，他想要自杀，却没有子弹了。</p><p>Cthulhu风格的科幻小说。</p><h1 id="桃园"><a href="#桃园" class="headerlink" title="桃园"></a>桃园</h1><p>这里是桃园，我是根据祖上流传下的地图来的。老人们说此图非关键时刻不得启封。就连我在厕所中郁郁而死的高祖父、死在五十个女人手上的伯父和用两把手枪终结自己生命的父亲都没有打开过这张地图。如今它在我手上，我在桃园，以一个社会调查员的身份。我想知道这颗黄色星球上的最后一片净土是怎么样的。</p><p>岛的外貌和记载的一样，“芳草腥美，落英缤纷”，外沿是桃花盛开。“林尽水源，便得一山……”我沿小孔进入。光在聚集，就像世界在创立，我感到那边是一个美好的新世界。</p><p>这里的确和我们那不同，偌大的村庄内空无一人。古建筑鳞次栉比，这引起了我调查的兴趣。我走入村庄的内部，打算从房子开始调查。</p><p>每所房屋都不是空的，我在屋外能清楚地感受到。然而门窗紧掩、窗帘遮蔽，里头时不时发出大型食肉动物的进食声、婴儿的尖利笑声以及一些不可名状的声音，大脑产生了本能的畏惧感。窗帘、墙壁或是门楣上不时会冒出或消失些圆睁的眼睛注视着我不断移动。我无法想象里面是怎样一种压抑的恐怖，故而我完全没胆敲门。</p><p>这里是北温带，空气中却一直蒸发着一种浓厚的热气，人待久了足以窒息。</p><p>这里的房屋毫无特点，这是我长久观察后惊惶得出的结论。尽管第一眼看上去是第一航道的古代庭市，它们事实上有种蜡似的虚伪感。房屋的材质并非地球上的任何一种已知材料，性质奇特又恶心。它们的反应甚至让我感觉他们具有生命。</p><p>我终于看见人了，那是一个蘑菇头圆圆脸的小孩和一个胖胖的小孩。他们很欢快地跑着跳着，似乎在进行历史书中提到的“婴孩的游戏”。他们靠近了，脸上洋溢的欢快就像太阳驱散乌云，我感到一种无名的快乐自外界涌入身体。他们靠得越来越近了，我能够听到他们玲珑的小嘴里蹦跳着的欢快的音符，那是：</p><p>“肏你妈…肏你妈…”蘑菇头咧着笑脸，拍打着前面的小胖子，用童稚的声音低声笑骂。</p><p>突然小胖子被路上的石头绊倒了。他的表情即刻突变，它的面具好像裂开了一点。它迅速站起，朝着那石头破口大骂：“肏你妈——的屄！”但随后又仿佛自豪于自己刚才所能说出的最后两字，心满意足地拐进一条小巷，不见了。</p><p>天更热了。</p><p>我突然想到卡夫卡的一篇小说，想到那个被父亲一句判决就马上投河了的孩子，从地上捡了把枪。我想找真正的桃园。</p><p>然而尽是这样的劣等枪。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 创作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【朝花夕拾】吉静文选 残垣</title>
      <link href="/2019/07/18/History-My_Essays-The_Ruins/"/>
      <url>/2019/07/18/History-My_Essays-The_Ruins/</url>
      
        <content type="html"><![CDATA[<p>小说或者寓言。</p><a id="more"></a><p>（版权所有，严禁转载。违者自行承担相应法律责任）</p><p>这个集子名《残垣》。</p><p>我并不知道这样的文章应当归到哪种文体。自认是小说，或者寓言。</p><p>戏谑为少，幽怨为多。</p><p>完全不美好的，过去。</p><h1 id="狼"><a href="#狼" class="headerlink" title="狼"></a>狼</h1><p>“狼来了，狼来了。”我说。</p><p>他们没理我，他们照常工作。</p><p>之后，我把他们吃了。</p><h1 id="鱼"><a href="#鱼" class="headerlink" title="鱼"></a>鱼</h1><p>“子非我，安知我不知鱼之乐？”庄周言毕，跃而入水，曳尾于涂。</p><h1 id="哈姆雷特"><a href="#哈姆雷特" class="headerlink" title="哈姆雷特"></a>哈姆雷特</h1><p>无穷大的图书馆中一只猴子在如山的稿纸中昏昏欲睡地打字直到它滑下椅去在散落的稿纸中留下了串脏脚印。</p><h1 id="君子之风"><a href="#君子之风" class="headerlink" title="君子之风"></a>君子之风</h1><p>你说他说你说你他妈的分明已经纯乎就是个傻逼傻缺傻狗就是个白痴就是个人渣你拉屎吧你去死吧你你你就是个……</p><p>多讽刺啊，这是相互否定吗？其实这是平等。</p><p>一切冲突均同理，即便你以为故作不争就是君子。</p><h1 id="朋友"><a href="#朋友" class="headerlink" title="朋友"></a>朋友</h1><p>我生活在壳里。</p><h1 id="天堂之门"><a href="#天堂之门" class="headerlink" title="天堂之门"></a>天堂之门</h1><p>从未有人从里面出来过。</p><h1 id="海底两万里的风景"><a href="#海底两万里的风景" class="headerlink" title="海底两万里的风景"></a>海底两万里的风景</h1><p>一只塑料袋悠然飘过。</p><h1 id="蟋蟀和蚂蚁"><a href="#蟋蟀和蚂蚁" class="headerlink" title="蟋蟀和蚂蚁"></a>蟋蟀和蚂蚁</h1><p>艺术家飞往天堂，劳动者驻留于大地。</p><h1 id="善之花"><a href="#善之花" class="headerlink" title="善之花"></a>善之花</h1><p>裸露的大地一旷无垠。地上的我看到地缝中的花朵和远处的石像。石像的表情如它复活节岛上的同胞那样复杂。石像或许等了我千年，或许因我的出现而出现。我未可知。</p><p>我朝花朵走去，石像为我流泪。</p><p>我摘起花朵，石像顷之倒塌。</p><p>不详姓字的花，在被摘起时就枯萎了。</p><h1 id="远方"><a href="#远方" class="headerlink" title="远方"></a>远方</h1><p>我是自己醒的，没有人来叫我，这说明火车还没有修好。火车外的男人们咒骂着火车、行程以及世界上的一切，车厢里则堆积着絮絮叨叨的家常女。我想起城市，打着虚假的暖气，烙上了工业文明的钢印，面无表情的机器公民横行其间。雪花落在我的脸上，打断了我的想象。空中仍摇曳着数片晶莹雪花，但它们不属于我，我也不属于它们，我的归属在火车本会到达的那片地方。在轻微而持续的寒冷中，我还能做什么呢？我睡着的时候尚早，以至那提醒乘客火车故障让他们转回巴士的电子音要过一会儿才响起。其间雪下得越来越大了。</p><h1 id="三只小猪"><a href="#三只小猪" class="headerlink" title="三只小猪"></a>三只小猪</h1><p>猪A在把猪B卖给灰狼后长吁了一口气：终于除掉这个心腹之患了。他却未料自己被猪B反咬了一口，在他之前被那匹狼捅了一刀进了酒肆。酒场中猪C与灰狼划拳碰杯，共啖猪肉，谈天说地。</p><h1 id="心之刃"><a href="#心之刃" class="headerlink" title="心之刃"></a>心之刃</h1><p>历史的事实是不明朗的，没有人真正理解一切的细节，而那在一定程度上会导致不可预测的结果。</p><p>我回到班级。有的人回头看我，有的人没有。她像只花蝴蝶一样仍旧谈笑风生对开门两耳不闻，声音尖锐刺耳。一股无名火起，我径自走去，手上握着把刀，它好像一直就在那里。我用力一刺，然后就没声响了。</p><p>有人来劝架，我一一把他们杀了。</p><p>血干得很快，刀像崭新的一样，锃锃发亮。他们的皮肉和骨头马上腐烂了。</p><p>其他学生也消失了。夕阳照进了干净的教室。</p><p>然后，外面飞来了一只蓝蝴蝶，眨巴着翅膀上的一对眼睛。</p><h1 id="食人症"><a href="#食人症" class="headerlink" title="食人症"></a>食人症</h1><p>我住在房子外面，他们在房子里面。平时我们相安无事，但他们时常莺歌燕舞欢笑不断，而我一个朋友什么房间也没有，常常感到很悲哀。他们是如此的冷漠，却又无比热情地对待同间的房客。他们看见我了，他们的目光满是怜悯，他们的脚扎根于水泥地，他们的表情仍旧愉悦。我好悲哀，我好悲哀；每每这种时候我就想吃东西。人类在休息的时候大脑会消耗20%的能量，为什么要这么多呢？有什么用呢？但外面没有什么可吃的东西，随着我越来越沮丧周围的事物越来越奇怪越来越不可名状。我只能吃掉自己了，它们也是这么认为的，至于他们的观点我不知道我也没有感情顾及。先是手指，是没有味道的鸡爪；再是手掌、手臂、双脚、双腿、躯干还有内脏——人类为什么要思想，为什么要接受一切痛苦的根源——我的头部、我的脑浆、我的思想、我的心。最终我被吃得一干二净。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 创作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【朝花夕拾】【转载】听雨轩文选 我的罗曼史</title>
      <link href="/2019/07/18/History-Essays_Of_Classmates-My_Romance/"/>
      <url>/2019/07/18/History-Essays_Of_Classmates-My_Romance/</url>
      
        <content type="html"><![CDATA[<p>非常非常有趣的写法。我也想写这样的内容，不过写的肯定没人家有意趣啦。</p><a id="more"></a><p>（如有侵权，请联系博主。将于第一时间予以删除）</p><h1 id="我的罗曼史"><a href="#我的罗曼史" class="headerlink" title="我的罗曼史"></a>我的罗曼史</h1><p>作者：王敏洁</p><p>月光在墨色的涟漪里晕染开来，满塘浮动的青雾，白衣赤足，衣袂飘飞，跨过万水千山、时光苍茫，她向我走来。一卷楚辞，满纸荒唐，千年哀愁从笔墨间流淌下来，凝成一滴，融入她清俊的眉眼。一见钟情，我和语文的邂逅，是一场宿命的相会。</p><p>人说初恋难忘，果真如此。语文亦师亦友，见识广，有百面之性格，千般之故事。她可以是不谙世事的翠翠，也可以是精明世故的熙凤：可以是赤壁怀古、寻想人生哲理之东坡，也可以是月下荷塘、体悟理想境界之配弦。无论如何，她总携着华丽、朴素、热烈、淡泊之美向我走近，她总带着一种诗意的人生向我走来。喜欢在午后的阳光里修文，铺开一张纸，让每一个坎坷都被照得灿亮，然后开始百般打磨，千般润饰，直至笔墨间蜿蜒出精金美玉般的光华。我从不可惜这样一个下午，也许它本有他用，但我觉得值得。语文值得被一个人认真对待，认真去爱。我们的爱，已渐入佳境。</p><p>至于后来与英语坠入爱河，却又是他话了。金发碧眼，身长九尺，英语虽形貌妍丽，望之而令人生畏。然英雄过不了美人关，终究还是深陷温柔乡。英语为我打开了世界之窗，浩淼的遥远的大西洋上，有一片大陆从海雾后隐现了它的真容。繁荣都市，寂静土地，宏伟繁复的西式建筑，艰涩深邃的文学著作……一群深眉邃眼、高鼻鹰目的外族人，在地球的另一端，同样日出而作，日落而息。细水长流，日久生情，越是深入地了解，越助人抵达一个顿悟的境界：每一个民族，都在经历着同样的喜怒哀乐、兴衰荣辱，都在共享同一片苍穹，同一颗太阳，同一片土地。每一个民族的语言和文化，都同一棵树上不同的花朵。我们同根，我们同生。</p><p>与数学的相爱可谓是回肠九转，异常艰辛。一张空白的试卷，两幅极简的几何，三根愁白的头发，满室弥漫的寂静。不是我不想爱他，而是我不敢爱他。数学长得未免太过生人勿进，白衬衫，黑西裤，纽扣一直系到领口，一副泛着蓝光的深度眼镜，目光让人不寒而栗。数学似乎一辈子都不会对我感兴趣。可是你无法否定，数学的魅力浑然天成，令人无法抗拒。冬夜寂静，一灯如豆，你披衣在桌前与数学对视，感觉一种独属于人类的理性和热情在脑海里冷却，在胸膛里燃烧。于是你开始翻山越岭，千里跋涉，一意孤行，只为寻找一个不为人知的答案。思维的火花在黑夜里闪现出雷电般摄人的光彩。你到达了，或者你倒下了，飞蛾扑火的热情还在胸膛里寂静地燃烧。这是人类至高的理性，他的名字叫数学。</p><p>后来又在倾城日光下邂逅化学，在车水马龙的街道偶遇政治，与胸怀大略、满面沧桑的历史有了交集……学科是有生命的，能在今生今世和他们相知、相爱、相守，是一种莫大的荣幸。</p><p>我不是不在乎外在的东西，只是更重要的是爱，不是结晶；是过程，不是结果；是学习，不是收获。真正热爱的人，将它们所有的爱和生命都注入自己的一片田地，他们将汗水滴入土壤，而不去想耕耘是否会有收货。而他们坐拥的，不只是一个秋天的金黄，还有整个精神世界的富甲一方。</p><p>爱你所学，学你所爱。</p><p>“我在生活里不需要更深地思索，从书卷里获取粮食，在野花盛开的文字中获取爱情，我的世界宁静有序，痛很清晰，爱恨简单存粹。”</p>]]></content>
      
      
      
        <tags>
            
            <tag> 创作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【朝花夕拾】【转载】听雨轩文选 创世纪</title>
      <link href="/2019/07/18/History-Essays_Of_Classmates-Genesis/"/>
      <url>/2019/07/18/History-Essays_Of_Classmates-Genesis/</url>
      
        <content type="html"><![CDATA[<p>私以为这样的科幻是真正诗意的，文学的，而非仅是“文化的“。</p><a id="more"></a><p>（如有侵权，请联系博主。将于第一时间予以删除）</p><h1 id="创世纪"><a href="#创世纪" class="headerlink" title="创世纪"></a>创世纪</h1><p>作者：孔炳翔</p><p>熵值已经接近了最高点。</p><p>所有文明都停止了战争，在不断临近的热寂面前苟延残喘。</p><p>宇宙已经黯淡无光，唯有深处有几点火光，那是低等生物在用仅存的物质合成恒星。这像是一片涸辙，大鱼们早早地感觉到了干涸的恐惧，潜在水底。而小鱼们还浅浅地浮在水面附近，浑然不知这即将到来的，光明的黯淡。</p><p>此外还有不少的暗点，那是高等文明，它们已经能够完全的使用恒星的光和热或是正反物质湮灭所释放出的能量，包裹它们母星的是一类类似黑体的物质，完全吸收外来的和内在的光线并储存。</p><p>更深处，还有一个暗点和一个光点，在互为中心相互旋转。</p><p>暗问：“你怎么让能量外溢了？你能制造逆熵场了？”</p><p>光：“我不能，但我愿意。”</p><p>“愿闻其详。”</p><p>光：“这是一个故事，或一首史诗，绝非一条物理定则。”</p><p>光的诗：</p><p>“只要我一息尚存，我就称你为我的一切。</p><p>只要我一成不变，你就感觉你在我的四周。任何事情我都来请教你，任何时候我都把我的爱献上给你。</p><p>只要我一息尚存，我就永不把你藏匿起来。</p><p>只要把我和你的意旨锁在一起的脚镣还留一小段，你的意旨就在我的生命中实现——这脚镣就是你的爱。”</p><p>超弦的震动传导着这首诗。暗点们隐藏在黑暗中，揣度着这宇宙的最高解读者之一的隐晦的诗句。</p><p>良久，暗问：“如果答案为爱，那么问题为何？”</p><p>……</p><p>光点挨个地黯淡，熄灭。不少暗点也无声无息地冷却。</p><p>光的光芒同样愈发地不稳定。</p><p>……</p><p>沉寂了许久的超弦再一次地抖动起来，不过这次应该没有听众了。</p><p>光：“你感觉到了吗，这个空间只剩下这里存在塌陷了。他们都熄灭了。我们是热寂屠刀下最后的生还者。”</p><p>“嗯”</p><p>“你想到什么了吗。”</p><p>“有点思路。就是从一个平行宇宙中窃取能量，先躲过热寂。再试试能不能躲到另一个宇宙里去。”</p><p>“那躲过热寂是有办法了，只是大坍塌不一定有办法。”</p><p>“你的光强越来越不稳定了。这就是你那首史诗的意义，你真能逆转熵了？”</p><p>“那我们打个赌吧。”</p><p>“好。”</p><p>“如果你能够在大坍塌前制造出让物质在两个宇宙间流通的通道，这就是你的胜利。而我，如果我的方法能成功，我会重新出现在下一次大爆炸中，继续我的文明。其他文明也会有尝试我的方法，从大坍塌中跳出来，我将这个方法命名为洗礼或是圣餐。”</p><p>“那这样宇宙的能量就会不断减少，宇宙就不稳定了。”</p><p>“不会的，这就是我从很早之前就一直在外放能量的原因。”</p><p>……</p><p>最后的最后。</p><p>……</p><p>光在一片耀眼的光芒中塌陷了，像是大坍塌的序曲。在灼目的闪光中隐约可以看到一块十字形的晶体在挥发。从最重的钚碎裂到了最轻的氢，氢则直接碎裂成中子、质子和电子。电子在高速运动中轰击在质子上中和成中子。中子碎裂成夸克，夸克碎裂成基本粒子，这片空间的普朗克长度。引力场、电磁场融入时间。</p><p>超弦也因这场序曲而沸腾。</p><p>“要是干了以后就完了，那么还是快点干。”</p><p>“Cogito， ergo sum.”</p><p>最后一切都归于沉寂。</p><p>暗细细地感受着引力场，除了她所压迫地这片空间，其他的各处均平坦而光滑。</p><p>全宇宙统一了温度、密度和时间。</p><p>未来的世界是银子的。</p><p>热寂。</p><p>白银时代。</p><p>超弦也沉寂了下来。</p><p>暗试着拨动了一下，一道细细地波传向了宇宙深处。她想了想，拨出一道旋律。</p><p>“就这样，让我独自面对这孤独的死亡。让大坍塌——这场没有客人的最后的晚餐见鬼去吧！”</p><p>在大坍塌前，它都回不来了。她想。</p><p>的确，这道波以超越光速的速度没入黑暗中，像是一位开拓者进入荒野，亦或是一头鲸潜入深海。</p><p>……</p><p>这无边的黑暗像是一个漫长而无月的夜晚在期待着一个黎明。</p><p>它期待着一句话。</p><p>“要有光。”</p><p>……</p><p>大坍塌后的那一刹那，时间终结。</p><p>“又有新成员了，老规矩。你的创世纪。”</p><p>这像是一个沙龙，黑暗中藏着很多身影。</p><p>“那好吧。”</p><p>“要有光！”</p><p>这个奇点便开始发光发热。它极欲爆炸，却听从于这黑暗中的意志。</p><p>“这个世界被光明笼罩，它限制了我不能同时是我却又同时不是我，那我就得有自己的身体。”</p><p>虚空中出现了一块球形的全反射体。</p><p>“这个宇宙不能没有物质，他本将依托于基本粒子而存在。并且它活着。”</p><p>宇宙膨胀了一点，能量迅速形成基本粒子，高速地在局促的空间里移动着。两者的转化达到了平衡。</p><p>“它不能是十维的，它是三维的。那这样我也得是三维的。”</p><p>随着长度、数目、温度这三个维度的建立，它也从球形转化为了十字形晶体。</p><p>“所有粒子都要保有量子纠缠，这样在大坍塌来临时，它们能重新聚拢成一点而这将通过超弦相作用。”它像是叹息了一声。“那这样，速度和空间位置就是相矛盾的了。与此同时，基本粒子就成为超弦在长度维上的震颤。”</p><p>无数冰冷的超弦穿透了它的身体。</p><p>“既然基本粒子是超弦的震颤，那么第一，它不会停止运动，第二，震颤又两个方向。这导致了两种完全相反的物质的存在，而我需要做的只有预定一个方向。”</p><p>它随意地朝一个方向拨动了一下，不同于它之前所做的，这次，它只是在长度维上，而不是在温度维上拨动。</p><p>“它得保障文明的出现。”</p><p>“它得有几种基本力来规定粒子的运动。”</p><p>他幻化出一个正N面体，一个在三维的长度维下就是球体的物体。这个物体最终定格在代表四的那个面上。</p><p>……</p><p>“它还需要一个能量源，和时间轴。”</p><p>“那就是我。”</p><p>“因为它因为我而存在。”</p><p>“我没有活着，也不曾死去。”</p><p>“Cogito， ergo sum.”</p><p>“它诞生之日，便是我消亡之时，它消亡之时，便是我归来之日。”</p><p>他率先成为一道能量流，融入这个奇点。</p><p>“那我们也该加入其中了。”</p><p>黑暗中的身影一一融入了这个奇点。</p><p>它像一颗心脏开始跳动。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 创作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【围炉夜话】对于国内计算机普及教育考核体系范式的简要批判</title>
      <link href="/2019/07/18/Toughts-Exams_Of_Computer_Courses/"/>
      <url>/2019/07/18/Toughts-Exams_Of_Computer_Courses/</url>
      
        <content type="html"><![CDATA[<p>日经，因为不开心。</p><a id="more"></a><p>（文章可能比较情绪化，一些观点会有失偏颇？欢迎批评）</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>咱不谈国内教材的风格问题，不谈谭浩强等经典教育家，不谈十年不更新的课件。咱就来看看现在高校中的计算机考核体系（考试制度、评分制度等等）中存在着哪些问题。</p><p>首先需要说明的是，此处涉及的计算机类课程是“计算机普及教育”性质的，是面向低年级学生的计算机基础课程，包括中学时的信息技术课程、大一的程序设计基础课程等，而非专业性较强的课程，后者因笔者尚未接触过故不作评价。</p><p>所谓考核体系中存在的问题，指的是计算机学科课程的考核无法客观全面地反映学生的能力，造成低能者高分，高能者低分的现象。当然，我并没有做统计，只能拿自己说事。个人看到这样的成绩比较不爽，写篇软文骂骂街，期盼一下更加让人（己）信服的计算机课程考核体系，仅此而已。</p><p>标题中所谓范式，指的是当前国内学校普遍采取的这种考核模式。不光浙大如此，大多数学校在计算机学科的考核模式上虽有差异，但总体而言还是如此的。个人比较不喜这样的考核模式，但也不了解其他的模式，对于墙外的教学也不甚了解，无法提出有指导性的教学改进意见。</p><p>对这种考核体系的厌恶是自中学时代开始的。从中学开始，我就不喜欢技术这门学科的考试，无论是信息技术，还是通用技术（这里不谈通用）。高一时候还能凭借着信息差稳拿信息技术的第一，但等到大家都明白这门课的套路后就发现它也就这样了。大家都满分，很没意思。（高中同学之前在寝室里吹水哪些课拿过第一的时候把信息拿出来吹，搞邪了你）倒是我会因为乱七八糟的问题满不了。难道分数不比别人高说明我不比别人强？怎么可能。难道每个分高于我的人都比我热爱计算机，都比我有程序设计的思想，都比我更理解算法？怎么可能。但分数就是摆在那里。很不爽。很不爽。高中的信息技术无法在思想深度上作拓展，只得在边边角角上挖坑，坑一坑考试技巧低的人。这到底有什么意思？设置这样一门考试是要考察什么？想不明白，于是我不选技术，选历史。</p><p>到了大学，本以为进了计院就不用再接触这些糟心的考试了，但还是事与愿违。</p><p>从浙江大学《C语言程序设计》《程序设计专题》课程的情况来看，这类计算机普及课程的考核一般会由project，平时参与情况，期中期末考三部分构成。其中后者为大头，占了50%~60%。我们便来谈谈这考试。不过在说考试之前，我们有必要关注，考试要考察什么。</p><h1 id="能力"><a href="#能力" class="headerlink" title="能力"></a>能力</h1><p>普及性的计算机学科，需要学生掌握哪些能力呢？中学课本中往往会有office、ps、flash（该换h5啦）的基础操作指南。这些好拿出来考试？有什么思维含量？通过简单的搜索就能掌握的记忆性的知识，完全没必要考察。让学生用文字描述具体的操作过程也挺蠢，有一种独到的滑稽感。说到底，我知道这些内容对中学生而言并非不重要，但感觉用传统的中学教学模式对待计算机课程就有种说不出的拧巴感。</p><p>还有呢？程序设计的能力，这实质上是对计算思维的培养，对逻辑思维以外一种独特而有效的解决问题的思维模式的培养，这是相当有价值的。教授一些简单的算法，一些常见的数据结构，足以打开低年级学生（尤其是中学生）的心智，让他们领略到计算机科学的魅力，而不是薪水的魅力。</p><p>把宏观的程序设计能力再细分，在具体的程序设计上，我们还需要具备对程序流程的理解能力，对意外事件的处理能力，对程序正确性与复杂度的分析能力，等等等等。虽然归纳地并不细，不过考试大抵也便是考察这些个能力。ok，那我们开始讲试卷，看看它能否较好地检验学生的综合能力。</p><h1 id="试卷"><a href="#试卷" class="headerlink" title="试卷"></a>试卷</h1><p>考试试卷会由多个部分组成：判断题（理论性较强），填空题（用大脑编译运行程序），程序填空题。这些部分分别能考察什么东西呢？首先是判断题，个人非常讨厌。有些理论书上没提看似值得深挖，但个人觉得真的没啥意思，举个例子：</p><blockquote><p>定义FILE  *fp; 则文件指针fp 指向的是（）。(1分)</p><p>A. 文件在磁盘上的读写位置</p><p>B. 文件在缓冲区上的读写位置</p><p>C. 整个磁盘文件</p><p>D. 文件类型结构体</p></blockquote><p>这种题目要考察什么？如果教师在课堂上对这一知识点有所强调，并能进行知识点的延伸，那这样的题目可作为检验听课情况的一枚试金石。可若是教师对此完全没有提，学生面对这样的题目要怎么办？虽然自学是重要的技能，但我们也应理清什么样的知识是好的，是值得我们投入时间的。计算机课程不是思想道德修养，它里头虽然也有理论，但切不可空谈理论而忽视实践。而在这样一类的题目中，实践的影子，何在呢？</p><p>虽然题库中存在许多这样无趣的题目，但无可否认的是，许多题目还是有一定价值的，能够帮助同学们检验知识漏洞。这是值得肯定的。</p><p>填空题最大的特点，就是没意思，和实际的工程比较脱节。它是在考察学生对于语法规则，简单的算法的理解能力，但笔者不认为这是一种合格的考核方式。且不谈优先级排序，++++++这种反人类题。填空题与工程的一大脱节便体现在考试的限制上，学生被要求不得打开编译器对程序进行调试。诚然，如果不这么做则填空题的区分度会大幅减少。但这样的规定也在很大程度上破坏了计算机课程可贵的实践性，这和程序填空题的弊端是一致的。本来一个编译运行，几个调试就能发现的低级错误，硬是成了所谓体现区分点的地方。这能区分个什么对语言特性的认识对编程范式的思索，只是停留在大众教育阶段的对于所谓“勤奋”“仔细”的筛选。想到大家在走出高考考场后仍要惦着曾经的那么一些无趣的行为模型，我比较无语。</p><p>至少我没有见到过有趣的填空题和程序填空题，虽然都会做，但做起来慌得不行，唯恐哪个细节又没注意到，感觉写下来的都是错的。事实也正是如此，总会因为trivial的错误错掉一些题（虽然中学老师教我们强调细节，不过在大学的context里，“仔细”的重要程度还是第一位吗？）。程序填空题的初衷是好的，希望考察学生对代码的阅读能力与对程序流程的认识。但不得不说这种形式实在不讨喜。码风的不一本应通过建立语言使用的共识（编码规范）来达到一定程度的消除，然而学校并未这么做。另外，对陌生代码细节的把控不当也是所谓“区分点”的一环，而这本应通过测试来消除的。</p><p>简言之，这三类题除了选择题尚可，对其他两类题鄙人均比较反感。虽然如此，我也不清楚什么样的题型是自己是大家所喜闻乐见的。感觉计算机学科就不适合笔试。加入一定量的编程题（不可以有码量巨大的模拟题）或许比较好吧，但浙大《程序设计专题》课程今年把编程题取消了，原因不明。</p><p>这里顺便吐槽一下PTA系统。死板的填空题检测机制不支持等价写法，程序填空题的评测系统简单粗暴连拼写都不帮你检查一下（变量名错了扣了一堆分，无语）。最让我不爽的是，编程题的题库里放了很多三流学校（浙大不知算不算）三流教师编写的牛逼题，什么答案输出4+-3i才能过，什么手动实现atof函数（还nm是残的，不支持指数写法），什么“题目主要是输入花费大量的时间，如查找出现超时，尝试多次提交。”我还能说什么呢？牛逼，真nmd牛逼。我不知道这样的题目能锻炼我什么能力，只知道我浪费了好多时间好多心情在这种没营养的东西上面。</p><h1 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h1><p>笔者眼中理想的计算机普及教育课程的评价体系相较于此前模式的改变，大抵如下：</p><p>提升project在评价中的占比，达到50%~60%。同时对project的拓展功能进行额外评分（拓展功能与正态分布不可得兼，不当让学生为了不被正太而将简单的project过分复杂化，加上许多“冗余”功能，使得恶性竞争的风气盛行。入门级的计算机课程是简单的，大家都能学得好，搞什么正态分布？猪头领导，不具体问题具体分析，不求是，当什么浙大校长），由教师、助教依据细则、个人判断进行评分。增加project的数目，包括小组project与个人project，两个短学期的课程中，前者一项（工作量较大），后者三项（工作量较小）为宜。互评作为签到性质的任务，在project的评分中只不占比重，只是平时参与情况的一部分，作为同学们相互学习的一环。同时恶意评分者当受到惩罚。</p><p>不取消期中期末考试因其还有一定价值，但应降低其比重至20%~30%。保证题库的质量，撤销同学们普遍认为没有价值的题目。教师当对所谓“考试技巧”进行强调，强调考试与工程的差异与考试本身的价值，本身的特点。考试要增加对伪代码的支持，简单粗暴的程序填空题当少，更能反映考生理解力和表达力（可用伪代码表达自己的想法）的简述题当有。添加一定量的编程题。</p><p>中学阶段的信息技术课程当向这样的模式看齐，尤其是浙江省的信息技术学科。</p><p>以上的方案不尽成熟，还是需要迭代优化的。（所以就鸽在这吧）</p><hr><p>开始于2019-07-03</p><p>完稿于2019-07-18</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【围炉夜话】互膜与卖弱——黑暗森林中的生存法则</title>
      <link href="/2019/07/18/Toughts-Wo_Laji_Nin_Niubi/"/>
      <url>/2019/07/18/Toughts-Wo_Laji_Nin_Niubi/</url>
      
        <content type="html"><![CDATA[<p>“我最菜了，您最强啦。”金牌玩家如是说。</p><a id="more"></a><p>没有问卷，没有调查。全程瞎bb，欢迎指责本菜鸡哪里说的不对。</p><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>说到卖弱，大家很容易想到NOI，ACM（IMO怎么没人卖？），想到某几个或某几十个大佬间互夸互卖，“我要退学啦”“我是真的菜”，或者，“还是您更强”“您多厉害啊”。（定睛一看，我们能看到一张强连通图，没有自环的那种（夸夸图），还有一张非常神奇的仅由自环构成的图（卖卖图））</p><p>其中可能有历史原因：一开始某些毒瘤学长喜欢这样，于是后辈也都染上了这种风气。不过这样只能保证风气的开端而无法保证其生命力，真正要维持互夸互卖的风气，还是由互夸互卖这一行为本身的特点决定的。这一Meme的生命力为何得以那么顽强呢？首先，我们需要确定我们需要考虑的问题是否属实，在什么条件下属实。</p><p>互夸互卖的风气着实是存在的，但它存在在哪里呢？在别的学科，比如人文社科的学科上，大家也这样吗？在相对一般的大学中，大家也这样吗？这些先不管，虽然它们和我们要考虑的变量间也存在着一定的相关关系而可作为证据佐证我们的观点（因为懒得调查所以懒得管）。我们来yy一下，在工信学子中，在计院学子中，互夸互卖为何能成为一种历久弥新的风气。</p><h1 id="计院？"><a href="#计院？" class="headerlink" title="计院？"></a>计院？</h1><p>是否计算机专业的学生更能膜人呢？从专业，蔓延到其他领域，似乎是这样。</p><p>计算机课程较适合自学，其起点较低而终点难以估量。于是，同一年龄段的学生间往往差异较大。另外，计算机学科的实践性也使得其与数学物理这样的学科有明显的差异，在计算机学科上的领先能直接表现为可见的成果：动不动就能搞看上去很厉害的项目。这能给其他同学造成较大的冲击。</p><p>这套理论听上去很正确？但它能够解释OI选手间的互膜吗？另外，所谓“看上去很厉害的项目”实际上并不一定有难度。世界上有很多封装好的轮子和实现好的库，许多项目只是调库而已，很容易实现，但效果往往不错。</p><p>个人认为，互膜始于计算机课题的难以描述，还有难以把握，而非其难解性。对于同一个问题，或许大家都有些想法。但是要把它具体地实现，则要考虑许许多多的细节，其中许多并不好描述。于是在问题比较复杂的情况下，对这样的问题的解答有一定“玄学”的特质。一段程序，它为何是正确的呢？它这样不可名状，逻辑这般诡异，却又能得出正确的答案？在能够理解者与无法理解者之间，仿佛存在着语言上的隔阂，虽然处理的都是一样的作业，但二者对程序的理解是完全不同的。这层隔阂，或许是造成互膜风气的一个重要原因。开始这样的“膜”是敬畏性的，但逐渐地它演变为游戏性质的meme。</p><h1 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h1><p>单纯把这一行为视为一种游戏的话，它似乎也有可探讨的余地。</p><p>互夸与互卖似乎是一体两面的，表面上，前者是对他人的赞同，后者是对自身的否定。其目的也是相同的，这在之后讨论。但在操作的难易度上，二者并不相同，夸人可以因人而异，抓住对方的vulnerability猛夸猛奶；卖弱则要更深入的挖掘自己，挖到什么宝都能拿出来卖，以增强说服力。夸和卖也要有新意，有气势，这样效果才好。</p><p>夸人-被夸-夸人-被夸……简单的闭环系统，或者简单的博弈。当然，决策也可以是多样的，比如夸和卖可以结合在一起，这样博弈树的当前节点便能得到转换，其走向也能得以改变：“哎哟，我哪有您强啊，您看看您，①②③；您看我多菜啊，①②③”……</p><p>虽然作为调剂而言，偶尔互膜卖弱还是好玩的。但频率多了会感觉这样的对话真的很像小孩子吵架，只不过内容从“我是你爸爸”“我是你爷爷”变成了“您多强啊”“不不不还是您更强”。追求一个虚无缥缈的无法达到的共识，无法达成的认同，这从方向上来说就错了吧。网络上的辩论家们也沉浸在类似的行为中，不过他们争执的内容也不太一样。重复性强迫行为。自虐。Fort-Da。</p><p>是否我们永远长不大？</p><h1 id="认知"><a href="#认知" class="headerlink" title="认知"></a>认知</h1><p>我们为何而互膜而卖弱？因为我们关心自己在他人眼中的形象。</p><p>感到弱小倒是很稀松平常的状态。在庞大的知识体系面前，在生活的无字之书面前。学得越多，越能感到前人已经将弯路都走遍了，可探讨的问题也探讨个遍了，但自己还有很多细节没明白，对于宏观的知识架构也不甚清晰。面对这样的知识大厦，感到弱小，或者更确切些，敬畏，再自然不过的了。我不相信存在热爱数学而不敬畏她的人。</p><p>但是由热爱、信念、意志出发的作研究，与一般的考试，又是两种状态。既然是敬畏，何必要宣扬呢？对于考试，我们在题目之外，也相当看中排名，会自觉地不自觉地关注自己的，别人的位次。</p><p>惧怕形象在他人心目中跌落不起。无法在成绩上做补救，只得在其他方面上做努力。不去想关于考试的细节，假装看淡一切。拒绝交流，做些无关紧要的事情，划水，摸鱼。</p><p>当然，情况也不尽然，以上是我的情形。不过其他情形也就不讨论了吧，没什么好讨论的，大抵在行为上表现出“卖弱”的同学可以分为四五类，每类有不同的特征。但总归，我们当为自己的言行负责。即便是真的不满意，总是表现出来也不免会让他人不舒服，这是客观结果。在游戏的同时应兼顾他人的感受，尤其是因考试而心情不佳的同学，这并不容易，但我认为是必要的，至少自己要做到（似乎，并非人人这么想，这不是普适的价值观）。</p><h1 id="态度"><a href="#态度" class="headerlink" title="态度"></a>态度</h1><p>所以面对这样的风气，我们该怎么做呢？随意。</p><p>以下是笔者的态度：</p><blockquote><p>世人皆浊，何不淈其泥而扬其波？</p><p>众人皆醉，何不餔其糟而歠其醨？</p></blockquote><p>毕竟，主要是你的综合能力，而不是你的言论，决定了你到底是什么嘛。</p><hr><p>初稿写于2019-07-02</p><p>完稿写于2019-07-18</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【围炉夜话】从设计的角度看《以撒的结合》</title>
      <link href="/2019/07/18/Game-The_Binding_Of_Isaac/"/>
      <url>/2019/07/18/Game-The_Binding_Of_Isaac/</url>
      
        <content type="html"><![CDATA[<p>并非严谨的考究，只是随便写写而已。</p><a id="more"></a><blockquote><p>以撒的结合是一款集合了推箱子、血统检验、少女换装、宠物养成等等元素的跨世代大作。——灰机wiki</p></blockquote><h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>游戏有多好玩，要素有多丰富就不讲了。初次对以撒感兴趣是因为它的名字，然后是游戏方式吧。在盗版游戏网站上下了羔羊，没玩多久，感觉不好玩，不太适应这种游戏模式，也不知道道具是干啥用的。于是就弃了。那时候大概是初一初二吧。</p><p>高中的时候班里流行元气骑士，我也跟风玩了一会，发现这种游戏模式和以撒很像，这时候能接受了。之后重新开始羔羊，打了几把，感觉不错，于是开始入正。</p><p>然后就是常规的入坑环节了。</p><h1 id="剧情"><a href="#剧情" class="headerlink" title="剧情"></a>剧情</h1><p>游戏究竟讲了一个怎样的故事？其实故事的逻辑并不重要。其中的一些细节也没必要深挖，如为什么天启只掉肉块/绷带，“afterbirth”是什么意思，为何又要设置“mega satan”。这些都是为游戏性，而非剧情服务的。拿hush来说，没有这个boss游戏在剧情上也是完整的，那它加进去的作用是什么呢？丰富boss的种类，给予玩家挑战。再如ultra greed，它不过是七宗罪之一的强化版，为何也是最终boss之一，有这样高的地位？因为游戏要加入greed mode，所以要加入跟这个模式相匹配的boss。从游戏性的角度考虑，这些困惑大都能迎刃而解。</p><p>而剧情也是开放的，没有真正的所谓结局。原版有十三个，重生又多了三个，胎衣又加了几个。那么故事究竟是如何的？无所谓，关键在于它能否打动你。</p><p>游戏中能打动我的点（重生版本），大致如下（<strong>严重剧透</strong>）：</p><font color="FFFFFF">①???结局，一些照片：全家福、带上妈妈的假发、独自一人不开心、愤怒的妈妈……祥和的音乐中，记忆远去，THE END。<br></font><font color="FFFFFF">②拿到cancer时，以撒会哭得更伤心。<br></font><font color="FFFFFF">③用眼泪和怪物对抗。<br></font><font color="FFFFFF">④“Are you sure you want me to die？”<br></font><font color="FFFFFF">⑤原版的海报中，光芒之下是绻缩的以撒，他的身边，是成千上万的腐烂血腥的觊觎的怪物。<br></font><font color="FFFFFF">⑥“子宫层”这个名字，以及其中噬咬的声音。<br></font><font color="FFFFFF">⑦妈心战斗背景音乐名为“Ventricide”，心之死；以撒战斗背景音乐名为“Infanticide”，弑婴。<br></font><font color="FFFFFF">⑧muligen的哭声，leech的叫声……Gurdling的表情与叫声<br></font><font color="FFFFFF">⑨“瘘管”“畸胎瘤”“枯萎卵”，它们的名称；“bloat”“the carrion queen”“枯萎卵”它们的形态。<br></font><h1 id="游戏性"><a href="#游戏性" class="headerlink" title="游戏性"></a>游戏性</h1><p>《以撒》中的元素有哪些呢？道具是为面板属性还有特殊能力服务的，故先来看属性吧。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>首先这个游戏要保障生存，所以要有血量和移速；为了生存还要杀怪，这需要射速和伤害。作为roguelike游戏需要引入更多要素，这先放在“其他”这一项中。简单划分一下，我们能得出基础属性大致能归到这几类中。</p><h3 id="玩家属性"><a href="#玩家属性" class="headerlink" title="玩家属性"></a>玩家属性</h3><p>（粗体字为可拓展可创新点）</p><p>①生存：血量、状态、<strong>受伤机制</strong></p><p>②攻击：伤害、距离、<strong>特效</strong></p><p>③速度：移速、射速、弹速</p><p>④其他：幸运等</p><h3 id="人物特性"><a href="#人物特性" class="headerlink" title="人物特性"></a>人物特性</h3><p>设计更多的可选人物更能激发玩家游戏的兴致，为使人物有特色，一方面要将不同人物的面板区别开来，但更要做的是给人物添加特点。《以撒》在这方面是通过人物初始道具及特性凸显人物的，比如Eve在一血时便能开启Whore of Babyron，???不可获取红心等。</p><p>这里还涉及了人物形象的塑造。总而言之，《以撒》中除Lazarus和Eden外的人物形象都较为独特而讨喜，个人尤其喜欢Eve、Azazel、Magdalene的形象，另外Magdalene和妈妈形象的相似及其恢复系特点则从侧面对剧情有所表现。</p><h3 id="眼泪属性"><a href="#眼泪属性" class="headerlink" title="眼泪属性"></a>眼泪属性</h3><p>除了基础的伤害、距离，特效就需要用到思维发散了。另外，伤害也能通过其他方式得到加成，如生成蓝苍蝇，烧伤或中毒效果。简单盘点一下，《以撒》中有这些个特效。</p><p>1.分裂（分击中分裂与直接分裂）：寄生虫或洛基的角、四眼蜘蛛</p><p>2.穿透（分穿透敌人与穿透地形两种）</p><p>3.击退：狗头</p><p>4.悬浮：反重力</p><p>5.状态变更(中毒/烧伤/迟缓/石化/恐惧）</p><p>6.追踪：弯勺者</p><p>7.蓄力：巧克力奶</p><p>8.爆炸：吐根</p><p>9.制造友军：猫套</p><p>10.变轨：除了各种worm外，还有镜像和妈刀，因为回程也算得上一种变轨</p><p>11.防御：隐形眼镜</p><p>12.吸引：奇异吸子</p><p>13.攻击方式变更：鲁多维科科技</p><p>……</p><p>这些并不好做归纳。但确实非常多样，非常给游戏性加分。</p><h2 id="地图与怪物"><a href="#地图与怪物" class="headerlink" title="地图与怪物"></a>地图与怪物</h2><h3 id="地形与地图结构"><a href="#地形与地图结构" class="headerlink" title="地形与地图结构"></a>地形与地图结构</h3><p>伤害类：刺、血</p><p>障碍：洞、石头</p><p>地图结构的总趋势是越下层地图越大目标房间越难找。而且越往下走，单个房间的难度一般也会更高。结合具体的地图说明或许更有说服力些。</p><h3 id="怪物"><a href="#怪物" class="headerlink" title="怪物"></a>怪物</h3><p>怪物的基础属性和玩家是类似的。所不同的是，怪物的攻击方式一般更加多样，除了“弹幕”，还可以以各种方式冲撞，放硫磺火（血束），招小怪等。</p><p>怪物的免疫方式也各有特色。The carrion queen就是个比较好的例子，虽然很蛋疼。</p><h2 id="道具"><a href="#道具" class="headerlink" title="道具"></a>道具</h2><h3 id="道具渊源"><a href="#道具渊源" class="headerlink" title="道具渊源"></a>道具渊源</h3><p>1.源自宗教：硫磺火、三位一体盾……分天使与恶魔两个方向</p><p>2.源自以撒的生活，包括很多腐烂的事物，如早餐中餐晚餐，Guppy相关的道具等</p><p>3.源自其他文化，包括其他游戏（魔法菇）、流行文化（十二星座）等</p><p>其中第三类看上去有些跟剧情不搭嘎，但也是合理的，不光是因为《以撒》并非剧情向的游戏。星座文化可能有些俗套，但在以撒的视角中，这也没什么问题——以撒作为一个既有普遍性又特殊的美国小男孩，了解这些文化，玩各式各样的游戏是很正常的。</p><h3 id="道具形象"><a href="#道具形象" class="headerlink" title="道具形象"></a>道具形象</h3><p>如果是我来设计这款游戏的话，我会先把道具的功能设计出来，再考虑形象。不过如果捡了道具而角色形象完全没改变，游戏性可能会有所下降。在这个意义上，《以撒》“换装”的特点将其roguelike的特性发挥得更深了一层，虽然这并非游戏的主要功能，但着实是一个很漂亮的bonus。（但是，后面的服装会覆盖前面的，我觉得这样不够好）</p><h2 id="探索性"><a href="#探索性" class="headerlink" title="探索性"></a>探索性</h2><p>《以撒》在游戏要素的展现尚做得还是可以的。一开始玩家只能start game。死亡。重开。死亡。重开。打完妈腿，游戏结束了？子宫解锁。妈心。每次都有不同的结局。黑暗层，教堂。再来是宝箱层，阴间。再之后呢？好像并没有个名义上的终点。虽然打完哪个boss都可能是the end。但相信玩家并不总是有the end的感觉。</p><p>但之后游戏的探索性便比较弱了。毕竟游戏的剧情并不清晰，可探索的元素在游戏后期相对较少了。之后，《以撒》更像是个日常打卡游戏。个人在玩了70h之后感觉游戏要素已经较少了，我也不是成就党，所以游戏基本就扔栈底了。这样看来，《以撒的》生命周期至少有40h，对一些核心玩家而言会较长。</p><h1 id="画面"><a href="#画面" class="headerlink" title="画面"></a>画面</h1><p>血腥、黏着、腐化的环境，却并不阴暗，而是非常明亮，真讽刺啊。</p><p>总体的画风还是比较萌的，但是有的道具，细细一想，好瘆人的。铁丝衣架还好了，眼球突出就比较引人不适了。用可爱的画风吸引玩家并使之适应，同时制造出反差，这也算是游戏的特色吧。</p><hr><p>初稿写于2019年5月4日</p><p>完稿写于2019年7月18日</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计 </tag>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【围炉夜话】七月集训自省书</title>
      <link href="/2019/07/17/ICPC-Feeling-July/"/>
      <url>/2019/07/17/ICPC-Feeling-July/</url>
      
        <content type="html"><![CDATA[<p>（虽然是写给颜学长的作业，但感觉还是写出了些东西的，就把这篇放上来了。dl们轻喷鸭qwq）</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记得之前颜学长在群里说集训队中有空余名额而鼓励同学们主动申报时，自己内心还是非常忐忑的。虽然知道自己能力尚不强，短期内也难有较大提升；但还是很想能以此催逼自己学算法，以收获一段不一样的体验。以下，是当时自己对“为何希望参加ICPC”的回答：</p><blockquote><p><strong>1.为何希望参加ICPC</strong></p><p>- 想要收获一段富足的，紧张刺激的体验；</p><p>- 想要结识其他厉害的同学，收获友谊；</p><p>- 想要在算法能力上有进一步的提升，拓宽拓深自身的知识面。</p></blockquote><p>当然，我知道自己的能力还很有限，所以参加集训的主要目的是学习，同时希望在比赛中收获经验，提升自我。不过从七月中我的所为来看，自己仍心有余而力不足，提升得还不够，能力上还是差了厉害的同学一大截。这有心态上的原因，有思维结构上的原因，还和具体的能力也有一定的关联。不论如何，总归是一段经历吧。</p><h1 id="个人赛总结"><a href="#个人赛总结" class="headerlink" title="个人赛总结"></a>个人赛总结</h1><h2 id="contest-1"><a href="#contest-1" class="headerlink" title="contest 1"></a>contest 1</h2><p>这场总体而言打得不好，爆零了。一方面题目不太容易，另一方面自己的知识点还太薄弱，A题将kmp稍作变式就不会了，hash也出锅了。写题策略也不是很得当，一直在纠结没有人做的D题，废了挺多时间的，导致到了挺后面才开始看B题（虽然即便能逃出WA的命运还是躲不过TLE啊）。知识点薄弱，于是在将E题的操作抽象出来后沮丧地发现自己的数据结构水平碰不动这题。</p><p>A题想了想发现可以用last数组记录上一个位置，然后就是字符串匹配了，但是要更新节点。自己之前写的kmp是迭代地算出来的，不支持更新的操作，于是改用hash：$map &lt; deque &lt; int &gt; , int &gt;$，但不知道哪里出了问题，WA了三发。之后换成自己写的hash就过了。STL有些靠不住？</p><p>B题一开始看到有点怕，但想了想发现还好，就是个树上的dp，状态的转移很自然，但还是WA了，原因不明。听讲题组说还要先bfs一遍确定顺序，要预处理逆元……虽然这些都做了但还是T了，不知为何，常数太大了？</p><p>D的话一直在推式子，看看这个CNF如何转化为full CNF，但越想越感到它不好描述，就弃了。</p><p>E看了看发现这就是个带修改的区间第k大值问题，不会做，还需要学习。</p><h2 id="contest-2"><a href="#contest-2" class="headerlink" title="contest 2"></a>contest 2</h2><p>第二场作为出题组所以没有打，出的是比较水的H题。即便如此题目还是想了很久才想出来。思维一直比较乱，直到想到2i和2i+1中有且仅有一个odious number后才发现这题好简单。A题想的倒比较快，不过不是很严谨，只是大致觉得贪心是正确的。</p><p>C是二叉树染色（其实跟图论没关系好吧还是有些关系的，考察的算法是线性代数……）。这题如果当时做感觉肯定是不会的（自己肯定是疯狂找规律然后陷入自闭，在听到题解时诧异“啊这题要用矩阵快速幂？”），因为自己没有想到要把root和第i层的节点node看作是一条长度为i的起点为root终点为node的路径。这个抽象很重要。这样抽象之后，便可以把原题转化为一个求定长路径的满足条件的路径数的问题了。根据离散书上的结论，这可以用一个矩阵快速幂算出来。但是，题目所要求的并非叶子节点的路径数，而是所有节点的路径数。故而要求的不能是$A$，而得是$\sum A$。（然后还是不会做，我知道$\sum A = (E - A^{n+1}) \times (E - A)^{-1}$但我不知道在一些情况下逆矩阵并不存在……）而这可以靠矩阵维护，很奇妙。从这题中回（xue）顾（xi）了一下线代中的一些套路。</p><p>在D，火柴人这题上微微锻炼了一下思维。这也是个贪心，不过没A那么显然。有点像求Euler path时的那种贪心：匹配后删边。为什么这样是正确的呢？看感觉吧……然后对于父親节点和父親的父親节点，还有父親的父親的父親节点的操作，他们并不是完全一致的，前两者是把儿子全删掉，后者就删一个儿子。为什么呢？画画图感受一下……所以一个bfs再加个reverse，自底向上地找火柴人再删边就好了。感觉自己对这类题（树上的操作）的理解还不是很深，还需要强化，否则下次碰到变式还是不会的。</p><p>E，并查集（棋盘区间合并）这题比较麻烦，比较锻炼综合能力。读入确是一个麻烦的点，但不应当一上来就搞读入，而要先设计好如何对题目中的操作进行建模。很明显，保存整个棋盘的状态是不可行的，空间不够。需要保存的也只有上一行的状态和这一行的状态。那么怎么将有交集的区间合并起来呢？感觉并查集比较好用，那就并查集吧。合并id，合并id对应的size。在最后找$id == pre[id]$。即可。并不好讲的，略显麻烦的综合题。</p><p>F是连分数的题。这个模型此前从没接触过，看到了一脸懵逼，不过跟着题解走感觉也还好，又学到了一些指不定用得上用不上的套路。先是找规律，发现分子/分母各满足一种递推关系。于是可以用矩阵维护这个递推关系。因为要支持单点修改和区间查询，就得把矩阵放到线段树上。也就差不多了。</p><h2 id="contest-3"><a href="#contest-3" class="headerlink" title="contest 3"></a>contest 3</h2><p>第三场感觉手感好一些，不过这场出了点锅，主要是A题，把一周前的原题摆出来这是认真的么……秒完A就是看E，思考了一段时间后顺利AC；再来是F，思考了更长时间结合了一些奇技淫巧后也成功AC。但做完这三题就没题做了……C拿手推SG函数推得手抽筋还没发现规律。B题看到suffix就心烦不想看。G没经验，不会。这场虽然我做得还可以，不过学长们感觉不行，一找找出好多道原题……集训前练了练和期望相关的题目，也学了学整出分块，A也有补。总体来说运气的成分也占了一定的比重吧。</p><p>秒掉了A题然后就是看E，没有想到容斥，感觉似乎能递推？设规模为n时答案为$f[n]$。考虑男一，他的位置是随意的。有$\dfrac{1}{2n-1}$的概率女一坐在男一旁边。这时候答案就是$Df[n-1]$。可若是女一不坐在男一边上呢？考虑把男一旁边的位置和女一旁边的位置合并为一对位置。无论是否cp坐在这个位置上，它对于答案都没有贡献。记有这样一对“坏位置”时规模为n的答案为$g[n]$。同样地，我们对$g[n]$进行化归。即可得到这样的递推方程$g[n] = \dfrac{1}{2n-1}f[n-1] + \dfrac{2n-2}{2n-1}g[n-1]$。而$f[n] = \dfrac{1}{2n-1} D f[n-1] + \dfrac{2n-2}{2n-1}g[n-1]$。初始条件想一想，两个式子同时遍历一波，答案就出来了（数竞的时候总要从这样一组递推方程中得到封闭公式，有了计算机的算力反而递推方程是更容易理解也更容易搞出答案的形式，学科有别啊学科有别）。</p><p>写完了E看F，也是期望dp。一开始算出来没有模MOD，算出来跟答案不一样，看了好一会儿才发现问题出在哪（好尴尬，估计出题人看到我的request会想笑）。想清楚了之后发现式子很好推，和整除分块好像。简单码了一码，交了上去，RE了，才发现没有把E换成calc_E。之后再是本地调，预处理了一下逆元以降低复杂度，然而又出锅了：inv预处理得不够大。于是之后代码就变成了算逆元又有费马小定理又有线性预处理的神奇版本……即便如此算得还是很慢。用clock_t算了一算，发现预处理很快，后面算很慢。于是用unordered_map记忆化一波，成功AC。</p><p>C还没补，状态的转移有两类，一类涉及增加的，要考虑边界。边界不会考虑，于是算出来的结果很奇怪很奇怪，不知怎么调整。</p><p>D涉及到快速求解大整数的质因子，还不会……</p><p>G感觉有些套路？线段树维护矩阵连乘。开始看到没想法，但其实和contest 2的F很像很像的。如果早点补题或许能把这题搞出来的……这样就不用纠结在C上面了。</p><h2 id="contest-4"><a href="#contest-4" class="headerlink" title="contest 4"></a>contest 4</h2><p>第四场比较难，一开始看题感觉啥也不会，慌得不行。大家做出来的题普遍不多，我也只做了一题，但是做得比较慢，因为对题意开始有些不理解，然后调参还调了很久。这场的节奏被几个陈题带偏掉了，于是大家都在看C和E，没有看（出题人说比较简单）的F和G。状态比较差，做完D之后就陷入了没题做的尴尬境地，想群论死活想不明白。B的复杂度也搞不对，C也是毫无头绪。其他题没有仔细看，又是决策失误啊决策失误。</p><p>作为签到题的D并不难，但我开始没有看出这是签到题，因为一开始没有正确理解题意，没想到只要求个$\Delta \theta$就好，反而七想八想想到奇怪的地方去了，给出题人send request还很尴尬地被no response。理解了题意就好做了，划两条公切线（开始只划了一条公切线，没有把微积分的本质掌握啊我orz），找一下几何关系，注意一下什么时候$\theta$要换成$\pi - \theta$，就差不多了。我一开始把概率的递推关系搞错了，导致$\sum P \not = 1$，搞了好一会才想明白。没有把微积分实质掌握还有一个反映，就是我以为区域是对称的然而并不是，只有下半边能取，上半边是取不得的。在这上头（$/ 2\pi$，不是$/ \pi$）又debug了老半天，拿python当计算器疯狂手工计算。虽然这点是比赛结束后才想到的，不过能凑出答案也是不错的。做得实在是慢啊。不过也算涨了些经验，之后碰到这类涉及浮点数的题时候会更顺手些吧。</p><p>E看着是个群论题？变换了好久才发现这个变换的实质：交换一三列，三列同时取反。然后就不会了……在四元那八种等价元素间一直在找特征值，死活找不到……这题还没补。</p><p>C有一万个人做出来但其实好难的咧……听说cjb，jsb他们当年都没人做出来……卡在这鬼题目上卡了一万年，心塞塞。</p><h2 id="contest-5"><a href="#contest-5" class="headerlink" title="contest 5"></a>contest 5</h2><p>又爆零了，菜本菜呀……</p><p>两个线代题都不会，第一个，A完全莫得想法。第二题，E对除法的处理不很恰当。想着凑出一个线性组和满足答案的形式，但怎么想怎么不对。而把未知量和已知量分离，再跑个高消则能解出答案。代码量略大，但思维难度不大，应当要想出来的。我不只是微积分没有掌握本质，线代也根本没有学清楚啊……这题补了却无法在99上面跑，也不知程序是否正确。</p><h2 id="contest-6"><a href="#contest-6" class="headerlink" title="contest 6"></a>contest 6</h2><p>虽然没有爆零但还是菜。</p><p>一来先把题目顺着过了一遍，A看着就慌，跳。B看着感觉比较套路，但没想法，也跳。C好可怕跳掉了。看到D还是稍稍有一点想法的，然后就死在这上面了。G看了看感觉做不出来，跳。E是关于LCS的较灵活的题，可能能做？但dp太差想问题想得乱七八糟的，也跳掉了。F被题意坑惨了……就算做题策略得当，我还能做出哪道题呢？也就罚时少一点吧。硬实力实在不行。</p><p>D题想了想，枚举最长边，枚举次长边，数形结合一下，可以直接找最短边。没有关注到数据范围的50000。一直WA一直WA，WA到怀疑人生。难道是这个-1的问题？嗯……终于T了！然后就没想法了，尝试分块，WA，再分块，WA，比赛结束。答案还没看。</p><p>F题发现题目中的点构成了一个特别特殊特别特殊的六边形。然后一个点染色，一个连通块的颜色就确定了！这样贪心地做就好了。一开始dfs，WA了。百思不得其解。之后感觉bfs更靠谱些，还是WA，奇怪奇怪。之后扫了一下classification，发现随意输出答案也是要顺序的……晕死了，浪费了一个小时加两发才A掉。这样下来F2也有想法了：对于每个连通块，维护一个结构，包含了未选区域的最小元、选区和未选区元素个数差、选了的区域和未选的区域。看上去很完美，叠了一层又一层的STL。然而……WA掉了？没有发现问题出现在哪里。</p><h1 id="对自我的剖析"><a href="#对自我的剖析" class="headerlink" title="对自我的剖析"></a>对自我的剖析</h1><p>（也就是颜学长强调的要写的“自己的长处短处”“以前认为的上一项”。不过我没有“以前”，就只好从零开始剖析自己的长短处了；作为非春季集训队成员，互评的任务也是没有的）</p><p>直视自己的弱小，找出权值最高的薄弱点，找出合理有效的解决方案，这是必要的。咱虽然能力不行，但可不能心态也不行呀。</p><p><strong>字符串</strong>：只会最基础的复杂度颇高的操作，对前缀函数等字符串相关知识点的理解还不够深。对较灵活的题目缺乏经验。亟需强化。</p><p><strong>动态规划</strong>：对动态规划没有很好的总结与系统性的认识，一般都是瞎搞而无法系统地对其进行分析与归纳。因为认识不深，能否做出题比较看运气。</p><p><strong>数论</strong>：（身为前数竞选手对于自己对于ICPC中的数论题不精颇感惭愧）打过一些基本的板子，如拓展卢卡斯定理，孙子定理，杜教筛的板子，并能对其有一定的认识，但认识并不深。碰到题目有时会陷入不知从何分析的境地。</p><p><strong>数值</strong>：做过的题不是很多，了解的结论也不是很多。</p><p><strong>图论</strong>：基础的知识基本掌握，但做的题还比较少，做题经验比较匮乏，看到较新颖的题会陷入不知如何分析的境地。</p><p><strong>博弈</strong>：了解一些基本模型，写过少量题，但没怎么做归纳。一般的套路还未掌握。能否想出来比较看运气，看思维是否和题目衔接上。</p><p><strong>计算几何</strong>：写过一些基本的板子：graham，旋转卡壳，最近点对，但对于灵活的题目还缺乏分析的能力。平时做的几何题也较少，经验较匮乏。</p><p><strong>数据结构</strong>：非常薄弱，许多模型都不甚了解。</p><p>总而言之，我并没有特别突出的强项，各个专题的能力差距不大，但对于数据结构和字符串还相当不擅长。</p><h1 id="出题总结"><a href="#出题总结" class="headerlink" title="出题总结"></a>出题总结</h1><p>这次出题还是比较顺利的，看得出来学长们经验相当丰富。一开始是大家各抛出一些idea，我想个了密码题，主要是思路题，但也有细节要处理，也要关注特判。抛完idea的第二天开始讨论，早上大家把自己的题大致说了一说，然后邓老板决定签到题、简单题、中档题的比例与题目的去留。</p><p>我在ICPC上与同学的交流还不是很多，于是听他们开会时有懵逼的感觉，很慌的感觉。大家都是简单讲一下破题的要点，涉及的算法，然后就没然后了。所以看着那些题而一点想法都没有的我颇有格格不入之感。虽然Odious Number看看没想法，但还是接下了邓老板的锅，把这题的题面、数据、标程搞掉。中午想了个dfs的做法，很麻烦，还要大数，用python写慢得离谱。之后观察了一下表中的数，猜出了一个结论，用C重写了一遍。这样出数据和标称的锅便可以拿下了。</p><p>之后又把题目从十六进制的输入输出，还有伪高精的数据范围，改成long long了，这样来放过更多的做法，让题目更签一些。</p><p>顺便也写了一写题解，帮D题审核题面，这是其他的工作。</p><p>感受的话，感觉大家都挺认真负责，出题的流程清楚明白很有可行性，各自的锅也能在ddl前赶完。</p><p>也从这次出题中理解了一些出题人的苦衷，明白比赛过程中为何频频会有announcement了。出题目不易呀……</p><h1 id="其他感想"><a href="#其他感想" class="headerlink" title="其他感想"></a>其他感想</h1><p>听讲座听得十脸懵逼，听着听着就会想睡，感觉思维有些跟不上主讲者的节奏。（听题解也是这样的）知识体系还太薄弱了。这样学得又累，收益又不大，心态又受挫，有些得不偿失的感觉？</p><p>集训的感受……感觉进步不是很大，在思维上的提升还不够显著，没能学到大家看待问题分析问题的思想。平时对题目的畏惧感也没有减轻，看题看题解看着看着就开始神游天外，或水手机，或睡觉……感觉自己还是曾经的自己，能力只线性地提升了一点点，学了些新知识，但对其的理解还不够深，无法举一反三。大家是怎么学习的呢？还没有观察出结论。</p><p>打比赛比较随缘，这不是恶补一下就能改变结果的，所以还是调好心态比较重要。赛后补题没有很紧迫地去做，因为有些心累。有时候会出现意志力下降的情况……这是比能力问题更严重的问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学之美】复变函数与拉普拉斯变换-金忆丹版：第一章 预备知识</title>
      <link href="/2019/06/29/Notes-Complex_Function-CH01/"/>
      <url>/2019/06/29/Notes-Complex_Function-CH01/</url>
      
        <content type="html"><![CDATA[<p>学复变函数嘛……首先不能不了解一下复数，复数的概念，复数的运算，复数与平面的关系，差不多了。</p><a id="more"></a><h1 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h1><p>一般来说，复数有三种表示：$x + y i, r(cos \theta + sin \theta i), re^{i \theta}$。三种表示各有其适用范围，前两者分别对应平面直角坐标系与极坐标系，而最后的表示法与极坐标系的表示有共同点也略有区别，一般来说它在运算上最为方便。</p><p>复数的模和辐角本身是独立的刻画复数的单元，故我们可以将二者分离来看。模是对于距离的刻画，很好理解，与模相关的知识要点则多和不等式相连结。至于辐角（$Arg z$与$arg z$），则要规定其范围。这样便可在$x + y i, r(cos \theta + sin \theta i)$两种表示间相互转化。（求辐角的规则有些麻烦，结合实例，比如$\pm 2 \pm 3i$感受更佳）</p><p>三种表示的共轭均非常简单，而能解决许多问题，降低运算复杂度。共轭的概念虽简单，但要灵活运用并不容易。另外，用共轭可以分离实部与虚部。</p><p>需要注意的是，复数更接近向量而非一般意义上的实数，是不可比的。复数集并非偏序集。</p><p>正如我们可以用实数刻画数轴一般，我们也能用复数（向量）来刻画坐标面。这便是复平面，在第三小节中将对其作进一步的探讨。</p><h1 id="复数运算"><a href="#复数运算" class="headerlink" title="复数运算"></a>复数运算</h1><p>将复数视作向量（即用$z = x + yi$看待复数），则加法同乘法非常好进行。至于除法，自然可以硬算，但是考虑$z \cdot \overline{z} = |z|^2$从而推出$z^{-1} = \dfrac{\overline{z} }{|z|^2}$显然更加优美，在计算上也更方便。</p><p>乘积的意义为何呢？在形式上，$z_1 = r_1 e^{i \theta_1}, z_2 = r_2 e^{i \theta_2}$，故而$z_1 z_2 = r_1 r_2 e^{i (\theta_1 + \theta_2)}$。考虑e的指数的意义，则能发现$Arg(z_1 z_2) = Arg(z_1) + Arg(z_2)$。故乘法的意义即旋转。</p><p>在这个意义下，除法作为乘法的逆运算，其意义也与上面相类似。</p><p>复数的乘幂和开方也是需要讨论的话题，比如求-1的四次方根，需要用到开方，而在此之前要先对乘幂有所了解。乘幂的形式，即$z = r e^{i \theta} \rightarrow z^n = r^n e^{i n \theta}$。</p><p>由这一式子可以引出de Moivre公式：，$r^n (cos \theta + i sin \theta)^n = r^n (cos n \theta + i sin n \theta)$，故有$(cos \theta + i sin \theta)^n = cos n \theta + i sin n \theta$，此即de Moivre公式（自然，它可以根据其他方式推出，不过这里我们实际上是是采用欧拉公式来推的）。</p><p>至于开方，经过推导，可以得到n个相异的根，其中第k个根$w_k = \sqrt[n] r  e^{i \frac{\theta_0 + 2k \pi}{n} }, k = 0, 1, 2, \dots, n-1$。把这些根放到复平面上看或可加深对其的理解，对复数乘积的理解。</p><h1 id="点集与复球面"><a href="#点集与复球面" class="headerlink" title="点集与复球面"></a>点集与复球面</h1><p>点集系函数定义域与值域的本质属性。在直角坐标面上，我们定义过点集。类似地，此处我们可以通过复数对其加以定义，只消将$\rho$替换为$|z|$即可。由此我们先后定义了邻域，内点，边界，有界/无界区域，曲线，单/复连通区域。</p><p>图形也可以用复数表示，如$|z - z_0| \leq R$表示一个圆域。在辐角、距离上加以限制，我们不难得到几类简单图形的复数表示。</p><p>（复球面详见书本，没图不好描述）</p><p>复球面的中心思想是将平面上的点与球面上的点做一一映射，从而将虚无缥缈的无穷远点转化为了看得见摸得着的北极点。可以用用$tan \theta$与实数轴间的一一映射与之作类比。</p><h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><p>①de Moivre公式的运用：用$cos \theta$与$\sin \theta$表示$cos 3 \theta$。（手算的复杂度为$O(n^2)$）</p><p>②共轭与模：或者$|z| = 1$或者$|w| = 1$，证明$|\dfrac{z - w}{1 - \overline{z} w}| = 1$。</p><p>③（瞎搞）若复数$z_1, z_2, z_3$满足$\dfrac{z_2 - z_1}{z_3 - z_2} = \dfrac{z_1 - z_3}{z_2 - z_3}$，证明$|z_2 - z_1| = |z_3 - z_1| = |z_2 - z_3|$。</p><p>④复数与多项式间的联系：若$w$为1的一个n次方根，证明$1 + w + w^2 + \dots + w^{n-1} = 0$。</p><p>⑤复数与不等式：证明在闭单位圆盘$D = \{ z \big| |z| \leq 1 \}$上，$|z^2 + 1| \leq 2$。</p><p>⑥数形结合：将$(1 + cos \theta) + i sin \theta$表示为指数形式。</p><p>⑦共轭：证明$\overline{(\dfrac{z_1}{z_2})} = \dfrac{\overline{z_1} }{\overline{z_2} }(z_2 \not = 0)$。</p><p>⑧共轭：证明实系数多项式$P(z) = a_0 + a_1 z + \dots + a_n z^n$若有一根为$z$，则$\overline{z}$也必为其根。</p><p>⑨复数与不等式（不会做）：$z_1, z_2$为复数，证明$|z_1 - z_2|^2 + |z_1 + z_2|^2 = 2(|z_1|^2 + |z_2|^2)$。</p><p>以上数题中，③不知其考点，⑨尚不会做，其他的题目较为灵活，知识点覆盖率也较高，结论也较有用，值得一做。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 数学_分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图灵之路】CF记-其三（2019-07-18更新）</title>
      <link href="/2019/06/29/ICPC-Practice_Codeforces_3/"/>
      <url>/2019/06/29/ICPC-Practice_Codeforces_3/</url>
      
        <content type="html"><![CDATA[<p>退役真快乐呀……</p><a id="more"></a><p>不知不觉，CF已经打了一个半个月。这一个半个月以来我收获了什么呢？我的rating能够反映出我认为我具备的实力了么？我题目补得，总结得怎么样呢？</p><h1 id="round-573-div2"><a href="#round-573-div2" class="headerlink" title="round #573 div2"></a>round #573 div2</h1><p>关键词：博弈，思维，模型转换，心态，其他能力</p><p>cjb他们参与出的<a href="https://codeforces.com/contest/1191" target="_blank" rel="noopener">题</a>，好难呀……其实并不难（第二套补完的题！），但我为何还是做不好呢？前面的题过的还是快的，但之后做得就比较糟糕了。一直卡在D这个博弈题上怎么想也想不出来，没有仔细看E和F。虽然E也是博弈题，过的人更少，但其实第二天看了看我还是比较有想法的。可能是看到翻硬币游戏就有点害怕不敢细想吧，不应该害怕的。F也没有仔细看，其实模型转化一下我也是能做出来的。做题之外的其他能力，良好的心态，自信与任性间的平衡，我还不够，需要提升呀。</p><p>DE两个博弈题均不套路，能够锻炼思维。F要先转换模型，我在比赛时这点做得还不够。F在转换模型后是问区间权值的问题，可以用树状数组处理。</p><h2 id="ABC"><a href="#ABC" class="headerlink" title="ABC"></a>ABC</h2><p>A题太水不讲，C题也就是个模拟，边界注意一下就好了。</p><p>B题是个模拟题，给你三张麻将牌，牌有数字也有花色。问至少还要拿几张牌（自己指定花色和数字）才能凑成一对“koutsu”或者“shuntsu”，前者是三张完全一样，后者是同花色，数字连续。</p><p>看上去用一堆if就能搞定？但如何保证if没有漏掉的呢？我是这么做的，把现有的三张牌按数字排序（这样判数字相差多少更方便），然后判是否它们构成了一对“koutsu”或者“shuntsu”。若无，再两两判，判是否有同花色同数字的牌，或者同花色数字连续（相差为1或2均可）。这样代码也比较清晰。</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>题意：有n堆石子，Alice和Bob轮流选一个有石子的堆，拿走一个。失败条件：当前没有堆有石子可拿，或者当前玩家拿完石子后出现两堆的石子数一样。（初始局面可出现若干堆石子数重复）</p><p>首先考虑这样的一种必败态：A在第一步会马上输掉。第一个条件就是00000……，我们看第二个条件，就是说A无论拿了哪个堆中的石子，剩下必然存在两堆满足其石子数相等。</p><p>简单想一想，如果初始局面中有两堆石子数一样，A必须要从中选一堆拿掉，不然必败。那么A从中拿掉了一个还必败的情况，就有一下四类情形。比如说第一堆和第二堆都是n个石子，那么第一步必败的情形有1）n=0；2）存在第三堆有n-1个石子；3）存在第三堆有n个石子；4）存在有第三堆和第四堆都有m个石子。这些特判并不难进行，在排序之后。</p><p>如果初始局面没有两堆石子数一样，那么A必败的状态是怎样的呢？必然是01234……证明也容易，考虑最小元即可。</p><p>如果初始局面不符合上述两类马上必败的条件，那么我们先忽视第二个失败条件，考虑A和B一直进行游戏后的“最终局面”。事实上，最终的局面必然是01234……的一种排列。为什么？因为最终局面中必然有0，若无，则游戏仍可继续进行。有了0，局面中必然有1，若无，则游戏仍可进行……数归证毕，虽然此处并未给出“最终局面”的定义。</p><p>最终局面的胜负是确定的，因为A和B采取最优策略，他们在局面可向合法局面转化时不会触发第二个失败条件。而如果用局面中的总石子数刻画一个局面的特征值，那么一种局面向另一种合法局面的转化必然使得特征值减一。故而，在特判以后可由初始局面的特征值和最终局面特征值之差的奇偶性判断初始局面为N位置抑或P位置。</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>题意：当前有n个硬币排成一列，给定其正反情况。Alice和Bob可以选择k个连续的硬币，把它们全翻成正面或全翻成反面。如果某玩家在进行操作后，所有硬币的正反性均一致，则其胜利。求A先手，A、B采取最优策略时A能胜利，必然失败，或是能够平局。</p><p>首先，题目有两种情形：游戏结束而不平局时硬币全为正面，或者全为反面。我们在下文中只考虑第一种情形，那么第二种怎么考虑呢？简单，把初始局面中所有硬币都翻转一下，把玩家的操作都翻转一下，就化归到第一种情形了。</p><p>考虑A在第一步能够胜利的情形，这很容易考虑：如果硬币中的0比较少，能够被k个1覆盖掉，也就是说最左边的0和最右边的0距离小于k，A就能马上胜利。我们用$lft[i]$表示i左侧（包括i点）最近的0所在的位置，用$rgt[i]$表示i右侧（包括i点）最近的0所在的位置。A能一步胜利的条件就是$lft[n] - rgt[1] \leq k-1$。</p><p>再考虑一下A在一步之后必然失败的情形，这要怎么处理呢？对A所有可能操作的位置进行判断。比如A把第3~k+2个位置的硬币全翻成0，那么只要判定第1~2个位置和第k+3~n个位置是否能被一段连续的1覆盖即可。这也可以用此前得到的$lft$和$rgt$数组处理。</p><p>如果A在走了一步，B也走了一步之后，局面还没有结束，那么剩下的局面必然是平局的。为什么呢？假设初始位置是N位置，但A走完一步局面还没有结束，那么B的位置是P位置。但是，B可以选择和A完全一致的操作，这样A的位置便成为P位置了。这和前面的假设矛盾！故，A走了一步B也走了一步局面还没结束的情形，必然就是平局。</p><p>以上程序涉及到一些细节没有说明，以代码的形式给出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> LL maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">2</span>][maxn];</span><br><span class="line"><span class="keyword">int</span> n, k, lft[<span class="number">2</span>][maxn], rgt[<span class="number">2</span>][maxn]; <span class="comment">// lft[1][] for the filpped situation</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++)</span><br><span class="line">        s[<span class="number">1</span>][i] = (<span class="number">1</span>^(s[<span class="number">0</span>][i]- <span class="string">'0'</span>)) + <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; maxn;i++)</span><br><span class="line">        rgt[<span class="number">0</span>][i] = rgt[<span class="number">1</span>][i] = len+<span class="number">1</span>; <span class="comment">// init the array "rgt" to avoid special judge</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> flip = <span class="number">0</span>;flip &lt; <span class="number">2</span>;flip++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ptrl = <span class="number">1</span>, ptrr = len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++)</span><br><span class="line">            <span class="keyword">if</span>(s[flip][i] == <span class="string">'0'</span>)</span><br><span class="line">                <span class="keyword">while</span>(ptrl &lt;= i)</span><br><span class="line">                    rgt[flip][ptrl++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">            <span class="keyword">if</span>(s[flip][i] == <span class="string">'0'</span>)</span><br><span class="line">                <span class="keyword">while</span>(ptrr &gt;= i)</span><br><span class="line">                    lft[flip][ptrr--] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(lft[<span class="number">0</span>][n] - rgt[<span class="number">0</span>][<span class="number">1</span>] &lt;= k - <span class="number">1</span> || lft[<span class="number">1</span>][n] - rgt[<span class="number">1</span>][<span class="number">1</span>] &lt;= k - <span class="number">1</span>) ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ans == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> lose = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> flip = <span class="number">0</span>;flip &lt; <span class="number">2</span>;flip++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n-k+<span class="number">1</span> &amp;&amp; lose;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(lft[flip][i<span class="number">-1</span>] &amp;&amp; rgt[flip][i+k] != len+<span class="number">1</span>) lose = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(lft[flip][n] - rgt[flip][i+k] &gt;= k) lose = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(lft[flip][i<span class="number">-1</span>] - rgt[flip][<span class="number">1</span>] &gt;= k) lose = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(lose) ans = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"tokitsukaze"</span>);</span><br><span class="line">    <span class="keyword">if</span>(ans == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"quailty"</span>);</span><br><span class="line">    <span class="keyword">if</span>(ans == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"once again"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><p>题意：平面上有n个点，其坐标给出。每次你可以在平面上圈定一个区域，区域由$x_1, x_2, y_b(x_1 &lt; x_2)$唯一确定，包含了满足$x_1 \leq x \leq x_2, y \leq y_b$条件的所有$(x, y)$。定义$S$为区域$R$中包含的题目中给出的点的集合。定义$R_1 \not = R_2 \Leftrightarrow S_1 \not = S_2$。询问不相等的区域有多少种（除去只包含空集的区域）。</p><p>区域是连续的，不好处理。与$R$相关联的$S$是离散的，相对好处理一些。怎么确定所有可能的$S$呢？我们从$S$中的元素来着手。注意到，y更小的元素被包含时，y更大的元素更可能被包含；而y更大的元素被包含时，y更小的元素可能不被包含。故而，我们可以根据y从大到小对每个点进行遍历。比如y最大的点有4个，忽视下方的点。那么这样可能的$S$有$4 \times 5/2=10$ 种。更一般地，如果“一行”中有k个点，那么可以生成 $k(k+1)/2$个集合。</p><p>至此，我们形成了一个朴素的解决问题的框架：把点按y从大到小遍历，把上一行的点压到下一行中，计算其对答案的贡献。写成伪代码，也就是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; set_of_x;</span><br><span class="line">sort(points, points+n, cmp);</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>, r;l &lt; n;l = r)</span><br><span class="line">&#123;</span><br><span class="line">    r = l;</span><br><span class="line">    <span class="keyword">while</span>(r &lt; n &amp;&amp; points[r].y == points[l].y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!set_of_x.count(points[r].x))</span><br><span class="line">        &#123;</span><br><span class="line">            set_of_x.add(points[r].x);</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += (<span class="number">1L</span>L*k*(k+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个思路看上去非常的正确，但我们要注意到它把上一行直接“压下来”，这个过程是对答案有影响的。比如考虑题目中给出了$(5, 6)(2, 3)(3, 3)$三个点。在处理到第二行的时候，$k=3, k(k+1)/2=6$。但是这6个集合中有与前面枚举的集合重复的！$\{ (5, 6) \}$。</p><p>所以我们不能这么直接粗暴地把上面的行压下来，而是要注意到，枚举这一行的时候，这一行的元素必然要在集合中。故而可以用集合的差去做：要把这行中计算出来的，仅由上面的行的元素所构成的集合减去。</p><p>而这要怎么进行呢？我们再把points按x进行排序，那么，如果一行中的$p_1, p_2$中间夹了一些上一行的点，那么这些点构成的集合要减去，而且只要把它们减掉就能得出答案！这不难证明。（当然，还要关注在此一行最右边的点右上角的点）</p><p>于是，我们需要计算$x_{p_1}$和$x_{p_2}$中夹杂了多少上一行中的点。这要怎么做呢？我们可以把所有x值先离散化，然后用树状数组记录权值（每个点出现与否）前缀和来做。</p><p>上代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span><span class="keyword">int</span> x, y;&#125;nodes[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node&amp; lhs, <span class="keyword">const</span> Node&amp; rhs)</span></span>&#123;<span class="keyword">return</span> lhs.y &gt; rhs.y || (lhs.y == rhs.y &amp;&amp; lhs.x &lt; rhs.x);&#125;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; set_of_x;</span><br><span class="line"><span class="keyword">int</span> x_unique[maxn], n, n_unique;</span><br><span class="line"><span class="keyword">int</span> tree[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;<span class="keyword">return</span> num&amp;(-num);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> begin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = begin;i &lt;= n_unique;i += lowbit(i))</span><br><span class="line">        tree[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> begin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = begin;i &gt; <span class="number">0</span>;i -= lowbit(i))</span><br><span class="line">        ans += tree[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;nodes[i].x, &amp;nodes[i].y);</span><br><span class="line">        x_unique[i] = nodes[i].x;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(x_unique+<span class="number">1</span>, x_unique+n+<span class="number">1</span>);</span><br><span class="line">    n_unique = unique(x_unique+<span class="number">1</span>, x_unique+n+<span class="number">1</span>)-x_unique<span class="number">-1</span>;</span><br><span class="line">    sort(nodes+<span class="number">1</span>, nodes+n+<span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">int</span> sz = <span class="number">0</span>, sz_lst = <span class="number">0</span>;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>, r;l &lt;= n;l = r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x_lst = <span class="number">0</span>, x_now;</span><br><span class="line">        r = l;</span><br><span class="line">        <span class="keyword">while</span>(r &lt;= n &amp;&amp; nodes[r].y == nodes[l].y)</span><br><span class="line">        &#123;</span><br><span class="line">            x_now = lower_bound(x_unique+<span class="number">1</span>, x_unique+n_unique+<span class="number">1</span>, nodes[r].x) - x_unique;</span><br><span class="line">            <span class="keyword">if</span>(!set_of_x.count(x_now))</span><br><span class="line">            &#123;</span><br><span class="line">                set_of_x[x_now] = <span class="number">1</span>;</span><br><span class="line">                add(x_now);</span><br><span class="line">                sz++;</span><br><span class="line">            &#125;</span><br><span class="line">            sz_lst = query(x_now<span class="number">-1</span>) - query(x_lst); <span class="comment">// x_now-1, not x_now</span></span><br><span class="line">            ans -= (<span class="number">1L</span>L*sz_lst*(sz_lst+<span class="number">1</span>)/<span class="number">2</span>); <span class="comment">// sz_lst for the number of points between x_p1 and x_p2</span></span><br><span class="line">            x_lst = x_now;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        x_now = n_unique;</span><br><span class="line">        sz_lst = query(x_now) - query(x_lst); <span class="comment">// don't forget this term</span></span><br><span class="line">        ans -= (<span class="number">1L</span>L*sz_lst*(sz_lst+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">        ans += (<span class="number">1L</span>L*sz*(sz+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="edu-round-68-div2"><a href="#edu-round-68-div2" class="headerlink" title="edu round #68 div2"></a>edu round #68 div2</h1><p>关键词：审题，树状数组归纳，扫描线</p><p>比较水的<a href="https://codeforces.com/contest/1194" target="_blank" rel="noopener">一场</a>，虽说如此rating也没涨多少，一个月才入蓝的辣鸡在此。</p><p>A题数归易证答案为2x。但答案真的是2x吗？应该加入特判：printf(“%lld”, min(2*x, n))。</p><p>C题模拟不谈，瞎搞就好了。（下次变量名不能再叫ptr_s, ptr_t了，敲得慢不说，还易混淆）</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>题意：麻烦，不想复述了。</p><p>这个鬼题目卡到比赛结束才卡出来。第i行若有$cnt_{r, i}$个点，第j列若有$cnt_{c, j}$个点。如果i行j列没交点，答案为$(n - cnt_{c, j}) + (m - cnt_{r, i}) - 1$。如果i行j列没交点，把最后的-1去掉。想这个东西想了半天，碰到边界就捉急，思路混乱的很。我应当清晰哪个是变量哪个是不变量，确定$cnt_{r, i}$和$cnt_{c, j}$不变再来结合有交点/没交点的具体例子看什么时候要-1什么时候不-1的。变量名的意义也要和草稿上的一样才行呀。</p><p>观察数据范围，$n, m$不确定，但$nm$是较小的。所以可以用$vector<char>$来存图。然后预处理$cnt_{r, i}$和$cnt_{c, j}$。一个点一个点扫过去，动态更新答案，这题就没了。</char></p><p>我一开始没有注意到$nm$是小量，以为图存不下，要在线处理。在线该怎么做呢？容易想到要保存$cnt_{r, i}$最大的这行$i_{max}$的信息。这是可以线性扫描得到的。得到了这行的信息，再考察所有$cnt_{c, j}$最大的$j_{max}$列（不一定一列）。因为i行j列没交点答案更优，所以找到没交点的就不必再找了。</p><p>但问题是，$cnt_{r, i}$最大的不一定只有一行，如果有多行怎么办呢？我的办法是把多行的有效信息都压进一行里：我们需要的信息是什么？也就是没有交点的格子。于是可以这般维护最大行的信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(rows[i] == rows[i_max])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)</span><br><span class="line">        <span class="keyword">if</span>(grids[j] == <span class="string">'.'</span>)</span><br><span class="line">            grids_max[j] = grids[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码是正确的，但是还要考虑其他杂七杂八的东西，写起来很麻烦，也容易出错。我一开始grids_max没有初始化，就出锅了。这样的代码也只能节省空间，对于全为$*$的那种图，时间复杂度完全没有降下去。不过个人觉得这个思路还是有一定价值的。</p><h2 id="D-1"><a href="#D-1" class="headerlink" title="D"></a>D</h2><p>题意：当前有n个石子，Alice和Bob先后轮流取石子，无法取者输。一次取的石子数只能是1，2，k。k由题目给定。</p><p>简单的博弈题，需要眼力。</p><p>通过k=4，k=5等情形时候的模拟，我们首先能够观察出来$k \not \equiv 0 (mod 3)$时这个跳k步是完全没有价值的，游戏等价于只能跳1步2步。证明？按n模3的情形分类，慢慢数归即可。</p><p>接下来思考$k \equiv 0(mod 3)$会怎么样。通过对k=3，k=6等情形时候的模拟，我们有理由猜想当前循环节为k+1。证明？按n模k+1的情形分类，慢慢数归即可。</p><p>所以这么漂亮的游戏是怎么构造出来的呢？</p><h2 id="E-1"><a href="#E-1" class="headerlink" title="E"></a>E</h2><p>脑子题，套不套路不清楚，起码之前自己是不会的。每每碰到这种模型便有慌里慌张的感觉，需要归纳总结。上次做到的略有相似的题是哪道呢……</p><p>（扫描线？知识盲区+1，学习ing）</p><p>题意：给定一些水平的线段和竖直的线段，求这些线段围成的图形中有多少个矩形。线段数、坐标点绝对值均$\leq 5000$。</p><p>首先，这是个枚举题，直接枚举两条水平的两条竖直的复杂度显然爆炸，得加速。问题在要如何加速呢？</p><p>一个$O(n^3)$的做法是对每条水平的线段求出与其相交的竖直线段的集合，扔到bitset里。然后枚举一对水平的线段，找与两者均相交的竖直线段的条数。这样的做法可以卡过去，也不知道为什么，比较玄学，菜鸡的我不会分析。</p><p>正常的解法是$O(n^2 logn)$的，和这个数据范围也很搭。我们先来把问题简化一下：如果竖直的线段是无限长的，那么我们若是枚举一对水平线段，便可以求两条水平线段的公共线段$[l, r]$。可以用树状数组在$O(logn)$的时间求出与之相交的竖直线段条数。这是一个（经典的？）子问题。</p><p>但现在竖直的线段不是无限长的，它要满足一定的约束条件：和我们枚举的两条水平线段在y轴上的投影均有交。这样的话，我们便不能预处理出树状数组了，而是要动态地更新。如何操作呢？把水平线段按y升序排序，每次枚举一对水平线段会得到$[y_1, y_2]$的一个区间，其中竖直线段必须要包含这个区间。根据这个需求，我们又可以将竖直线段按y2升序排序……下面的内容繁而不难，用文字较难表达出来，笔者便不再说明了，详见代码。这题最重要的是先要想到枚举的顺序，然后是看出树状数组能够处理这一问题，最后才是考虑各式各样的细节。</p><p>（对了，使用树状数组先要把坐标都转化为正值）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span><span class="keyword">int</span> x1, y1, x2, y2;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_by_y</span><span class="params">(<span class="keyword">const</span> Node&amp; lhs, <span class="keyword">const</span> Node&amp; rhs)</span></span>&#123;<span class="keyword">return</span> lhs.y2 &lt; rhs.y2;&#125; <span class="comment">// both for vert and hori</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; hori, vert;</span><br><span class="line"><span class="keyword">int</span> tree[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;<span class="keyword">return</span> num&amp;(-num);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> begin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = begin;i &lt; maxn;i += lowbit(i))</span><br><span class="line">        tree[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> begin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = begin;i &gt; <span class="number">0</span>;i -= lowbit(i))</span><br><span class="line">        ans += tree[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x1, x2, y1, y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">        x1 += <span class="number">5001</span>, y1 += <span class="number">5001</span>, x2 += <span class="number">5001</span>, y2 += <span class="number">5001</span>;</span><br><span class="line">        <span class="keyword">if</span>(x1 &gt; x2) swap(x1, x2);</span><br><span class="line">        <span class="keyword">if</span>(y1 &gt; y2) swap(y1, y2);</span><br><span class="line">        Node node = (Node)&#123;x1, y1, x2, y2&#125;;</span><br><span class="line">        <span class="keyword">if</span>(x1 == x2) vert.push_back(node);</span><br><span class="line">        <span class="keyword">if</span>(y1 == y2) hori.push_back(node);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(hori.begin(), hori.end(), cmp_by_y);</span><br><span class="line">    sort(vert.begin(), vert.end(), cmp_by_y);</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, sz1 = hori.size(), sz2 = vert.size();i &lt; sz1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(tree, <span class="number">0</span>, <span class="keyword">sizeof</span>(tree));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i2 = sz1<span class="number">-1</span>, j = sz2<span class="number">-1</span>;i2 &gt; i;i2--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; vert[j].y2 &gt;= hori[i2].y1)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(vert[j].y2 &gt;= hori[i].y1 &amp;&amp; vert[j].y1 &lt;= hori[i].y1)</span><br><span class="line">                    add(vert[j].x1);</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> l = max(hori[i].x1, hori[i2].x1), r = min(hori[i].x2, hori[i2].x2);</span><br><span class="line">            <span class="keyword">if</span>(l<span class="number">-1</span> &lt; r)</span><br><span class="line">            &#123;</span><br><span class="line">                LL num = query(r) - query(l<span class="number">-1</span>);</span><br><span class="line">                ans += (num*(num<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="round-574-div2"><a href="#round-574-div2" class="headerlink" title="round #574 div2"></a>round #574 div2</h1><p>感觉<a href="https://codeforces.com/contest/1195" target="_blank" rel="noopener">这场</a>的题都非常毒，题面不太好理解，看题面能看个半天。但为何大家还是过得这么快呢orz……</p><p>A题题意不太理解，稀里糊涂搞出来的……B题是个解方程没啥好讲的，怕sqrt出锅于是加了个误差检测但似乎并没必要？C题为啥也这么多人做出来呀orz……D题也是……碰到相性不佳的一场真是尴尬呀。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>题意：有2n个数，排成两行，每行n个。让你从中任取若干数，使得其总和最大，并且没有两个数在同一列。</p><p>本来以为两条对角线比一比就好了，没有想到这样的情况，思维不够缜密：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9 1 1</span><br><span class="line">1 1 10</span><br></pre></td></tr></table></figure><p>嗯……那我们来dp吧。考虑$dp[0][i]$是选取第i列上面元素时前i列的最大值，$dp[1][i]$是选取第i列下面元素时前i列的最大值。那么略加思索，我们可以列出这个式子：</p><p>$dp[0][i] = h[0][i] + min(dp[1][i-1], dp[1][i-2])$</p><p>为什么这样就可以了呢？数归一下或许就能理解吧……</p><h2 id="D-2"><a href="#D-2" class="headerlink" title="D"></a>D</h2><p>（鸽）</p><h2 id="E-2"><a href="#E-2" class="headerlink" title="E"></a>E</h2><p>题意：给定$n \times m$的矩阵，每个格子上面有数。让你求所有$a \times b$的子矩阵中最小值的和。（鬼题意看了好久才看明白……我英语太差了）</p><p>我们能否先处理出每个$a \times 1$的子矩阵的最小值，把它压成一个数，然后求这b个数所组成的新的$1 \times b$的子矩阵的最小值呢？这样就变成了RMQ问题了？不过是RMQ套RMQ而已。复杂度$O(n^2 logn)$。</p><hr><p>初稿写于2019.06.04</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图灵之路】CF记-其二（2019-06-29更新）</title>
      <link href="/2019/06/29/ICPC-Practice_Codeforces_2/"/>
      <url>/2019/06/29/ICPC-Practice_Codeforces_2/</url>
      
        <content type="html"><![CDATA[<p>下分真快乐呀……</p><a id="more"></a><h1 id="round-567-div2"><a href="#round-567-div2" class="headerlink" title="round #567 div2"></a>round #567 div2</h1><p><a href="https://codeforces.com/contest/1181" target="_blank" rel="noopener">戳我做题</a></p><p>（总算，分又升回来了。虽然还是刚进来的水平……）</p><p>A题是个还不错的签到题，让我想了一小会。对于第二问，在模的意义下思考可能更容易想。</p><p>B题……见着大数就烦。思路很简单，但是代码并不容易写。把数位的存储顺序弄乱了，捣鼓了半个多钟头。之后用python又写了一遍，还是python优雅呀。</p><p>C题当时看着有些烦，不过想了想感觉还是能做的。分析的思路就是从分析width=1的flag要满足什么条件，再到分析flag的width更长时答案怎么算。简单的预处理即可。</p><p>然后要注意这题的一个大坑点……预处理完一段颜色的len中，得到可能的flag中每段的长度为len1, len2, len3，注意构成flag的条件是len1==len2&amp;&amp;len3&gt;=len2而非len1==len2==len3！为什么？因为最后一段不需要完整。</p><p>（不会做，D题鸽）</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>这题的代码不难（easy version），但并不好想，或许可以锻炼思维能力吧。</p><p>思考一下题目中怎样能把两个territory merge在一起呢？就是它们要有一条公共边，横或纵。我们把只包含一个castle的territory或是由多个按上述规则merge而来的territory称为good。那么，如果一个大的territory能够通过一条横/纵的边分为两个good territory，则这个territory则good……</p><h1 id="round-568-div2"><a href="#round-568-div2" class="headerlink" title="round #568 div2"></a>round #568 div2</h1><p><a href="https://codeforces.com/contest/1185" target="_blank" rel="noopener">戳我做题</a></p><p>A排序一下，然后容易证明左右两点向外扩展能够得到最优解。</p><p>B的话原文中的一个字母可以得到若干位相同的字母，于是可以把同一类的原文划为一组……</p><p>C是贪心的思路，首先把占时长的人都筛掉。于是我一开始就维护了两个堆，一个大顶堆一个小顶堆，两个堆之间元素换来换去，于是就T了……连总时长大于M的情况都没筛。</p><p>但是根据此题的特点，$0 &lt; t_i \leq 100$，直接遍历即可，根本不需要维护堆。而且这样和桶排的思想也很类似，怪我没想到桶排咯……</p><p>D这题略恶心，因为有个干扰项，如何把这个干扰项去掉呢？我们关注公差d。如果d是a0，a1的距离，那么下面的判断就很方便了。如果不是，要么a0是干扰项，要么a1是干扰项，特判一下后面的距离是否均为d即可。</p><p>特判完后得到d为a0a1距离，怎么找出干扰项ak呢？注意到，$a_{k-1}a_k \not = d$，然后就好啦。注意一下细节。</p><h2 id="E-1"><a href="#E-1" class="headerlink" title="E"></a>E</h2><p>题意是给定一个矩阵，每次可以在上面画一条蛇，也就是任取一块$1 \times c$或是$r \times 1$的区域标上字母：a, b, c…画蛇是没有限制的，也就是可以在有字母的区域上标上新的字母。然后给定一张已经按照a, b, c…顺序画出蛇来的矩阵，问能否从中反推出每次画的蛇的坐标（r1, c1, r2, c2）。</p><p>考虑反推的思路，看矩阵中最大的元素，比如说，’d’。它必得连续地占据一行或是一列，如不然，矛盾。那么，如何判断它是否连续地占据了一行呢？首先，它必然只占了一列。于是，可以设col_occupied[maxn]和num_of_col_occupied来判断它占了几列，占了哪几列。如果它只占了一列，那么可以再遍历出它在这一列中row最小的行r1与row最大的行r2（这也正是所需输出的）。然后，从r1遍历至r2，即可判断’d’在此行中是否连续。</p><p>这样最大的元素可以确定了，那么第二大的元素，’c’怎么确定呢？不同于’d’在矩阵中出现的必然性（由’d’的最大性可得），’c’不一定会出现在矩阵中，因为它们可能都被’d’覆盖掉了，这样输出r1[‘c’] = r1[‘d’]即可。这是一种情况，至于’c’出现在矩阵中的情况，可以用类似判断’d’是否连续占据一行/一列的方法判断’c’是否只占据了一行/一列。</p><p>但是’c’不一定连续。因为比如’c’是横的，’d’是纵的，’d’可以覆盖部分的’c’。同时，我们在之前的操作中不能把’d’简单地替换为字母序更小的字母，这样很容易造成结果的错误。那么，如何处理呢？</p><p>比如说，’c’至占据了一列，其所出现的row最小的行行号r1，row最大的行行号r2。在[r1, r2]间出现了不是’c’的字母，有两种情况。第一种，无法从该矩阵中还原出蛇的画法。第二种，这个字母本来是’c’，但是被覆盖了。注意覆盖它的字母只能是字母序比它大的字母。</p><p>然后至于更小的字母，跟上面的处理方法是相似的。</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><p>考虑单个pizza，怎么判断它能否please多少人呢？比如ingredient为1，3，5，那么可以将这个pizza编码为一个price = price, bitinfo = 000010101, index = index的node，这样的node至多1&lt;&lt;9个，因为碰到bitinfo相同的pizza可以只取price更小的。bitinfo和pleasures的关系又如何呢？比如一个friend喜欢的ingredient可以编码为000000101。那么上面这个pizza就可以please他。两个pizza的话，考虑两个bitinfo取&amp;即可。</p><p>这样本来的枚举量是m^2，现在只是(1&lt;&lt;9)^2了，计算量少了好多呀！这都是bitinfo去重的功劳。虽然枚举量大大减小了，但怎么确定这种组和较另一种更优呢？首先是看pleasures的数目，这需要预处理每一种bitinfo所能please的人数，而这可以在读入每个人的时候处理</p><h1 id="round-569-div2-鸽"><a href="#round-569-div2-鸽" class="headerlink" title="round #569 div2(鸽)"></a>round #569 div2(鸽)</h1><p><a href="https://codeforces.com/contest/1180" target="_blank" rel="noopener">戳我做题</a></p><p>（第一套补完的题……留念）</p><p>A……嗯……很可爱，很纯真，在这样险恶的世界里是存活不了几分钟的……</p><p>B：给你一个数列{a}，可以把每位a[i]替换为-a[i]-1，问怎样替换能使得$\prod a_i$最大。</p><p>yy一下，负数的绝对值更大，所以负数越多越好。如果n为偶数，全部为负就好。n为奇数的话，至多保留一个正数，取绝对值最大的maxv还是最小的minv呢？（先把所有数都转为负数，方便讨论）把全部数乘一块，记作pi，把maxv转换为-maxv-1后|pi’| = |pi / maxv * (maxv-1)|，把这个式子和把minv转换的式子对比一下，带个值进去，就能发现转换maxv能得出更优解。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>给定双端队列，给定操作：将首位元素与第二位元素出队，将较大元插在队首，较小元插在队尾。问k次操作后队首前两个元素。</p><p>显然，队首元素单调不减，而最大元被垒到队首之后，操作等价于在把后n-1个元素形成的队列中的队首放到队尾，可以用模运算模拟。前面模拟的步数不超过n，用链表实现复杂度为$O(n)$。</p><p>P.S.deque真快，还不用特判，爱了爱了。</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>给你n*m的矩阵，你一开始在(1, 1)这个位置，每次可以用(dx, dy)跳一跳，比如(dx = 2, dy = 3)，就能从(1, 1)跳到(3, 4)了。每个(dx, dy)跳了一次就不能再跳了，比如你不能一直(-1, 0)这么跳。问你能否跳过所有点一遍。</p><p>找规律试试？考虑1*m的矩阵，怎么跳呢？因为不能一路(0, 1)，我们需要找到有规律的跳法。考虑$(1, 1) \rightarrow (1, m) \rightarrow (1, 2) \rightarrow (1, m-1) \rightarrow …$，这种跳法是可行的，它好在哪里呢？它对于一些难以用到的(dx, dy)的利用率高，一开始的$(0, m-1)$显然只能用一次，后面的也一样（其实是化归到子问题了，把(1, m)这样一个问题化归到(1, m-1)了，只是翻折了一下）。</p><p>于是对于n*m的矩阵我们也能遵循类似的跳法：$(1, 1) \rightarrow (n, m) \rightarrow (1, 2) \rightarrow (n, m-1) \rightarrow …$。（不过这样的话，每一步无法化归到子问题，只有遍历完两行后才算是化归到子问题）注意对奇偶分类讨论。</p><h2 id="E-2"><a href="#E-2" class="headerlink" title="E"></a>E</h2><p>有一个食堂，里面有n道菜，每道价格不一样，每道只有一样。有m个学生，各有bi块钱。学生买菜的策略是，总是买他买得起的最贵的菜。然后题目有q次询问，每次可以改变一道菜的价格或者一个学生的金钱数。问改变之后所有学生买完菜后，剩下的最贵的菜的编号。</p><p>（什么鬼食堂，每道菜只有一样，菜的价格还能差个几千几千的。学生也挺牛逼，每次只买一样菜。这很不社会主义啊。）</p><p>首先，题目中提到了学生是排着队买的，但通过yy我们能够知道，不论学生的顺序如何，他们全体买的菜都是那几样（个体在调整顺序后买到的菜可能会发生变化）。我们想想能否二分答案：从0-maxn中，最贵的还没有买的菜的价格是多少？这样的区间查询要怎么进行呢？我们可以搞个线段树，第i棵树上搞个标记，学生有i块钱就-1，存在有i块钱的菜就+1。如果标记&gt;0，就说明有菜剩着。这样进行区间修改也比较方便。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, q, a[maxn], b[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span><span class="keyword">int</span> l, r, v, lazy;&#125;tree[<span class="number">4</span>*maxv];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[index].l = l;</span><br><span class="line">    tree[index].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    build(index &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    build((index &lt;&lt; <span class="number">1</span>)+<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> target, <span class="keyword">int</span> mark)</span> <span class="comment">// mark == 1 ? meal : pupil</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[index].r &lt;= target)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[index].v += mark;</span><br><span class="line">        tree[index].lazy += mark;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    down(index);</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[index].l + tree[index].r) / <span class="number">2</span>;</span><br><span class="line">    change(index &lt;&lt; <span class="number">1</span>, target, mark);</span><br><span class="line">    <span class="keyword">if</span>(target &gt; mid)</span><br><span class="line">        change((index &lt;&lt; <span class="number">1</span>)+<span class="number">1</span>, target, mark);</span><br><span class="line">    tree[index].v = max(tree[index&lt;&lt;<span class="number">1</span>].v, tree[(index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>].v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(tree[index].l != tree[index].r)</span><br><span class="line">    &#123;</span><br><span class="line">        down(index);</span><br><span class="line">        <span class="keyword">if</span>(tree[(index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>].v &gt; <span class="number">0</span>)</span><br><span class="line">            index = (index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            index &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (tree[index].v &gt; <span class="number">0</span>) ? tree[index].l : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, maxv<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a+i);</span><br><span class="line">        change(<span class="number">1</span>, a[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, b+i);</span><br><span class="line">        change(<span class="number">1</span>, b[i], <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cmd, i2, x, *c, mark;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;cmd, &amp;i2, &amp;x);</span><br><span class="line">        c = (cmd == <span class="number">1</span>) ? a : b;</span><br><span class="line">        mark = (cmd == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        change(<span class="number">1</span>, *(c+i2), -mark);</span><br><span class="line">        *(c+i2) = x;</span><br><span class="line">        change(<span class="number">1</span>, *(c+i2), mark);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ask());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[index].l == tree[index].r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[index].lazy == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[index].l + tree[index].r) / <span class="number">2</span>;</span><br><span class="line">    change(index &lt;&lt; <span class="number">1</span>, mid, tree[index].lazy);</span><br><span class="line">    change((index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>, tree[index].r, tree[index].lazy);</span><br><span class="line">    tree[index].lazy = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="round-570-div3-鸽"><a href="#round-570-div3-鸽" class="headerlink" title="round #570 div3(鸽)"></a>round #570 div3(鸽)</h1><p><a href="https://codeforces.com/contest/1183" target="_blank" rel="noopener">戳我做题</a></p><p>（水题好多，在细节上处理地不是很好以致没有一发ac。不知假如参加的话能不能把E/H苟出来）</p><p>A：计算比给定数大的，最小的，满足各数位上的数之和模4余0的数。</p><p>这题注意一下数据范围，无需特判，枚举即可……</p><p>B：给定一个数列{a}还有一个数k，问能否将所有a[i]替换为b使得$|a_i - b| \leq k$。</p><p>开始想的是二分，但之后发现检测一下上界取不取得到就好了……</p><p>C：你有n格电，每次可以消耗a格并爽一爽或者可以消耗b格但不能爽，已知有k个回合，问你最多能爽几爽。</p><p>贪心地把尽可能多的B换成A就好了，不过要注意数据范围！int的话中间可能会溢出，这是个隐蔽的坑点。</p><p>D：你有若干种糖，每个个数不一。然后你要送礼，每种糖的个数不能一样，问你最多能送出多少糖。</p><p>用个map处理一下，一波遍历，就好惹（但在G上栽了，细节没考虑全？不是很想补……）。</p><p>F：给你n个数，让你选1个或2个或3个，使得选出来的数两两不能整除，求这1/2/3个数的和的最大值。</p><p>莫得思路（对剪枝的复杂度不太明白就没写，网友的思路看不懂）。</p><h2 id="E-H"><a href="#E-H" class="headerlink" title="E/H"></a>E/H</h2><p>题意可以理解为给定字符串，让你求它的长为n, n-1, n-2…的subsequence（不要求连续，比如’acd’是’abcd’的合法子串）有多少个（其实不需要求出全部，求出长为n, n-1, …直至k的子串数目就行了，这里的k不同于题目中的k）。</p><p>枚举组和再判重复杂度看上去大得可怕，我们考虑dp。令$dp[length][char]$表示长度为length，末尾字符为char的子串的数目（这样无法表示空字串，所以要记得特判）。这样就能递推了：顺序遍历给定字符串，读到一个新的字符ch时，若它在第k位，枚举$length = k \rightarrow 1, char = a \rightarrow z$即可。记得length得倒序遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LL ch_tail = str[i];</span><br><span class="line"><span class="keyword">for</span>(LL len = i<span class="number">-1</span>;len &gt;= <span class="number">1</span>;len--)</span><br><span class="line">&#123;</span><br><span class="line">dp[len+<span class="number">1</span>][ch_tail] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(LL ch = <span class="number">0</span>;ch &lt; <span class="number">26</span>;ch++)</span><br><span class="line">dp[len+<span class="number">1</span>][ch_tail] += dp[len][ch];</span><br><span class="line">&#125;</span><br><span class="line">dp[<span class="number">1</span>][ch_tail] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>需要说明的是，长为k的子串在数量级上与$C^k_n$较为接近，而题目中的n可大至100，这样k=50时dp不是会溢出吗？然而事实是上述代码能够ac。私以为，问题在于dp是通过加法递推得到的，可以看作计算机在运算时进行了模处理，这样中间虽然可能出现负数，但是在边界值上仍然是正确的。如果对此感到不放心，不妨对dp取模，这样更保险些。</p><h1 id="round-571-div2-鸽"><a href="#round-571-div2-鸽" class="headerlink" title="round #571 div2(鸽)"></a>round #571 div2(鸽)</h1><p><a href="https://codeforces.com/contest/1186" target="_blank" rel="noopener">戳我做题</a></p><p>（A是什么东西，现在签到题都这么送的吗？？？）</p><p>（B好像是个假题，把好多人坑惨了。幸好这场没打，复习雾理要紧。）</p><h2 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h2><p>给定bit string a与b，a比b长，问a有多少子串满足和b异或以后有偶数个1。（这里的子串必然是连续的，和b等长的。比如a = ‘001100’, b = ‘001’时a的子串仅有’001’, ‘011’, ‘110’, ‘100’四种，它们和b异或后分别为’001’, ‘010’, ‘111’, ‘101’，有偶数个1的仅有’101’一项。）</p><p>直接模拟的复杂度高达$O(n^2)$，稳超时。然后这个操作和线性反馈移位寄存器(LFRS)的操作好像有点像？我们考虑递推。比如a的子串从’001’变到’010’，第一个0变成0，和b第一位异或必然不变；第二位从0变到1，第三位从1变到0，异或后都发生改变。于是，从前一个状态变到后一个状态时异或和中1的个数的改变量即a的原子串满足，此位与下一位相异的位的位数。（有些抽象，拿上面的例子来看能更清晰地感受这种想法）于是可以通过前缀和记录从i位到i+len位中此一位与下一位相异的位的位数。O(n)。</p><p>（因为答案是询问模2余0的cnt个数，而非输出每个cnt，所以代码中的cnt只是与”真正的“cnt模2同余而非相等。）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> str1[maxn], str2[maxn];</span><br><span class="line"><span class="keyword">int</span> delta[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, str1, str2);</span><br><span class="line">    <span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(str1), len2 = <span class="built_in">strlen</span>(str2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len1;i++)</span><br><span class="line">        delta[i] = delta[i<span class="number">-1</span>] + (str1[i] != str1[i<span class="number">-1</span>] ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len2;i++)</span><br><span class="line">        <span class="keyword">if</span>(str1[i] != str2[i]) cnt++;</span><br><span class="line">    <span class="keyword">if</span>(cnt % <span class="number">2</span> == <span class="number">0</span>) ans++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len2;i &lt; len1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt += (delta[i] - delta[i-len2]);</span><br><span class="line">        <span class="keyword">if</span>(cnt % <span class="number">2</span> == <span class="number">0</span>) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过细节处理略麻烦：边界的处理，delta的意义（是第i位与i+1位的异同，还是第i位与第i-1位的异同？）。在手工演算的同时，可以通过调整input中的数据边界判断边界处理是否妥当。</p><h2 id="E-3"><a href="#E-3" class="headerlink" title="E"></a>E</h2><p>有点烦的题。给你一块地，比如说这样一块2×3的地：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">010</span><br><span class="line">110</span><br></pre></td></tr></table></figure><p>然后这块地可以拓展程这样一块(2×2)×(2×3)的地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">010 101</span><br><span class="line">110 001</span><br><span class="line">101 010</span><br><span class="line">001 110</span><br></pre></td></tr></table></figure><p>如果把原来的地记作A，那么拓展后的地就可以记作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A  A&apos;</span><br><span class="line">A&apos; A</span><br></pre></td></tr></table></figure><p>其中A’由与A同行同列全为1的矩阵和A异或得到。</p><p>地可以无限拓展。题目问的给定这样一个子矩阵，知道其左上角坐标，知道其右下角坐标，问子矩阵中1的个数有多少。</p><p>怎么做呢？考虑二维dp。如果能求出(1, 1)到(x, y)这样一个矩阵中1的个数，那(x1, y1)到(x2, y2)的矩阵自然也不在话下。因为题目中x, y高达1e9，所以打表显然不现实。我们能求出来的也就只有$dp[n][m]$这个量级，再大的要怎么算呢？</p><p>注意到，很大的一块地中包含了许多小地。如果能求出小地中1的个数和小地的数目，那也很方便算。而注意到所有经过了一次拓展得到的2n×2m的地中1的个数都是相同的，我们就把这样一块地记为一个基本单元，B，其逆为B’。比如说，x = 6n, y = 4m，那么它包含了3×2个这样的基本单元，不管是B还是B’，里头1的数目都是一样的，这样算出来就是$dp[2n][2m] <em> (6n / 2n) </em> (4m / 2m)$。</p><p>但是大的地不一定都是上面那样规整的，比如，x = 6n + 2，这要怎么办？通过画图我们能得知，这样在竖直方向多出来了一点点，得把它补上。y = 4n + 3也这样处理。x、y都不规整还会多出来一个小矩阵。但多出来每一块的究竟是B还是B’的一部分呢？这可以通过递归得到。比如从左往右数第5个基本单元，它是由第1个基本单元，也就是B’异或得到的，所以它是B。如此。总之细节处理比较麻烦，结合图片理解更佳。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e3</span>+<span class="number">5</span>; <span class="comment">// caution! the basic unit is 2n*2m</span></span><br><span class="line">LL n, m, q;</span><br><span class="line">LL sum[<span class="number">2</span>][maxn][maxn]; <span class="comment">// 0 for original matrix while 1 for inversed matrix</span></span><br><span class="line"><span class="function">LL <span class="title">get_flag</span><span class="params">(LL c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">0</span> || c == <span class="number">1</span>) <span class="keyword">return</span> c;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>^get_flag(c-(c&amp;-c));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(LL r, LL c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    ans += ((c/m)*(r/n)*sum[<span class="number">0</span>][n][m]); <span class="comment">// part 1</span></span><br><span class="line">    LL dc = c % m, dr = r % n;</span><br><span class="line">    LL flag_r = get_flag(r/n), flag_c = get_flag(c/m); <span class="comment">// r/n for the number of fields in the row</span></span><br><span class="line">    ans += ((r/n+<span class="number">1</span>)/<span class="number">2</span>)*(sum[flag_c][n][dc]); <span class="comment">// part 2: the vertical</span></span><br><span class="line">    ans += (r/n/<span class="number">2</span>)*(sum[<span class="number">1</span>^flag_c][n][dc]);</span><br><span class="line">    ans += ((c/m+<span class="number">1</span>)/<span class="number">2</span>)*(sum[flag_r][dr][m]); <span class="comment">// part 3: the horizontal</span></span><br><span class="line">    ans += (c/m/<span class="number">2</span>)*(sum[<span class="number">1</span>^flag_r][dr][m]);</span><br><span class="line">    ans += sum[flag_r^flag_c][dr][dc]; <span class="comment">// part 4</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> grids[maxn];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, grids+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(LL j = <span class="number">1</span>;j &lt;= m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[<span class="number">0</span>][i][j] = sum[<span class="number">0</span>][i+n][j+m] = (grids[j] - <span class="string">'0'</span>);</span><br><span class="line">            sum[<span class="number">0</span>][i+n][j] = sum[<span class="number">0</span>][i][j+m] = <span class="number">1</span>^(grids[j] - <span class="string">'0'</span>);</span><br><span class="line">            sum[<span class="number">1</span>][i][j] = sum[<span class="number">1</span>][i+n][j+m] = <span class="number">1</span>^(grids[j] - <span class="string">'0'</span>);</span><br><span class="line">            sum[<span class="number">1</span>][i+n][j] = sum[<span class="number">1</span>][i][j+m] = (grids[j] - <span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n *= <span class="number">2</span>, m *= <span class="number">2</span>; <span class="comment">// basic unit: 2n*2m</span></span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    <span class="keyword">for</span>(LL j = <span class="number">1</span>;j &lt;= m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[<span class="number">0</span>][i][j] += (sum[<span class="number">0</span>][i<span class="number">-1</span>][j] + sum[<span class="number">0</span>][i][j<span class="number">-1</span>] - sum[<span class="number">0</span>][i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">        sum[<span class="number">1</span>][i][j] += (sum[<span class="number">1</span>][i<span class="number">-1</span>][j] + sum[<span class="number">1</span>][i][j<span class="number">-1</span>] - sum[<span class="number">1</span>][i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        LL r1, r2, c1, c2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>, &amp;r1, &amp;c1, &amp;r2, &amp;c2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, calc(r2, c2) + calc(r1<span class="number">-1</span>, c1<span class="number">-1</span>) - calc(r1<span class="number">-1</span>, c2) - calc(r2, c1<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="edu-round-67-div2"><a href="#edu-round-67-div2" class="headerlink" title="edu round #67 div2"></a>edu round #67 div2</h1><p><a href="https://codeforces.com/contest/1187" target="_blank" rel="noopener">戳我做题</a></p><p>A：给定n个gift，每个包含或者一个A，或者一个B，或者一个A+一个B。现给出n、A、B的数目。问至多要取多少个gift才能保证取到的gift中必然既包含A也包含B。</p><p>看到这题没啥思路……其实考虑最坏情形就好了：连着取到的都是只有A或者只有B的gift。设第一类有a个，第二类有b个，第三类c个。那么输出min(a, b)+1就好了。有点抽屉原理的思想？</p><p>B：给定一个字符串s，比如说是arrayhead。然后有q个查询，每个查询问的是某个字符串t，比如说’aaa’，要原字符串的从头开始的符合条件的子串的最短长度，这个子串包含了s中的所有字符（计数），比如’aaa’的例子答案为8，子串为’arrayhea’。</p><p>容易发现，t中字符的顺序是无关紧要的，重要的信息只有它各个字符出现的次数。于是，我们可以依据某字符频率在原字符串中进行查询，这样的话要先对原字符串进行预处理，得到一个$place[cnt][char]$表示这样的子串的最短长度，其能够匹配频率为cnt的字符char。于是代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> place[maxn][<span class="number">26</span>], occurence[<span class="number">26</span>], cnt[<span class="number">26</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[maxn];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ch = s[i] - <span class="string">'a'</span>;</span><br><span class="line">        place[++occurence[ch]][ch] = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, temp);</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="built_in">strlen</span>(temp)<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ch = temp[i] - <span class="string">'a'</span>;</span><br><span class="line">            cnt[ch]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">26</span>;j++)</span><br><span class="line">            ans = max(ans, place[cnt[j]][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>初稿写于2019.06.04</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图灵之路】CF记-其一（2019-06-29更新）</title>
      <link href="/2019/06/29/ICPC-Practice_Codeforces_1/"/>
      <url>/2019/06/29/ICPC-Practice_Codeforces_1/</url>
      
        <content type="html"><![CDATA[<p>下分真快乐呀……</p><a id="more"></a><p>（听到颜学长说要看CF rating时我是懵逼的：啥？这是啥？从来没碰过……不过既然选了课也只能硬着头皮上了。打得手很生，rating维持在基础分上……感觉要凉要凉，不过我还能怎么做呢？补题补题，弥补那，相距天际的差距。</p><h1 id="round-563-div2"><a href="#round-563-div2" class="headerlink" title="round #563 div2"></a>round #563 div2</h1><p>第一次玩CF……好紧张……这网站注册五个月了就没登进去过……</p><p>随便写写关于题解的随想吧……</p><p><a href="https://codeforces.com/contest/1174" target="_blank" rel="noopener">戳我做题</a></p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>（分析题，分析出关键的性质就能做了）</p><p>（一开始把题目看错了，看成是模2同余才能交换，心想这不就分奇偶排下序就好了嘛……码完代码就被测试数据piapia打脸）</p><p>不是很有想法。如果所有数奇偶性都相同这个情况是容易考虑的。可如果有奇数也有偶数呢？先考虑1奇n偶的情况吧。1奇1偶肯定能有序，1奇2偶呢？这个要分类讨论了，我的想法是把最小的数先移到最前面，之后化归到规模更小的情形。但是这样有个问题，就是如果最小数是那个奇数，比方说，输入数据为1, 6, 4，貌似会出问题……1, 6, 4能不能排成1, 4, 6呢？瞎搞了一下发现可以，于是乎，发现了一个奇妙的性质：只要序列中有奇数也有偶数，那么通过一个奇数（它的位置不会改变），任意两个偶数间也能交换位置。于是排序就是可行的了。sort之。</p><p>（可还是不知道这题在考什么<del>，群论？</del>）</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>（还是分析题……）</p><p>题目中说，任意两个互素的数，其f值不相等。这个条件初看比较别扭，也比较抽象，还是先把它具象化吧。</p><p>如果是素数的话，它的f值肯定不能和其他素数的f值相等。于是我们令f(2)=1, f(3)=2, …</p><p>至于合数呢？由题意，f的最大值不能过大，我们看看合数的f值能否和素数相等，可令f(合数)=f(该合数的某素因子)，为方便计算，不妨再令f(合数)=f(该合数的最小素因子)，即f(某数)=f(该数的最小素因子)。这样能否满足题意呢？</p><p>可以的！假如两数互素，它们的最小素因子必不同，而f是由一个数的最小素因子决定的。</p><p>这样分析完，上个欧拉筛就完事了。</p><p><del>其实令f(某数)=f(该数的最大素因子)更好算，直接埃氏筛就搞出来了，可是我没想到\cry\cry\cry</del></p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>（前缀和呀前缀和，我怎么就把你忘了呢）</p><p>嗯……题意是让你求一个数列，使得其任意子列全部元素异或后不能和0或x相等，且数列长度尽量长，答案有多组，任意输出一组（还有个条件：所有元素均小于2^n）。比如，x=5时候{6, 1, 3}满足条件，因为它的子列有{6}{1}{3}{6, 1}{1, 3}{6, 1, 3}，异或后分别为6, 1, 3, 7, 2, 4，都不等于5。</p><p>当时被“子列”这个条件困扰了好久，也不知道怎么样让数列长度尽量长（我的想法是，任意新添加一个元素，都会引发矛盾，但是这样复杂度巨大……），一直在玄学思考子列能推出什么，发现如果在数组的中间取标记点，向两边扩展，能够完美匹配题目中的条件，但是这样在细节上很难处理……线性计算复杂度太高，二分也不见得简单。</p><p>看到题目中说前缀和（其实是前缀异或和，不过反正思想是这个思想，将二维的子列化为一维的数组，级数也是这个思想）后，恍然大悟：</p><p>$a_l \oplus a_{l+1} \oplus … \oplus a_r = b_{l-1} \oplus b_r$（$b_i = a_1 \oplus a_2 \oplus … \oplus a_i$，由异或运算的交换律和自反率知，该等式成立）</p><p>这样的话，就不用考虑$a_i$，考虑$b_i$所成的数列就好了呀，因为$a_i = b_{i-1} \oplus b_i$。那么$b_i$，要如何考虑呢？</p><p>由题意，$b_i \oplus b_j \not = 0$，这说明$b_i \not = b_j$（异或的逆元是且仅是本身），还有$b_i \oplus b_j \not = x$，只要保证$b_i \not = (x \oplus b_j)$就好了。于是可以设个vis数组，逐个确定$b_1, b_2, …$，比如$b_1$确定了，那么$vis[b_1] = vis[x \oplus b_1] = 1$，后面的$b_j$不能取$b_1$或是$x \oplus b_1$。</p><p>因为交换$b_i$和$b_j$不影响答案的正确性，所以$b_i$是可以任取的。为方便记，不妨从小到大遍历，发现$vis[k] = 0$则取$b_i = k$。从这个过程可以看出，算法的复杂度为$O(2^n)$。</p><p>从这里也可以看出{b}的长度了。把$i$和$x \oplus i$看作是一对，那么一对中只能取一个。所以$len(b)$=可用的数的数量/2。</p><p>但是还要注意一下细节，题目中的输入数据也提示了：$x \geq 2^n$的时候，无需把$i$和$x \oplus i$看作一对，因为后者根本取不到。这个情况下$len(b)$=可用的数数目。</p><p>（开始把题目的数据看错了，看到18，就想到long long在十进制下约为18位，于是感觉这样的vis开不下，没有进一步往下想。<del>开了vis又如何呢，还不是做不出来</del>）</p><p>手是生了啊。</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>（需要分析的，较为复杂的dp）</p><p>题意稍微有点绕，它提到了一个f(p)，定义略奇特，我们用直观的例子体会一下这个f是怎么算的。</p><p>比如给定排列{6, 2, 1, 3, 5, 7}，求它前i个数的最大公约数，排出来，就是{6, 2, 1, 1, 1, 1}。这里头有三个不同的数，于是$f(p)=3$。</p><p>{1, 2, 3, 4, 5, 6}除了上面那种排列外，还有其他排列，算出来的$f$不尽相同，但总归是有最大值的，记作$f_{max}$。题目问的就是，n-排列中，有多少种排列，算出来的$f$等于$f_{max}$呢？</p><p>我们来看看那个前缀最大公约数的数列，粗略一看，它似乎是单调不增的，这很好证明。再一看，发现$g_i$和$g_{i+1}$是有关系的（$g_i$即前缀最大公约数数组的第i项），就是$gcd(g_i, g_{i+1}) = g_{i+1}$。</p><p>要想$g_i$的取值尽可能多样，我们要让它减少地尽量缓慢。将排列的首项，$a_0$，素因子分解，我们发现，$f = \sum \alpha_i$（算数基本定理的简单应用）。所以$f_{max}$就是$\sum \alpha_i$最大时候的取值。这个是数论上的内容。结论如下：f取最大值时，$a_0 = 2^x \cdot 3^y$，且$y \leq 1$。</p><p>（证明的话，就是替换的思想。如果$a_0$中有其他素数，比如说，5，那么我们可以令$a^{‘}_0=2<em>2/5</em>a_0$，这样$a^{‘}_0$打头时候得出的f必然比$a_0$打头时候得出的要大。同理可以证明$a_0$中3的指数小于2）</p><p>发现了这个结论我们该怎么算答案呢……看看题，感觉要dp？那么怎么指定状态呢？<del>参考题解发现</del>令$dp[i][x][y]$表示排列到前i个数时，最大公约数为$2^x \cdot 3^y$这一状态可以让我们很方便地算出答案。因为每次添加一个数，所以都是$dp[i+1][][] = dp[i][][] + …$，而要取到$f_{max}$，x、y可以保持不变或是x—或是y—，总共三种状态转移的模式。在添加第i+1个数时候，要考虑只能添加取符合要求的数，不能取已经取到的数。归纳一下，也便如下（伪代码，不是AC代码；和$dp[i][x][y]$相乘的那个数就是符合条件的第i+1个数的个数了）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i+<span class="number">1</span>][x][y] = (dp[i+<span class="number">1</span>][x][y] + dp[i][x][y] * (cnt(x, y) - i));</span><br><span class="line">dp[i+<span class="number">1</span>][x<span class="number">-1</span>][y] = (dp[i+<span class="number">1</span>][x<span class="number">-1</span>][y] + dp[i][x][y] * (cnt(x<span class="number">-1</span>, y) - cnt(x, y)));</span><br><span class="line">dp[i+<span class="number">1</span>][x][y<span class="number">-1</span>] = (dp[i+<span class="number">1</span>][x][y<span class="number">-1</span>] + dp[i][x][y] * (cnt(x, y<span class="number">-1</span>) - cnt(x, y)));</span><br></pre></td></tr></table></figure><p>下面是本题的坑点了……</p><p>不能用long long保存数据，会MLE，要用int，但是这样运算时候有可能溢出，怎么办呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i+<span class="number">1</span>][x][y] = (dp[i+<span class="number">1</span>][x][y] + <span class="number">1L</span>L*dp[i][x][y] * (cnt(x, y) - i)) % MOD;</span><br></pre></td></tr></table></figure><p>注意那个1LL……上次校赛的题也是。</p><p>（最后交上去，2s的时限跑了1965ms，也太不好玩了吧！O(nlogn)不是很优雅了么！本来想用bfs稍微优化一下的，但还是懒得弄了……）</p><p>（又把数字看错了，2^18 &gt; 1e6我是怎么算出来的……）</p><p>F题还没补，先放放。（Idleness？）</p><h1 id="edu-round-66-div2"><a href="#edu-round-66-div2" class="headerlink" title="edu round #66 div2"></a>edu round #66 div2</h1><p>模拟题杀我……贪心杀我……</p><p>（为什么edu没有答案啊啊啊啊还有edu是什么意思它和div什么关系啊啊啊啊）</p><p><a href="https://codeforces.com/contest/1175" target="_blank" rel="noopener">戳我做题</a></p><h2 id="B-1"><a href="#B-1" class="headerlink" title="B"></a>B</h2><p>复杂的模拟题……看着很烦，思绪很乱。感觉是对的结果交上去WA了，再改改又WA了。一天后突然想到自己是哪里没想明白，这才AC。</p><p>模拟题很烦，看上去不能够考察能力，但其实是能的。它能考察心态，考察对于问题的分析能力。这些，是我还不够好的。</p><p>先来读题。输出比较简单，那就看输出。输出分溢出与否两种情形。然后溢出也分两类，一类是小数加加加加爆了，还有是循环循出超级大的数然后一加就加爆了。这两类有何区别呢？区别在于，第一类可以直接模拟，而第二类不能直接模拟，需要记录是在哪一层会加爆，然后如果“ADD”出现在这层以上，就置flag=1。</p><p>大致想明白了输出要怎么处理，接下来是看输入了。输入有三类：“ADD”“FOR x”“END”，ADD用以模拟相加（还要看会不会出现上面的第二类情况），for和end共同构成一个循环。根据输入，我们可以设置一个loop[maxn]记录每层for的次数，设置一个looping_now记录当前需要ADD的值，同时记录一个depth_now记录当亲啊层数，设置一个depth_overflow记录加爆了的层数（超过此层，looping_now不再更新）。</p><p>于是我们可以写出这样的伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, cmd, &amp;x);</span><br><span class="line">    <span class="keyword">if</span>(cmd == <span class="string">"ADD"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(depth_now &gt; depth_overflow) <span class="comment">// case 2</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        ans += looping_now;</span><br><span class="line">        <span class="keyword">if</span>(overflow(ans)) <span class="comment">// case 1</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cmd == <span class="string">"FOR"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(overflow(looping_now * x + ans))</span><br><span class="line">            depth_overflow = depth_now;</span><br><span class="line">        <span class="keyword">if</span>(depth_now &lt; depth_overflow)</span><br><span class="line">            looping_now *= x;</span><br><span class="line">        loop[depth_now++] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cmd == <span class="string">"END"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        depth_now--;</span><br><span class="line">        <span class="keyword">if</span>(depth_now &gt;= depth_overflow)</span><br><span class="line">            looping_now /= loop[depth_now];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后便是处理细节了……</p><h2 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h2><p>是个思路题，问的是给定n个x轴上的不同位置的整点，让你找一个整点$p_0$，使得$p_0$到距$p_0$第k近的点的距离，比任意$p_{random}$到距$p_{random}$第k近的点的距离，来得小。k由题目给出。</p><p>简单想想，k=1或k=2的情况很容易考虑，但是如何将其推广到k更大的情况呢？我们注意到一个事实，即沿着一个点向左走，它所后经过的点一定远于它所先经过的点，向右亦然，但是左点的远近与右点的远近间没有关联。</p><p>那么，对$p_0$而言，如果距它第k近的点$p_k$在其右侧，则距它第k-1近的点$p_{k-1}$可以在左侧也可以在右侧。若在右侧，则可以把$p_0$向右移动一位，容易看出，此时$p_k$仍然为距$p_0$第k远的点（证明的话，反证）。于是我们可以重复此操作，直至$p_{k-1}$转移到$p_0$的左侧为止。</p><p>于是这样一来，我们得到$p_0$是被包围在$p_{k-1}$与$p_k$间的一点。让我们忽视$p_1, p_2, …, p_{k-1}$，因为既然它们同在这个“包围圈”中，那么$p_0$在这个“包围圈”中移动到$p_0^{‘}$位置时，这k-2个点的某个排列必然构成$p_1^{‘}, p_2^{‘}, …, p_{k-2}^{‘}$。</p><p>那么现在，问题就简化为：$p_0$在$p_{k-1}$和$p_k$之间，如何取$p_0^{‘}$使得它到两点中更远的点的距离最短？很显然，中点。（此时$p_{k-1}$和$p_k$都是形式上的记号，是固定的点，$|p_0^{‘} p_k|$不一定大于$|p_0^{‘} p_{k-1}|$。但这两点的排列必然构成$p_0$移动到$p_0^{‘}$位置时实际意义上的$p_{k-1}^{‘}, p_k^{‘}$。我们一开始选定的$p_0$是任取的。将此$p_0$进行移动所得到的最优的$p_0^{‘}$才是我们想要的答案）</p><p>然后上面得到的形式上的$p_{k-1}$和$p_k$要怎么确定呢？注意到只要中间包含了k-2个点的点对都可能符合要求，于是一波遍历就好了。</p><h2 id="D-1"><a href="#D-1" class="headerlink" title="D"></a>D</h2><p>给定一个n元数组，让你在其中放一些（k-1）隔板，使得从$\sum 从左往右第i个区块中所有数字的和 * i$最小。</p><p>看到一些数字的和，我们考虑前缀和（$s_i = \sum\limits_{j = 1}^i a_j$），设题目中的分点为$t_1, …, t_k$，则所求即$\sum\limits_{i = 1}^k (s_{t_i} - s_{t_{i-1}}) \cdot i$（$t_0 = 0, t_k = n$）。</p><p>这个式子可以写成$k \cdot (s_{t_k} - s_{t_{k-1}}) + (k - 1) \cdot (s_{t_{k-1}} - s_{t_{k-2}}) + … + 1 \cdot (s_1 - s_0)$。也即$k \cdot s_{t_k} - (s_{t_1} + s_{t_2} + … + s_{t_{k-1}})$。</p><p>其中$t_1, t_2, …, t_{k-1}$是我们选择的分点，$t_k = n$。所以把前缀和排个序就好了。（注意排序是sort(s+1, s+n)而不是sort(s+1, s+n+1)）。</p><p>下面是原思路……</p><p>给定的样例为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 2</span><br><span class="line">-1 -2 5 -4 8</span><br></pre></td></tr></table></figure><p>不难发现，将5，-4，8划分到第二组优于将8划分到第二组。为什么呢？因为5-4&gt;0。从8开始，我们向左找相加为正数的一个点，再找下一个点……这样的贪心思路。</p><p>（结合代码可能更容易理解我的思路，另外sum为后缀和而非前缀和……）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LL a[maxn], sum[maxn], next_node[maxn];</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(LL n, LL k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += (sum[<span class="number">1</span>] - sum[n+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL n_next = n;</span><br><span class="line">    <span class="keyword">while</span>(next_node[n_next] &gt;= k)</span><br><span class="line">        n_next = next_node[n_next];</span><br><span class="line">    ans += k*(sum[n_next] - sum[n+<span class="number">1</span>]);</span><br><span class="line">    split(n_next<span class="number">-1</span>, k<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这里头的next_node数组，我是这么算的，O(n)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LL temp = <span class="number">0</span>, last = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(LL i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    temp += a[i];</span><br><span class="line">    <span class="keyword">if</span>(temp &gt; <span class="number">0</span>)</span><br><span class="line">        next_node[i] = last;</span><br><span class="line">    <span class="keyword">if</span>(a[i] &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = <span class="number">0</span>;</span><br><span class="line">        last = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉并无问题，然鹅交上去就wa了，现在还没de出来。</p><h2 id="E-WA"><a href="#E-WA" class="headerlink" title="E(WA)"></a>E(WA)</h2><p>其实可以把问题做等价的转化，就是思考从x开始，它要经过多少个区间才能”跳“到y点。拿例子来说，比如已有[1, 3], [2, 4]两区间，那么(x, y) == (1, 2)时hop=1，因为经过[1, 3]区间即可，(x, y) == (1, 4)时则hop = 2：从1跳到3再跳到4，或是从1跳到2再跳到4，没有更短的路径。</p><p>在这个问题中，设询问区间的左端点为x，它通过一个区间能“跳”到$z_1, z_2, z_3, …, z_m$这些点（$z_1, z_2, z_3, …, z_m$呈升序）。不难发现，贪心的思路能帮助我们解决问题，即$x-&gt;z_m, z_m-&gt;y$这种跳法必然优于$x-&gt;z_k, z_k-&gt;y$（$1 \leq k \leq m$）。（画个图感受一下更好，证明的话反证即可）</p><p>想到了这点，我们再来想如何进一步地处理这个问题呢。储存所有可能的询问值么？这样复杂度在时间上是$O(n^2)$，空间上也会爆。为了降低复杂度，我们考虑倍增的思路，记录从每个点开始，跳1步，跳2步，跳4步……所能达到的最远点。这样也不难设计出针对每个查询的算法。</p><p>倍增首先要处理边界情形：跳1步所能达到的最远点。考虑将所给区间按$l$从小到大排序（$l$若相同，保留$r$最大的那个区间，其他舍去）。那么若一个点P在一个或多个区间内，选取包含它的$l$值最大的区间[$l_{max}$, $r_{max}$]，则该区间是所有包含点P的区间中$r$最大的（由之前的排序得到）。故P所能到达的最远点，即$r_{max}$。</p><p>（另外，题目中有一些不被任何区间包含的点，我们记它们跳任意距离都会到-1）</p><p>然后是写倍增了，这是较为容易的。（但不知道有没有地方写错了……也检查不出来）</p><p>对于每次查询，我们看x跳一步是否能到达y，如是，则所经路径数+1，返回答案。如否，则会有两种情况：1）x最终跳到了一个”不动点“（$f[x][i] == f[x][i+1]$）；2）存在$i \geq 0$使得$f[x][i] &lt; y \leq f[x][i+1]$。对于前一种情况，我们返回-1（因为这个不动点必然在y左侧，如果不是，那么x会从case 2中退出，或者x跳一步就到达y了）。对于后一种情况，我们把$f[x][i]$代回$x$，进行迭代。</p><p>（这个算法看上去是正确的？然而WA了……）</p><p>（测试数据规模较大故无法拿到。值得一提的是，有output=2而实际应为1的情况，也有output=-1而实际为正数的情况。）</p><h1 id="round-564-div2-鸽"><a href="#round-564-div2-鸽" class="headerlink" title="round #564 div2(鸽)"></a>round #564 div2(鸽)</h1><p><a href="https://codeforces.com/contest/1173" target="_blank" rel="noopener">戳我做题</a></p><p>A注意特判。</p><p>B倒是挺有意思，找规律+假的数学归纳法可以得出一种可能的答案，但它为何而正确呢？（更代数的看）三角不等式。</p><p>C……毒瘤题。总归是贪心的思路，就看开始要浪费多少牌才能开始顺序打出所有牌了。而这可以通过枚举要把哪张牌垒到顶上来算。但是，为什么这样的策略是可行的呢？（我希望构造性的游戏方案，而不是非构造性地给个最优解）</p><p>D的话，我的关注点在“交叉”上，然后想着想着就想到麻烦的方向去了，想到图的结构如此的话该如何如何……而忽视了“树”这一条件。从根结点出发，可以发现，子树中的结点都是占据了“整一块”连续的圆弧的。在这个条件下，如果知道父母结点的位置，子树的个数，还有父母+孩子所占据的圆弧是既定的这一信息，就能列出所有可能的方案数了（记父母节点有k个子节点，则$f(u) =  k! \cdot \prod\limits_{child} f(child)$）。虽然思想是dp，但算一算是能发现公式的，于是打表就好了。</p><h1 id="round-565-div3-鸽"><a href="#round-565-div3-鸽" class="headerlink" title="round #565 div3(鸽)"></a>round #565 div3(鸽)</h1><p><a href="https://codeforces.com/contest/1176" target="_blank" rel="noopener">戳我做题</a></p><p>B又是贪心……数字的位置无关紧要，只有模三余n的数的个数是重要的信息。瞎匹配就好。我想如果把题目中“任意取两数”的条件改成“取相邻两数”，这道题该怎么做？</p><p>E的话我想想把这个图打成树，然后bfs二染色就好了……懒得写bfs就用了dfs，结果居然t了。这时才看到数据规模竟有$T \leq 2e5, n \leq 2e5$之大，这dfs个毛线啊？于是我在读入的时候直接随便染色，居然还是t。把memset去掉换成for，才a……（随便染色是怎么染呢？就那么染呗。如果当前读入的两个点都没染过，一个染0一个染1；如果都染过就跳过；如果一个染过一个没染，把没染的染和染了的染色相不同的染色。容易证明，这样下来符合题意。）</p><h2 id="D-2"><a href="#D-2" class="headerlink" title="D"></a>D</h2><p>“看到这个题，我有一种莫名的近乎落泪的感动。”</p><h2 id="F-WA"><a href="#F-WA" class="headerlink" title="F(WA)"></a>F(WA)</h2><h1 id="round-566-div2"><a href="#round-566-div2" class="headerlink" title="round #566 div2"></a>round #566 div2</h1><p><a href="https://codeforces.com/contest/1182" target="_blank" rel="noopener">戳我做题</a></p><p>（掉分的感觉，真·爽的一批）</p><p>做A的时候，乘法法则加法法则傻傻分不清，我不仅现在离散没学好，高中组和数学也没学好……</p><p>做B的时候想能否边读入便判定，便先找center_c再找center_r，可这样不仅代码长，还要考虑特殊情况。直接通过center的性质找第一个符合条件的不就好了么！做得又慢，做完还错，讨厌模拟题，但又不能秒过它，这样的态度不行的啊。</p><p>做C的时候（读题读了好久……对关键点的挖掘还不够迅速而准确，我的阅读理解能力有待提高）贪心的思想是没问题了，结果在字符长度上出了篓子……这是ICPC不是CTF，毒瘤出题人总喜欢出毒瘤数据。对可变长数组的感觉还不够啊。$vector<char>$，或者$string$。</char></p><p>做E的时候看出它是个矩阵快速幂了，但是把这东西的细节都忘掉了……无奈在比赛结束后20分钟才过sample。不过当时如果做出来也过不了的吧，因为费马小定理的关系。</p><h2 id="C-2"><a href="#C-2" class="headerlink" title="C"></a>C</h2><p>题意：给你若干个单词，让你选四个配成一对。要求是第一个词和第三个词有相同的元音数，第二个词和第四个词有相同的元音数且它们最后一个元音一样（由题意，每个单词至少有一个元音，所以一行中的最后一个元音必然在后面的词上）。问最多能配出多少对。然后输出最多匹配时的任意一种方案。</p><p>题目里有效的信息是单词、元音数、最后的元音。于是我们可以用一个struct来存数据。然后怎么匹配呢？考虑到第二个词和第四个词间的关系更强，我们先匹配出这一类，然后再匹配有相同元音数但是末位元音不一的另一类。</p><p>二四类怎么匹配呢？考虑贪心的思路。按元音数-最后元音进行排序，i从1到n，考虑nodes[i]和nodes[i+1]能不能匹配，能就匹配它们了（同时设vis[i] = vis[i+1] = 1，以防一个单词被重复使用）。不能则说明nodes[i]不能和其它nodes匹配（易证）。这样遍历一遍就匹配出同时能取的最多的二四类了。</p><p>一三类的匹配比较常规，也是贪心的思路，就不谈了。</p><p>匹配完之后我们得到cnt_first个一三类的单词组，cnt_second个二四类的单词组。怎么输出呢？分类讨论呗。若是cnt_first &gt;= cnt_second，输出cnt_second组单词就好了。若是cnt_first &lt; cnt_second，考虑到二四类的单词比一三类强（也就是，二四类的单词可以兑换成一三类用），输出cnt_first + (cnt_second - cnt_first) / 2组单词就好了。细节不表。</p><h2 id="E-1"><a href="#E-1" class="headerlink" title="E"></a>E</h2><p>接近裸的递推关系。把$f_n$写成$c^{a(n)} \cdot f_1^{b(n)} \cdot f_2^{c(n)} \cdot f_3^{d(n)}$的形式，就可以发现递推方程啦。其中b, c, d都是同一形式的，只不过初始条件不同罢了。a要特殊点，因为你要把它在形式上做一些变换，这是高中的内容。</p><p>然后矩阵快速幂上板子。要注意的是，$MOD = 1e9+7$是个质数，故而$c^{p*(MOD-1) + q} \equiv c^{p + q}$（费马小定理）。在处理指数的递推关系时候，要模MOD-1；而在计算快速幂时，要模MOD。</p><p>写题目的时候碰到个坑点，记录如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n &gt;= <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    n -= <span class="number">3</span>;</span><br><span class="line">    LL ans = qpow_num(qpow_matrix(n) - n, c); <span class="comment">// qpow_num(expo, base)</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样是过不去的，为什么？因为上面把n改变了，所以在处理a的时候得小心一点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n &gt;= <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    n -= <span class="number">3</span>;</span><br><span class="line">    LL ans = qpow_num(qpow_matrix(n) - n - <span class="number">3</span>, c); <span class="comment">// caution!</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样有时候会t，为什么？因为前面算出来的qpow_matrix那个是模过MOD-1的，而n没有模过MOD-1，所以指数会出现负数的情形，这样子快速幂就跳不出来了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n &gt;= <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    n -= <span class="number">3</span>;</span><br><span class="line">    LL expo1 = qpow_matrix(n) - n - <span class="number">3</span>;</span><br><span class="line">    expo1 = ((expo1 % (MOD<span class="number">-1</span>)) + (MOD<span class="number">-1</span>)) % (MOD<span class="number">-1</span>); <span class="comment">// caution!</span></span><br><span class="line">    LL ans = qpow_num(expo1, c);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模过的数和没模过的数……变量在公式上的始终如一与在程序上的可变……这些都是坑点啊。尽管可能还会再犯，但希望下次能先把这些错误过一遍，有个印象总得。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学之美】离散数学及其应用：第十一章 初探树</title>
      <link href="/2019/06/22/Discrete_Mathematics-CH11/"/>
      <url>/2019/06/22/Discrete_Mathematics-CH11/</url>
      
        <content type="html"><![CDATA[<p>树是一种特殊的图，它有一些良好的性质，也有相当广泛的应用。</p><a id="more"></a><h1 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h1><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><p>树：简单无环连通图（开始的定义是无向图，不过这并不是最重要的，最重要的是前面三条：无重边，无环，连通）</p><p>无向图为树，当且仅当任意两点间有唯一路径。</p><p>开始的定义中树是无向图，不过实际生活中我们建出来的树一般都有层级关系，故要定义方向。怎么确定方向呢？选定根节点然后递归（在subtree中递归）就好了。这样得出的树称为有根树，它的相关术语更多一些：parent, child, sibling, ancestor, descendant…这些是和点和点间的性质。至于点内部的性质，则有root, leaf, internal vertices，这些。</p><p>然后我们容易发现，parent有且仅有一个，除了根节点。children则可以不限量，除了叶节点。为了方便定量运算，我们定义每个节点children不超过m的树为m-ary tree，同时也定义了full m-ary tree。m取2比较常见，所以给它个好听的名字，binary tree。</p><p>然后child地位也不是平等的，有left child，有right child，有heavy child，有light child。这些是要有序地遍历树的时候要考虑的，这里先不必管。</p><h2 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h2><p>n个节点的树恰有n-1条边（可数归证，亦可套欧拉公式）。这条定理指出以下三个条件间的相互关系，即任意两个条件都能推出剩下的条件：1）G为连通图；2）G无环；3）G有n-1条边。</p><p>full m-ary tree若有i个internal vertices，则其有mi + 1个点。（由此，可确定总顶点数，内点数，叶子数间的关系，知二得三）</p><p>平衡树：叶子都在最后一层或是倒数第二层的树//为何作此定义？</p><p>m叉树至多$m^h$个叶子$\Leftrightarrow$m叉树高度h和叶子数满足$h \geq \lfloor log_m l \rfloor$。</p><h1 id="树的应用"><a href="#树的应用" class="headerlink" title="树的应用"></a>树的应用</h1><p>二分搜索树</p><p>决策树</p><p>博弈树</p><p>前缀码（关注Huffman编码）</p><h1 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h1><p>前序、中序、后序遍历</p><p>波兰式与逆波兰式</p><h1 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h1><p>图连通与其有生成树，二者等价</p><p>dfs、bfs求生成树</p><p>回溯的思路</p><p>Prim算法与Kruskal算法</p>]]></content>
      
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学之美】离散数学及其应用：第十章 图论基础</title>
      <link href="/2019/06/22/Discrete_Mathematics-CH10/"/>
      <url>/2019/06/22/Discrete_Mathematics-CH10/</url>
      
        <content type="html"><![CDATA[<p>想知道图有哪些好玩的应用吗？</p><p>想知道图有哪些奇妙的种类吗？</p><p>想知道怎样科学地研究我们生活中的电路和考试安排表吗？</p><p><strong>来学图论吧！</strong></p><p>①有向图、复杂图、环等奇妙关系的丰富组和！</p><p>②解锁打电话、找关系、打比赛、画分子、爬网站、焊电路板等趣味模型！</p><p>③用图论来获得缤纷色彩、最短路径等谜题的答案！</p><p>④所有的算法与复杂度都能尽情研究！</p><p>⑤在权重扩展包中探索新的玩法！</p><p><strong>好评发售中！</strong></p><a id="more"></a><h1 id="图的元素"><a href="#图的元素" class="headerlink" title="图的元素"></a>图的元素</h1><p>这一节主要在讲概念，概念也不复杂，一般动手画画就能理解，此处仅记一下术语。</p><p><strong>multigraphs</strong>，与之对应的是simple graph。multiplicity为边的重数。</p><p><strong>digraph</strong>（或directed graph），有向图。</p><p><strong>loop</strong>，在本书中指的是自环而非环（环一般用<strong>circuit</strong>表示）。</p><p>是否有重边，是否有自环，是否有向，也是Kenneth H.Rosen要求我们看到一个图时扪心自问的三个问题。</p><p><strong>pseudograph</strong>，同时有自环与重边的图，复杂图。</p><p>其他术语，什么mixed graph，simple directed graph就不记了，这些都可以通过组和最重要的三个元素得到。</p><h1 id="图的模型"><a href="#图的模型" class="headerlink" title="图的模型"></a>图的模型</h1><p>这里的模型基本大同小异，涉及的方面有日常生活；也有其他看似关联不大的学科，如心理学、环境学；还有就是各类网络：通信网，道路网……</p><p>书上的练习设计的的方向主要是自然语言与图论语言的转化，这是容易通过而熟练掌握的。练习中比较恶心的一类是画出precedence graph的Edge, 记于此处, 以供训练。<br>  s1: x := 0<br>  s2: x := x + 1<br>  s3: y := 2<br>  s4: z := y<br>  s5: x := x + 2<br>  s6: y := x + z<br>  s7: z := 4</p><h1 id="图的术语"><a href="#图的术语" class="headerlink" title="图的术语"></a>图的术语</h1><h2 id="邻域"><a href="#邻域" class="headerlink" title="邻域"></a>邻域</h2><p> 顶点A的邻域记作$N(A)$, 表示与A有共边的顶点的集合。</p><p>A的领域中的点与A是相邻(adjacent)的。</p><h2 id="度"><a href="#度" class="headerlink" title="度"></a>度</h2><p>在无向图中， $deg(A)$表示以A为端点的边的数目。</p><p>而在有向图中，$deg^-(A)$则表示起点为A的边数数目，类似地，$deg^+(A)$表示终点为A的边数数目。</p><p>度是与点有着直接关系的量。而边与度的关系则是每条边对总度数有两个贡献（举[有向]线段AB为例，无向图中数A的度与数B的度均要将其算一遍；在有向图中，它则只在A的入度和B的出度中各算了一次），由此可得定理1及其在有向图中的拓展（即书中的定理3）。</p><p>1.$\sum deg$ = $2|E|$</p><p>3.$\sum deg^-$ = $\sum deg^+$ = $|E|$</p><p>由此可见，无向图的度数和必为偶数。由此可得到书中的定理2：</p><p>2.无向图中度数为奇数的点必为偶数个。</p><p>证明的话，模2即可。</p><h1 id="特殊的图"><a href="#特殊的图" class="headerlink" title="特殊的图"></a>特殊的图</h1><p>1.完全图</p><p>2、3.环与轮（注意，$W_n$有n+1个点）</p><p>4.n维方体，顶点可用不超过$2^n$的正整数来表示（关注$n \geq 4$的情形，比如n=4要怎么画呢）</p><p>以上没什么好讨论的，其相关性质也非常好推。需要讨论的是以下的情形：二分图。</p><p>二分图的定义：对图$G = (V, E)$，若存在互不相交的顶点集$V_1, V_2$使得其并为$V$，且$E$中的任意元素$(u, v)$总满足$u, v$不同时属于$V_1$或$V_2$，则称$G$为二分图。</p><h2 id="二分图与染色问题的联系"><a href="#二分图与染色问题的联系" class="headerlink" title="二分图与染色问题的联系"></a>二分图与染色问题的联系</h2><p>二分图与染色问题有着密切的联系。简单图是二分图当且仅当其所有顶点能被染成两种颜色，并且没有同色点有共边。这并不难证明。</p><p>通过将求图$G$是否为二分图转化为能否将图$G$染色并使其满足上述条件，我们能得到一种求二分图的简单算法：从任意一点开始，将其染为一色，将与其相邻的点染为另一色，再转移到下一点，以此类推（类似BFS），直到出现矛盾或染色完成且自洽。</p><h2 id="二分图的匹配与Hall婚配定理"><a href="#二分图的匹配与Hall婚配定理" class="headerlink" title="二分图的匹配与Hall婚配定理"></a>二分图的匹配与Hall婚配定理</h2><p>给定二分图$G = (V, E)$，$E$的每一子集能够连接一些$V_1, V_2$中的点，若满足$V_1, V_2$中不存在度数超过1的元素，则称此为一次<strong>匹配</strong>。若一次匹配中连接起的$V_1$中的点的集合等于$V_1$，则称这是一次<strong>完全匹配</strong>。与二分图的匹配相对应的模型有求职、婚姻等。</p><p>了解了匹配的概念，我们自然会想到完全匹配需要什么条件，而Hall婚配定理则是对此的探讨。</p><p>二分图$G = (V, E)$存在完全匹配当且仅当对于所有$V_1$的子集$A$，都有$|N(A)| \geq |A|$。（此处$V_1$和$V_2$的地位是不对称的）</p><p>由存在完全匹配推出结论并不难，因为任意A中元素$u$唯一地对应$V_2$中的$v$，后者的集合是A的邻域的子集，其元素个数等于$A$的元素个数不大于$A$的邻域的元素个数。下面证明其逆命题，我们的思路是采用第二数学归纳法，将V中元素较大的情况缩减至V中元素较小的情况。</p><p>归纳前提：$|V|=1$时结论显然成立。</p><p>归纳假设：$|V|\leq k$时假设结论成立，下证明$|V|= k+1$时结论成立。</p><p>取$V_1$的恰含j个元素的子集A（A是任意的），由已知，存在两种情况：(1)$|N(A)| &gt; |A|$（对任意A情况均如此）与(2)$|N(A)| = |A|$，下分类讨论</p><p>(1)任取一个A，将其中一个元素与其对应元素配对（即剔除出$V_1$与$V_2$），余下的元素满足大前提及归纳假设，求证得证。</p><p>(2)将A与其对应集合配对，下用反证法证明余下的元素满足大前提（若不满足，其加上A之后也不会满足，故矛盾）也满足归纳假设，求证得证。</p><p>//此处应补充上图示</p><p>霍尔婚配定理的不足之处在于，它是一个存在性证明而非构造性证明，无法据其给出求出完全匹配的算法。</p><p>//霍尔婚配定理是否足够强呢？</p><p>(proper) subgraph</p><h1 id="图表示与图同构"><a href="#图表示与图同构" class="headerlink" title="图表示与图同构"></a>图表示与图同构</h1><p>邻接表、邻接矩阵, incidence matrix（前向星）</p><p>同构：关注不变量——环、度、子图结构，或者从补图入手</p><h1 id="图的连通性"><a href="#图的连通性" class="headerlink" title="图的连通性"></a>图的连通性</h1><p>割点（cut vertices）</p><p>从连通分量到强连通分量</p><p>k-connected</p><p>$\kappa(n) \leq \lambda (n) \leq min_{v \in V} deg(v)$</p><p>路径的条数（矩阵乘法）</p><h1 id="Euler路径与Hamilton路径"><a href="#Euler路径与Hamilton路径" class="headerlink" title="Euler路径与Hamilton路径"></a>Euler路径与Hamilton路径</h1><p>欧拉路径存在的充要条件</p><p>欧拉回路存在的充要条件</p><p>哈密顿回路：不能存在deg=1的点；deg=2的点至多一个</p><p>完全图（包括无向完全图与竞赛图）必有哈密顿回路</p><h1 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h1><p>dijkstra算法</p><h1 id="平面图"><a href="#平面图" class="headerlink" title="平面图"></a>平面图</h1><p>基本方法（如判定$K_{3, 3}$非平面图）</p><p>欧拉公式</p><p>degree of region</p><p>平面图中e，v相关的不等式</p><p>找和$K_5, K_{3, 3}$同构的子图</p><h1 id="图染色"><a href="#图染色" class="headerlink" title="图染色"></a>图染色</h1><p>找最大团</p><p>图染色的模型：考试安排表</p>]]></content>
      
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学之美】离散数学及其应用：第九章 关系</title>
      <link href="/2019/06/22/Discrete_Mathematics-CH09/"/>
      <url>/2019/06/22/Discrete_Mathematics-CH09/</url>
      
        <content type="html"><![CDATA[<p>这章的主题是关系——我们关注的不是单个的元素，而是<strong>元素间</strong>的性质。</p><a id="more"></a><h1 id="关系的概念"><a href="#关系的概念" class="headerlink" title="关系的概念"></a>关系的概念</h1><h2 id="关系的定义"><a href="#关系的定义" class="headerlink" title="关系的定义"></a>关系的定义</h2><p>什么是关系呢？关系是集合论里的词，它是用笛卡尔积给出的。我们先来看一个简单的例子，比如我们有六只猫，三公三母，有哪些可能的配偶方案呢？我们先把猫放到集合里，令 公猫集 = {Wang, Miao, Aichiyu}，母猫集 = {qwq，bwb，dwd}。这时候我们考虑笛卡尔积。{Wang, bwb}，这表明Wang和bwb存在关系（’Wang’ is related to ‘bwb’），更确切的说，存在二元关系。</p><p>笛卡尔积给出的是有序元素，所以关系也是有序的。“关系”这个词看着很别扭，因为自然语言中的“关系”不仅是“有关系”的意思。但要在数学上研究元素间的关系，我们就得把“关系”看作一个集合，由形如$A \times B$的式子给出的集合的子集，比如说，R = { {Wang, qwq}, {Wang, bwb}, {Miao, bwb} }。这就是一个“关系”（relation）了。</p><p>不必管R有什么意义，因为它的意义是我们赋予的。我们可以定义$(a, b) \in R \Rightarrow$ a不喜欢b，也可以做相反的定义，都可以。关系也不仅限于猫猫狗狗上，只要是元素，都可以用笛卡尔积给它们搞出个关系。这样“关系”就能很丰富了，比如满足不等式的两元素间的关系，函数原像与像的关系，等等。这里谈到的“关系”是我们由经验中的“关系”抽象而出的，仅表示两元素间存在“关系”，而并未指明这样的“关系”是什么“关系”。（真是绕）</p><h2 id="关系的性质"><a href="#关系的性质" class="headerlink" title="关系的性质"></a>关系的性质</h2><p>知道了R的定义，我们可以来考察它的性质了。根据实际研究的需要，我们主要考察R是否有以下四种性质：</p><p>1.reflexive。即$\forall a \in A, (a, a) \in R, R \subseteq A \times A$。观察$R = {(a, b) | a &lt; b, a, b \in N}$和$R = {(a, b) | a \leq b, a, b \in N}$的区别很容易理解这条性质。</p><p>2.symmetric。即$\forall a, b,  (a, b) \in R \rightarrow (b, a) \in R$。</p><p>3.antisymmetric。即$\forall a, b,  (a, b) \in R \wedge (b, a) \in R \Rightarrow a = b$。（在猫猫匹配的例子中，如果R是antisymmetric的话那可真是悲哀）</p><p>4.transitive。即$\forall a, b, c, (a, b) \in R \wedge (b, c) \in R \rightarrow (a, c) \in R$。</p><p>transitive的画风看起来和上面那些很不一样，我们之后再来考虑它。（这一节中有一些叫你判断R是否transitive的例题，方法的话枚举中间元素较为方便）</p><p>需要注意，antisymmetric和symmetric并不是互斥的，它们研究问题的方向可以说完全不同。“关系”中还有其他和对称性沾边的性质，比如asymmetric，它和antisymmetric其实很像，只是限制了$\forall a, (a, a) \not \in R$（对了，这条性质就是irreflexive）。要确定这些研究方向各不相同而有所交集的性质间的关系并非那么容易的，不过，这是一个值得研究的问题吗？</p><p>这一节中还会有一些组和问题，比如，给定$|A| = n$，问antisymmetric的R有多少个。这类题在理解了R的定义之后非常好做。上面例子的答案为$2^n \cdot 3^{n \cdot (n-1)}$。捆绑的思想。</p><h2 id="关系间的运算"><a href="#关系间的运算" class="headerlink" title="关系间的运算"></a>关系间的运算</h2><p>既然关系是一个集合，我们可以利用集合中的运算研究关系和关系间有什么关系。在这里，$\cup, \cap, \oplus, -$都可以直接继承集合中的运算。</p><p>然后因为关系是多元组，它还有自己独特的计算：$\circ$。如果把关系表示为矩阵的话，那么这一项便可以类比矩阵乘法。具体写来，是这样的：$R \subseteq A \times B, S \subseteq B \times C, (a, b) \in R \wedge (b, c) \in S \rightarrow (a, c) \in S \circ R$。（这个符号真反人类……明明运算和$R \times S$很像，但硬是要反过来写，不懂）</p><p>还有需要注意的是，$R^{-1}$不是使得$R \circ R^{-1} = E$成立的集合，它更像是$R^T$，这些记号需要注意。</p><p>然后定义了这个”乘法“(composite)之后，我们就可以来关注transitive这条性质了。比如有一条定理，讲的是R满足transitive和$R^n \subseteq R$这一条等价。证明的话，右边推左边按性质就好了，左推右数归就好。至于这条定理有何意义？（至少我不清楚）</p><h1 id="n元关系-待补充"><a href="#n元关系-待补充" class="headerlink" title="n元关系[待补充]"></a>n元关系[待补充]</h1><p>上面讲的关系都是二元关系，形如$A \times B$。类似的，我们可以定义n元关系。</p><p>对n元关系我们就不考察它的性质了，反正它还是元素笛卡尔积得到的集合，研究n元的情形没什么必要。</p><p>需要考察的是它的应用：比如数据库中，一个条目，比如说学生，包含了很多子数据：姓名、学号、GPA……那么我们可以把姓名×学号×GPA×…得到的元素视作一段关系的元素，也就是数据库中的项。这样一来，一个数据库就对应一种关系。我们要进行各式各样的数据库操作：添加，删除，排序……这些该如何定义呢？</p><p>（关注select和projection的分别。）</p><h1 id="关系的表示"><a href="#关系的表示" class="headerlink" title="关系的表示"></a>关系的表示</h1><p>前面我们都是抽象地”感受“关系的，这样想问题或许不容易理解。我们试着将其化归到已经学过的可爱的数学元素上，好让它更直观一些。</p><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>简单地在关系和0-1矩阵上做个一一映射，就能用矩阵来表示关系啦。</p><p>用矩阵来表示关系可以让reflexive, symmetric, antisymmetric的判断变得很简单，但是判断transitive还是一如既往的麻烦。</p><p>用矩阵表示也让composite（乘法）更容易算了（注意0-1矩阵乘法的规则）。这在之后研究transitive上是好的。</p><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>矩阵规模好大，但又好稀疏，用矩阵表示要写好多0，好烦，怎么破？用邻接表呗。（前向星，多好的名字啊）</p><h2 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h2><p>随便找道例题体会一下即可，这种表示法更为直观。</p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h2><p>我们觉得满足性质的关系是好的，比较漂亮。不满足性质的关系就没那么漂亮。那么，怎么把不漂亮的关系补成漂亮的关系呢？（为什么一定要补呢？置$R = \varnothing$多方便啊？）称补出来的为闭包（很显然，笔者的定义是不严谨的，但很直观）。</p><p>reflexive, symmetric都很好补，而antisymmetric补不出来。看上去要研究的只剩transitive了。</p><p>可这并不容易，需要先定义一些其他的概念。</p><h2 id="传递闭包"><a href="#传递闭包" class="headerlink" title="传递闭包"></a>传递闭包</h2><p>我们先来回顾一下何谓传递性，不用关系中的术语，而是以图论的角度来思考。一个有向图，它有点和边，于是可以得到从一点a出发的”可到达的“点的集合（设其中任意一点为b），也得到了它要到那些点的路径及路径长度。而传递性，表明从a到任意的的b最短距离为2，也就是能直连通。</p><p>但是目前的图不一定使得连通的两点能够直连通啊，所以要补边（边和关系中的元素一一对应），也就是考虑构造传递闭包。</p><p>上面是较直观的感受，用数学语言该如何转译呢？a可达b，即$\exists k, (a, b) \in R^k$。于是这个(a, b)需要添加到闭包中。yy一下，我们得到了一种获得传递闭包的方式：$R^* = \bigcup\limits_{k = 1}^{\infty} R^k$。</p><p>然后如果路径太长，长过顶点数，这其中肯定是有环的，可以把环剪掉。所以$R^* = \bigcup\limits_{k = 1}^{n} R^k$。</p><p>这个算法的复杂度是$O(n^4)$，还不错？不过要算好多乘法好累，有没有稍微简单一点的算法呢？有的，Warshall’s Algorithm。</p><p>Warshall算法的思路是这样的：如果有长度超过2的路径，那么这条路径必然要经过中间的节点，于是可以通过枚举中间节点来构造传递闭包。（想到Floyd算法了吗？恰好，Floyd算法的全称正是Floyd-Warshall算法）yy一下，对着书上的例题手工模拟一番，便能学会这个算法了。（正确性证明考虑数归）</p><h1 id="等价关系"><a href="#等价关系" class="headerlink" title="等价关系"></a>等价关系</h1><p>什么是等价关系呢？我们来看看具体的例子吧：比如$\equiv$，它就是一个等价关系，$1 \equiv 5(mod 4)$。其中1和5本身并不相等，但是在mod 4这个条件下，它们是等价的，是可互换的。故，等价关系，指在给定的条件下，元素满足同样的性质。</p><p>等价关系要满足什么性质呢？其实这是我们自己归纳出来的。比如说$\equiv$，它reflexive，symmetric，transitive。然后满足这三点的关系，那么，我们就下个定义：满足reflexive，symmetric，transitive的关系就叫等价关系。（这一定义并非先验的，为什么等价和这三个性质有联系可能不好理解，但为什么要尝试理解它呢？）</p><p>满足等价关系的元素可以归到一类里，称等价类。同余等价类就是很好的例子。</p><p>定义了等价类，我们可以选取等价类中的一个元素，比如说a，来表示这个类，记作[a]。于是乎可以得到三种等价的表述：$a R b \Leftrightarrow [a] = [b] \Leftrightarrow [a] \cap [b] \not = \varnothing$。</p><p>由等价类间的互不交，可由等价类在原集合上做划分（partition）。</p><p>然后对于计数问题，如问有多少种等价关系这样的问题，可以考虑等价类的数目来做。</p><h1 id="偏序关系"><a href="#偏序关系" class="headerlink" title="偏序关系"></a>偏序关系</h1><p>这节讲的是偏序关系。偏序，偏序，顾名思义，和两个要素息息相关，其一为“偏”，其二为“序”，“偏”又是建立在“序”的基础上的，指的是并非所有元素间均可比较。与偏序关系对应的是全序关系。无论是偏序还是全序，它们都得要能排序，也就是能比较才行。什么样的关系是可排序的呢？</p><p>$\leq, |, \subseteq$，这些看似不同的运算都有着相似的特点：reflexive, antisymmetric, transitive。我们看到这样的关系是可比的。于是，我们用$\preccurlyeq$表示这样的偏序关系，也就是满足以上三条性质的关系。经历了等价关系的洗礼，读者应当能够接受这种表达。</p><p>定义了偏序关系，我们接着来定义一种常用的排序方式：字典序。//待补充</p><p>Hasse图：用以直观表示偏序关系的图//待补充</p><p>maximum, minimal, greatest, least, (greatest) lower bound(GLB), (least) upper bound(LUB)//待补充</p><p>lattice(a partially ordered set in which every pair of elements has both a least upper bound and a greatest lower bound)</p><p>topological sorting</p>]]></content>
      
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学之美】离散数学及其应用：第八章 计数进阶</title>
      <link href="/2019/06/22/Discrete_Mathematics-CH08/"/>
      <url>/2019/06/22/Discrete_Mathematics-CH08/</url>
      
        <content type="html"><![CDATA[<p>虽然这章名为“计数进阶”，但其内容和“计数”关系似乎不是很大。除了生成函数是标准的“计数”内容，“递推”“分治”看起来和“计数”都没啥关系。另外容斥定理讲得也比较浅。</p><a id="more"></a><h1 id="递推关系"><a href="#递推关系" class="headerlink" title="递推关系"></a>递推关系</h1><h2 id="递推关系模型-需补充"><a href="#递推关系模型-需补充" class="headerlink" title="递推关系模型[需补充]"></a>递推关系模型[需补充]</h2><p>从兔子数列到牛数列</p><p>汉诺塔</p><p>满足特定条件的01串（如，不包括连续两个0的01串）</p><p>（卡塔兰数的一种情形）n个数相乘的顺序总数</p><h2 id="递推算法-需补充"><a href="#递推算法-需补充" class="headerlink" title="递推算法[需补充]"></a>递推算法[需补充]</h2><p>讲座问题</p><p>动态规划</p><h1 id="线性递推"><a href="#线性递推" class="headerlink" title="线性递推"></a>线性递推</h1><h2 id="齐次"><a href="#齐次" class="headerlink" title="齐次"></a>齐次</h2><p>所谓线性齐次常系数递推关系（linear homogeneous recurrence relations with constant coefficients），指的是形如$a_n = c_1 a_{n-1} + c_2 a_{n-2} + … c_k a_{n-k}$的递推关系。</p><p>提到“线性齐次常系数递推关系”我们就会提特征方程与特征根，它们是用以解递推式的利器。</p><p>特征根是个非常有效但也让人摸不着头脑的东西。它本身有何意义？下面笔者粗浅地谈谈自己对其的认识。</p><h3 id="二阶递推式-需完善"><a href="#二阶递推式-需完善" class="headerlink" title="二阶递推式[需完善]"></a>二阶递推式[需完善]</h3><p>如果递推式形如$a_n = Aa_{n-1} + Ba_{n-2}$，$a_n$该如何解呢？我们考虑能否用特殊的$a_n$凑出答案，比如，$a_n = x^n$，这样？把它代入原递推式，我们得到一个二次方程$x^2 - Ax - B = 0$，如果它有不同的解$x_1, x_2$，诶，好，$a_n = x_1^n$或者$a_n = x_2^n$看上去都可以。</p><p>但是啊，$a_n = Aa_{n-1} + Ba_{n-2}$是由$a_1, a_2$完全确定的。如果$a_1 \not = x_1$，那不就出问题了吗？其实，前面说$a_n = x_1^n$“可以”，那么$a_n = Cx_1^n + Dx_2^n$也是“可以”的。这样便能够通过给定的$a_1, a_2$解一解C、D，$a_n$的通解也就出来了。</p><p>因为$x^2 - Ax - B = 0$和$a_n$有着密切的联系，我们称前者为“特征方程”。</p><p>以上是特征方程有两个相异根的情形，如果相同则如何呢？不一定存在$C$使得$a_1 = Cx_1$且$a_2 = Cx_1^2$啊！在这个条件下，我们令$a_n = Cx_1^n + Dnx_1^n$。可以证明，这样的$a_n$满足条件//为什么想到要这样做？</p><h3 id="n阶递推式"><a href="#n阶递推式" class="headerlink" title="n阶递推式"></a>n阶递推式</h3><p>与上面类似的，我们能想到无重根的n阶递推式的通解形如$a_n = \sum\limits_{i = 1}^k \alpha_i r_i^n$，其中$r_i$为特征方程的解。</p><p>至于有重根的n阶递推式，它则形如$a_n = \sum\limits_{i = 1}^k(\sum\limits_{j = 0}^{m_i} \alpha_{(i, j)} n^j r_i^n)$，其中$r_i$为特征方程的解，$m_i$为重数。</p><p>证明呢？不管了(¬､¬)</p><p>有重根的n阶递推式</p><h2 id="非齐次-需完善"><a href="#非齐次-需完善" class="headerlink" title="非齐次[需完善]"></a>非齐次[需完善]</h2><p>所谓线性非齐次常系数递推关系（linear nonhomogeneous recurrence relations with constant coefficients），指的是形如$a_n = c_1 a_{n-1} + c_2 a_{n-2} + … c_k a_{n-k} + F(n)$的递推关系。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>找特解，而后化归到齐次。（这些方程都这种套路，得归纳一下）</p><p>特解怎么找呢？比如$a_n = 3a_{n-1} + 2n$，我们可以从结构上猜出$a_n = Cn$。而对于$a_n = 5a_{n-1} - 6a_{n-2} + 7^n$，我们也可以猜一个$a_n = C \cdot 7^n$。但是如果是$a_n = 5a_{n-1} - 6a_{n-2} + 3^n$，$a_n = C \cdot 3^n$就不管用了，要$a_n = C \cdot n^2 \cdot 3^n$才行（为什么又是这个形式？我不知道）。</p><p>一般的，有下面的定理。</p><h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p>若$a_n = c_1 a_{n-1} + c_2 a_{n-2} + … c_k a_{n-k} + F(n)$，$F(n)$形如$(b_t n^t + b_{t-1} n^{t-1} + … + b_1 n + b_0) s^n$，其中b、s均为常数。递推关系的特征方程$x^n - c_1 x^{n-1} - c_2 x^{n-2} - … c_k x^{n-k} = 0$的解中s的重数为m，则特解的形式形如$a_n = n^m (p_t n^t + p_{t-1} n^{t-1} + … + p_1 n + p_0) s^n$。</p><p><del>我不会，就不证了</del>例子：$a_n = 6a_{n-1} - 9a_{n-2} + F(n)$，当$F(n)$分别取$F(n) = 3^n, F(n) = n 3^n, F(n) = n^2 2^n, F(n) = (n^2 + 1) 3^n$，求$a_n$的通解。</p><p>应用：如求$a_n = \sum n^k$。</p><h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><p>研究分治算法时，一个值得关注的对象是时间复杂度。下面举几个大家耳熟能详的例子。</p><p>例子：矩阵乘法、二进制乘法（汇编乘法？）、二分查找、归并排序</p><p>上面的例子看似相似，但其算法复杂度可以很不一样！最后的公式会依据递推关系中的常数专门进行分类讨论，而且结论虽然能推，但是并不好记。//如何认识这一结论？</p><p>关于复杂度的推导，我们可以先简化问题，因为只要得到$f(n) = O(g(n))$就好了，可以对n进行“适当”的放大。这里，我们考虑$n = b^k$。</p><h2 id="f-n-的复杂度估计-需完善"><a href="#f-n-的复杂度估计-需完善" class="headerlink" title="f(n)的复杂度估计[需完善]"></a>f(n)的复杂度估计[需完善]</h2><h3 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h3><p>对于形如$f(n) = af(n/b) + c$的递推式，有</p><p>………………..$a = 1 \Rightarrow f(n) = O(log n)$</p><p>………………..$a &gt; 1 \Rightarrow f(n) = O(n^{log_b a})$</p><p>………………..$a &lt; 1 \Rightarrow f(n) = O(1)$</p><p>第一项很好理解，第二项是怎么得到的呢？其实直接得到的是$f(n) = O(a^k)$，而通过换底公式能得到$a^k = n^{log_b a}$，因为我们喜欢把n放到真数的位置。下面也是要用到这个转换的。</p><h3 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h3><p>对于形如$f(n) = af(n/b) + cn^d$的递推式，有</p><p>………………..$a = b^d \Rightarrow f(n) = O(n^d log n)$</p><p>………………..$a &lt; b^d \Rightarrow f(n) = O(n^d)$</p><p>………………..$a &gt; b^d \Rightarrow f(n) = O(n^{log_b a})$</p><h2 id="典例：最近点对问题-需完善"><a href="#典例：最近点对问题-需完善" class="headerlink" title="典例：最近点对问题[需完善]"></a>典例：最近点对问题[需完善]</h2><p>计算几何的一个<del>毒瘤</del>经典例题，初看非常的抽象，下面我试着以直观的方式说明一下如何用分治法解决这个问题。</p><p>首先分治呢，要先“分”，而后“治”。“分”的话二分比较常见，但二分要在有序集里才好进行。考虑以x坐标对这些点进行排序，然后取中间的点作为分界就好了。</p><p>下面的思路有些跳跃，我们从最后的算法出发来反推，这样可能更容易理解些。</p><p>分治法大框架的伪代码如下，一些细节先不必理解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">closest</span><span class="params">(Point p[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(high - low == <span class="number">1</span> <span class="keyword">or</span> <span class="number">2</span>)...</span><br><span class="line">    <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> d1 = closest(p, low, mid);</span><br><span class="line">    <span class="keyword">double</span> d2 = closest(p, mid + <span class="number">1</span>, high);</span><br><span class="line">    <span class="keyword">double</span> d = min(d1, d2);</span><br><span class="line">    d = merge(...);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面框架的细节主要是这个：d = min(d1, d2)。为什么要先算d呢？</p><p>这实质上是用于提高效率的。你想，“分”做好了，就是左右两边的最近点对距离都已经分别算出来了，“治”要怎么做呢？枚举左边的点和右边的点的距离么？这样还是$O(n^2)$，算法的复杂度还是没有降低呀！于是我们得限制枚举的点的数量。聪明的Preparata和Shamos发现，如果先算出d1、d2和d，那么用要枚举点的话，只要在下图中两条红线间的区域间（x坐标距mid为d的区域内）枚举即可。</p><p><img src="/2019/06/22/Discrete_Mathematics-CH08/closest_distance1.png" alt></p><p>就是说，这里用到了剪枝：把一些分居左右而距离必定超过d的点对剪掉。这个剪枝还是比较宽的，但它容易想到呀，如果要更深入地剪就要深入探究点的结构了，太复杂啦！我们不考虑。</p><p><img src="/2019/06/22/Discrete_Mathematics-CH08/closest_distance2.png" alt></p><p>可是，看这张图，即便上面有剪枝，枚举量还是太大了呀，如何缩减呢？我们遇到的问题是这些剩下的点还是无序的，只得暴力枚举，而没有有效的降低枚举量的技巧。于是，聪明的Preparata和Shamos又把剩下的点有序化了，并利用“两点间距离不能大于d”继续剪枝。请看伪代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">merge</span><span class="params">(Point p[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high, <span class="keyword">double</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;<span class="comment">// the size of the array "temp"</span></span><br><span class="line">    Point temp[];<span class="comment">// the points between the red lines</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//branch-cutting 1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = low;i &lt;= high;i++)</span><br><span class="line">        <span class="keyword">if</span>(p[i].x &gt;= p[mid].x - d)</span><br><span class="line">        <span class="keyword">if</span>(p[i].x &lt;= p[mid].x + d)</span><br><span class="line">        temp[len++] = p[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// the merge part</span></span><br><span class="line">    sort(temp, temp + len, cmp_y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;i + j &lt; len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp[i+j].y - temp[i].y &gt; d) <span class="keyword">break</span>;<span class="comment">// branch-cutting 2</span></span><br><span class="line">            d = min(d, dist(temp[i], temp[i+j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面“branch-cutting 2”这一行，它很容易理解，但是否足够有效呢？是否存在某组数据使得“the merge part”的运算量退化到$n^2$呢？幸运的是，它足够有效！而且运算量至多是7n！请看下面的图示。</p><p><img src="/2019/06/22/Discrete_Mathematics-CH08/closest_distance3.png" alt></p><p>假设我们正枚举到$P1$。Preparata和Shamos证明了，至多有7个$P2$满足$P2.y - P1.y \leq d$。因为前面在左右两边已经”分“过了，故有closest(left), closest(right) &gt;= d，即在“一边”的点两两距离大于d。这个结论非常有用！因为前面已经构造出了以2d为边长的长方形作为我们选点的区域，我们再在这个长方形里画小的正方形，再把P1放进去。能够发现，在图中所示的八个虚线区域中，每个区域至多一个点（否则矛盾）。故而“branch-cutting 2”在至多7步后就会退出，这个剪枝足够有效！</p><p>上面的分析还是比较粗略的，因为实际运算时似乎用不着7步，我们能否证明对每个点至多只要4次或5次比较呢？不论如何，总之都是较小的常数就是了。</p><p>接着来分析一下算法复杂度吧。开始的按x排序：O(nlogn)，之后的递推：f(n) = 2f(n/2) + nlogn + 7n（nlogn是按y排序）。解上面的递推式，得f(n) = O(nlogn)//为何网上有说法是nloglogn？</p><p>以反推的方式理解了一下这个算法，我们再来正面地总结一下我们的步骤：</p><p>①准备，按x排序原数组，使之有序；</p><p>②“分”，以中点为界，得到两子域中的最短点距；</p><p>③“治”，依据②中的最短点距d找出需要枚举的点，这里进行了第一次剪枝；</p><p>④“治”，将③中得到的点按y排序，顺序枚举，并通过y的距离进行第二次剪枝；</p><p>以上。</p><p>总而言之，这个算法的步骤还是容易实现的，难的是深入地理解它。这里两个剪枝分开来看都可能是效率不高的，但合在一起就产生了奇妙的相互作用，保证了总体剪枝的有效性。这十分精妙，但也很难想到，而且不好推广。</p><p>另外书上的算法是设了两个数组，分别对x排序与对y排序，之后在后者这一数组中检索，但这样细节是如何处理的呢？我还不知道。</p><p>算法的完整代码见下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span><span class="keyword">double</span> x, y;&#125;Points[maxn], temp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_x</span><span class="params">(Point &amp;lhs, Point &amp;rhs)</span></span>&#123;<span class="keyword">return</span> lhs.x &lt; rhs.x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_y</span><span class="params">(Point &amp;lhs, Point &amp;rhs)</span></span>&#123;<span class="keyword">return</span> lhs.y &lt; rhs.y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(Point &amp;lhs, Point &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>((lhs.x - rhs.x)*(lhs.x - rhs.x) + (lhs.y - rhs.y)*(lhs.y - rhs.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high, <span class="keyword">double</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> mid_x = Points[mid].x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = low;i &lt;= high;i++)</span><br><span class="line"><span class="keyword">if</span>(Points[i].x &gt;= mid_x - d)</span><br><span class="line"><span class="keyword">if</span>(Points[i].x &lt;= mid_x + d)</span><br><span class="line">temp[len++] = Points[i];</span><br><span class="line">sort(temp, temp + len, cmp_y);<span class="comment">//in the book, it's not necessary to sort. Why?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;i + j &lt; len &amp;&amp; (temp[i+j].y - temp[i].y &lt;= d);j++)</span><br><span class="line">d = min(d, dist(temp[i], temp[i+j]));</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">closest</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(high == low) <span class="keyword">return</span> INF;</span><br><span class="line"><span class="keyword">if</span>(high - low == <span class="number">1</span>) <span class="keyword">return</span> dist(Points[low], Points[low+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">double</span> d1 = closest(low, mid);</span><br><span class="line"><span class="keyword">double</span> d2 = closest(mid + <span class="number">1</span>, high);</span><br><span class="line"><span class="keyword">double</span> d = min(d1, d2);</span><br><span class="line"><span class="keyword">return</span> merge(low, mid, high, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...<span class="comment">//scanf</span></span><br><span class="line">sort(Points, Points + n, cmp_x);</span><br><span class="line">...<span class="comment">//printf</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>①分治算法在不同递推式下算法复杂度可能不同，需特殊情况特殊分析。</p><p>②分治算法的精髓在于“分而后治”，“分”是“治”的基础，通过“分”得到的有效信息能够帮助我们降低“治”部分的复杂度。在归并排序中，“分”得到的有效信息是子序列的有序性；在最近点对问题中，“分”得到的有效信息是子区域的最近点对距离。</p><p>③分治算法本身不难理解，但比较难想到，也比较灵活。分析分治算法时“为何这种问题可以用分治处理”。</p><h1 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h1><p>何谓生成函数？这是个比较玄妙的问题，它的定义很简单，但为何要这样定义，及它为何能用来解决组合问题，则常常会给人带来迷惑，下面笔者以个人的理解粗略地讲讲生成函数。</p><h2 id="生成函数的概念"><a href="#生成函数的概念" class="headerlink" title="生成函数的概念"></a>生成函数的概念</h2><p>先来看这样一个例子：$x_1 + x_2 + x_3 = 7$，其中$0 \leq x_1 \leq 2, 2 \leq x_2 \leq 3, 3 \leq x_4 \leq 4$，$x_1, x_2, x_3$为整数。求$(x_1, x_2, x_3)$有多少种可能。</p><p>我们固然可以通过解答树得到答案，但是否有其他更“代数”的做法呢？考虑这个式子：$(1 + x + x^2) \cdot (x^2 + x^3) \cdot (x^3 + x^4)$。它意味着什么？我们把第一个括号中x的指数看作$x_1$的取值，第二三个括号同理。从一二三个括号中各选一项乘起来，恰好对应$x_1 + x_2 + x_3 = k$的一种方法。故$(1 + x + x^2) \cdot (x^2 + x^3) \cdot (x^3 + x^4)$展开式中$x^k$的系数，即$x_1 + x_2 + x_3 = k$的方法数（而指数所对应的便是$x_1 + x_2 + x_3$的取值）。特别的，取k = 7，就得到了上面问题的答案。</p><p>这个方法看上去和暴力枚举并无二致，但事实并非如此。首先，生成函数将组合问题与代数问题连接起来，从而使得组和问题更易表示，而能为计算机所处理（多项式乘法）。其次，这样的算法在运算时更为容易，因为我们更熟练于多项式的乘法而不是列出解答树。</p><p>为何上述做法能建立从组和到代数的一一映射呢？原因在于乘法法则与加法法则——$ax^c + bx^c = (a+b)x^c$，这对应于加法法则；$ax^c \cdot bx^d = ab x^{c+d}$，这对应于乘法法则。如果认为这有些抽象，不妨在上面的例子中找找哪里用到了这两个法则。生成函数之所以能够解决组合问题，原因就在于多项式的运算能有这样和组和相关的性质。</p><p>上面的生成函数$G(x) = (1 + x + x^2) \cdot (x^2 + x^3) \cdot (x^3 + x^4)$是有限项的，容易理解。但是实际运用中我们一般会考虑无穷项的情况，即将$G(x)$写作无穷级数的形式。然后玄学东西又来了：比如$G(x) = \sum\limits_{i = 0}^{\infty} x^i = \dfrac{1}{1-x}$。为什么可以这样做？这样做有什么好处？这些我们将在下文中，结合具体的案例进行探讨，此时先不要被它迷糊了头脑。</p><h2 id="用生成函数证明组和恒等式-需完善"><a href="#用生成函数证明组和恒等式-需完善" class="headerlink" title="用生成函数证明组和恒等式[需完善]"></a>用生成函数证明组和恒等式[需完善]</h2><p>使用生成函数时，我们需要考虑“意义”。这不是指x的意义——x毫无意义，我们引入x只是要利用多项式的运算，因为它是好的。此处的意义指的是我们运算式子中的意义。拿上面的例子来说，$((1 + x + x^2)), (x^2 + x^3)$分别都有意义，它们相乘也是有意义的。谈到”意义“，你可能想到了第六章玄学的”组合证明“。而生成函数与组合证明，它们恰能够结合在一起。</p><p>//二项式定理？</p><p>比如Yanghui恒等式，可以这么证：$(1+ x)^n = (1 + x)^{n-1} + x (1 + x)^{n-1}$，关注左右式中$x^k$的系数即可。</p><p>又比如Vandermonde恒等式，关键的式子是$(1 + x)^{m + n} = (1 + x)^n (1 + x)^m$。</p><p>不难发现，使用生成函数的思路和组合证明的思路是完全一致的。但这个形式看起来就”正经“的多。</p><h2 id="用生成函数解决组和问题"><a href="#用生成函数解决组和问题" class="headerlink" title="用生成函数解决组和问题"></a>用生成函数解决组和问题</h2><h3 id="生成函数的模型"><a href="#生成函数的模型" class="headerlink" title="生成函数的模型"></a>生成函数的模型</h3><p><strong>例1</strong></p><p>$x_1 + x_2 + x_3 = 7$，其中$0 \leq x_1 \leq 2, 2 \leq x_2 \leq 3, 3 \leq x_4 \leq 4$，$x_1, x_2, x_3$为整数。求$(x_1, x_2, x_3)$有多少种可能。</p><p><strong>例2</strong></p><p>八本书，分给三个小孩，每人得到的书不少于两本不多于四本，求总方法数。</p><h3 id="再谈可重复元素的组和"><a href="#再谈可重复元素的组和" class="headerlink" title="再谈可重复元素的组和"></a><strong>再谈可重复元素的组和</strong></h3><p>在讲这个例子前，先要提一提广义二项式定理。</p><p><strong>广义二项式系数</strong>：$C_u^m = \dfrac{u \cdot (u-1) \cdot … \cdot (u - m + 1)} {1 \cdot 2 \cdot … \cdot m}$，其中m为非负整数，u为任意实数。</p><p>特别的，当u为负整数的时候，我们有$C_{-n}^m = (-1)^m C_{n + m - 1}^m$。</p><p><strong>广义二项式定理</strong>：$(1 + x)^u = \sum\limits_{i = 0}^{\infty} C_u^i x^i$。（证明的话，幂级数展开就好）</p><p><strong>例3</strong></p><p>有n种硬币，每种有无穷多个，问取r个硬币有多少种方法。</p><p>第一种硬币可以取0个、1个、2个、……，这样考虑的话，生成函数便是$G(x) = (1 + x + …)^n$。</p><p>但无穷级数相乘很难算。我们为了能够算出结果，假定级数收敛，那么$(1 + x + …) = \dfrac{1} {1 - x}$。则$G(x) = \dfrac{1} {(1 - x)^n}$。</p><p>于是可以使用上面的广义二项式定理了，得$x^r$的系数是$C_{n + r - 1}^r$。</p><p>回过来再考虑生成函数的问题，它为何要是无穷级数？为了方便表示”可重复元素“，也是为了计算上的方便，因为这样就可以在微积分和组合数学之间建立联系了，从而使用微积分中的一些性质。而对于实际的问题，我们都可以在模$x^r$的意义下考虑原式子，这样让人困惑的无穷就消失啦。</p><p>为何能假定上面的式子收敛？<del>我也不知道，好用就行了</del></p><p><strong>例4</strong></p><p>有三种硬币，币值分别为1、2、5，每种都有无穷个，求取r元有多少种方法？</p><h2 id="用生成函数解决排列问题-需完善"><a href="#用生成函数解决排列问题-需完善" class="headerlink" title="用生成函数解决排列问题[需完善]"></a>用生成函数解决排列问题[需完善]</h2><h2 id="用生成函数解决递推问题-需完善"><a href="#用生成函数解决递推问题-需完善" class="headerlink" title="用生成函数解决递推问题[需完善]"></a>用生成函数解决递推问题[需完善]</h2><p>考虑斐波那契数列的生成函数：$G(x) = \sum\limits_{i = 0}^{\infty} f_i x^i$，$G(x) = x + \sum\limits_{i = 2}^{\infty} f_i x^i = x + \sum\limits_{i = 2}^{\infty} (f_{i-1} + f_{i-2}) x^i = x + x\sum\limits_{i = 0}^{\infty} f_i x^i + x^2 \sum\limits_{i = 0}^{\infty} f_i x^i = x + xG(x) + x^2 G(x)$，则$G(x) = \dfrac{x} {1 - x - x^2}$，因式分解再裂项，就得到我们常见的结果了。</p><p>为什么生成函数这么奇妙？因为它巧妙地将递推关系用来消项。//<del>然后我也讲不出什么道道了</del></p><p>这里的G(x)看起来是很抽象的，有没有办法让它表现得具体一点呢？您好，有的。我们来算一下$G(1/10) = \dfrac{10}{89} = 0.1123595506…$，不难发现小数点后第i项就是斐波那契数列第i项（仅限前几项，因为后面的要进位）。</p><p>如此，我们便可以用生成函数在小数和数列间建立联系啦，也可以用生成函数得到一些好玩的小数。</p><h1 id="容斥原理-需补充"><a href="#容斥原理-需补充" class="headerlink" title="容斥原理[需补充]"></a>容斥原理[需补充]</h1><p>内容</p><p>素数个数（关注计算复杂度）</p><p>满射的个数</p><h2 id="错排问题"><a href="#错排问题" class="headerlink" title="错排问题"></a>错排问题</h2><p>后面的部分<a href="https://www.cnblogs.com/c1299401227/p/5349727.html" target="_blank" rel="noopener">引自网络</a>，略有删改。（不知是否这位老哥原创的）</p><p>$\forall i, f(i) \not = i, i, f(i) \in \{ 1, 2, …, n \};\forall i \not = j, f(i) \not = f(j)$，求符合要求的函数个数D(n)。</p><p>核心递推公式：</p><p>$D(n) = (n-1) [D(n-2) + D(n-1)]$</p><p>初始值：$D(1) = 0, D(2) = 1$。</p><h3 id="递推的推导错排公式"><a href="#递推的推导错排公式" class="headerlink" title="递推的推导错排公式"></a>递推的推导错排公式</h3><p>分析i = 1，它有n-1个取值。不失一般性，设$f(1) = 2$。再分析i = 2，若$f(2) = 1$，剩下的个数就是$D(n-2)$。</p><p>下面的一步就好玩了：如果$f(2) \not = 1$，那么剩下的个数是多少呢？注意！$f(2) \not = 1, f(3) \not = 3, …, f(n) \not = n$，这难道不是新的错排，个数是$D(n-1)$？于是，上面的递推式就得到啦！</p><p>下面咱们来推公式。</p><p>根据套路，设$D(n) = n! N(n)$，然后推一推，得//怎么想到要这么做的？</p><p>$nN(n) = (n-1) N(n-1) + N(n-2)$​，然后有</p><p>$N(n-1) - N(n-2) = (-1)^{n-1} / (n-1)!$，相加得</p><p>$N(n) = (-1)^2/2! + … + (-1)^{n-1} / (n-1)! + (-1)^n/n!$</p><p>故</p><p>$D(n) = n! [(-1)^2/2! + … + (-1)^{n-1}/(n-1)! + (-1)^n/n!]$</p><p>此即错排公式。</p><h3 id="用容斥原理的推导"><a href="#用容斥原理的推导" class="headerlink" title="用容斥原理的推导"></a>用容斥原理的推导</h3><p>用容斥原理也可以推出错排公式:</p><p>正整数1, 2, 3, ……, n的全排列有 n! 种，其中第k位是k的排列有 (n-1)! 种;当k分别取1, 2, 3, ……, n时，共有n*(n-1)!种排列是至少放对了一个的，由于所求的是错排的种数，所以应当减去这些排列;但是此时把同时有两个数不错排的排列多排除了一次，应补上;在补上时，把同时有三个数不错排的排列多补上了一次，应排除……重复该一过程，得到错排的排列种数为</p><p>$D(n) = n! - n!/1! + n!/2! - n!/3! + … + (-1)^n<em>n!/n! = ∑(k=2~n) (-1)^k </em> n! / k!$，</p><p>即$D(n) = n! [1/0! - 1/1! + 1/2! - 1/3! + 1/4! + … + (-1)^n/n!]$.</p><h3 id="简化公式"><a href="#简化公式" class="headerlink" title="简化公式"></a>简化公式</h3><p>错排的公式里有n项，计算复杂度是O(n)，有没有简便的近似值呢，像Stirling公式一般？有的，而且不仅仅是近似值：$D(n) = \lfloor n!/e+0.5 \rfloor$。（但是这个公式有何意义呢？计算n!不还得O(n)？）</p><p>以下是证明：</p><p>对$1/e$幂级数展开一波，得$1/e = e^{-1} = 1/0! - 1/1! + 1/2! - 1/3! - ….. + (-1)^n/n! + R_n(-1)$//看不懂</p><p>其中$R_n(-1)$，$R_n(-1) = (-1)^{n+1} \cdot e^u / (n+1), u∈(-1, 0)$</p><p>所以，$D(n) = n! \cdot e^{-1} - (-1)^{n+1} \cdot e^u / (n+1), u∈(-1, 0)$</p><p>而$|n! R_n| = |(-1)^{n+1} \cdot \dfrac{e^u} {n+1}| = \dfrac{e^u} {n+1} ∈ (\dfrac{1} {[e(n+1)]}, \dfrac{1}{n+1})$，可知即使在n=1时，该余项(的绝对值)也小于1/2。</p><h1 id="术语-需审核"><a href="#术语-需审核" class="headerlink" title="术语[需审核]"></a>术语[需审核]</h1><p>递推关系：recurrence relations</p><p>初始条件：initial conditions</p><p>线性常系数(非)齐次递推关系：linear (non)homogeneous recurrence relations with constant coefficients</p><p>关联的齐次递推关系：associated homogeneous recurrence relations（把F(n)去掉得到的递推关系）</p><p>特征方程/特征根：characteristic equation/roots</p><p>分治算法：divide-and-conquer algorithms</p><p>分治算法的递推关系：divide-and-conquer recurrence relation</p><p>最近点对问题：closest-pair problem</p><p>埃氏筛：sieve of Eratosthenes</p><p>错排：derangement</p><hr><p>完稿于2019-05-01</p>]]></content>
      
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学之美】离散数学及其应用：第六章 计数</title>
      <link href="/2019/06/22/Discrete_Mathematics-CH06/"/>
      <url>/2019/06/22/Discrete_Mathematics-CH06/</url>
      
        <content type="html"><![CDATA[<p>通过学习这一章，你可以了解到：</p><p>①抽屉原理及其应用</p><p>②一些排列组合的情形</p><p>③和排列相关的算法</p><a id="more"></a><h1 id="计数基础"><a href="#计数基础" class="headerlink" title="计数基础"></a>计数基础</h1><p>加法原理与乘法原理，注意它们和集合的关系（前者：$|\bigcup S| = \sum|S|$，后者：$|\prod S| = \prod |S|$），后者又用到了笛卡儿积，可见笛卡儿积在描述对象间关系中的基石地位。</p><p>容斥原理，推广到n元的情况。证明可考虑单个元素在集合中的存在与否。</p><p>碱基和分子生物学的联系</p><p>解答树（让思维更有层次性）</p><h1 id="抽屉原理"><a href="#抽屉原理" class="headerlink" title="抽屉原理"></a>抽屉原理</h1><p>最初的抽屉原理，推广的抽屉原理（公式，正推反推）</p><p>抽屉原理与单射的关系</p><p>抽屉原理的思想：考虑最坏情况</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><h3 id="朋友问题"><a href="#朋友问题" class="headerlink" title="朋友问题"></a>朋友问题</h3><p>证明：假设这世界上只剩n个人了（$n \geq 2$），那么必存在两个人他们的朋友数目相等。（每个人不能是自己的朋友）</p><p>视朋友数为抽屉，人为鸽子，这样看来鸽子数等于抽屉数，抽屉原理没法用了？非也。假设所有人朋友数相同的话，那么每个人的朋友数分别取到0、2、…、n-1，然而0和n-1是有不能同时取到，这样抽屉数就减少了。</p><h3 id="二分图-待补充"><a href="#二分图-待补充" class="headerlink" title="二分图[待补充]"></a>二分图[待补充]</h3><p>15-10</p><h3 id="球队比赛-待补充"><a href="#球队比赛-待补充" class="headerlink" title="球队比赛[待补充]"></a>球队比赛[待补充]</h3><p>//还不是很理解</p><h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><p>n+1个不超过2n的数中必有一数能够整除另一数。（思路：$k = p \cdot 2^k$）</p><h3 id="子列"><a href="#子列" class="headerlink" title="子列"></a>子列</h3><p>证明：$n^2+1$长度的互异实数列中必有长为$n+1$的单调递增子列或是单调递减子列。</p><p>嗯这题看上去比较抽象，简单地列一些数据也不能带来什么帮助。用什么代表抽屉和鸽子也都不好确定，如何切入呢？题目中“互异”这是个重要的条件，否则$n^2+1$个数全相等结论就不成立了。试试反证法吧，如果数列中任意单调递增/递减子列长度都小于等于n，会有矛盾吗？</p><p>下面的一步就需要一些创造力了。对于该数列，我们令$(f(i), g(i))$为以第i项开端的最长递增/递减子列长度构成的二元组。由之前的假设，数列中任意单调递增/递减子列长度都小于等于n，$(f(i), g(i))$的取值就只有$n^2$种可能，故$\exists i \not = j, (f(i), g(i)) = (f(j), g(j))$。但是呢，$a[i] \not = a[j]$（第i个数不等于第j个数），所以要么$f(i) &gt; f(j)$，要么$g(i) &gt; g(j)$。前面的结论不成立，矛盾！</p><h3 id="子列-1"><a href="#子列-1" class="headerlink" title="子列++"></a>子列++</h3><ol><li><p>$x_1, x_2, …, x_n$为整数数列，求证$\exists i \not = j, x_i + x_{i+1} + … + x_j \equiv 0 (mod n)$。</p><p>考虑模的意义下的前缀和就好啦。</p></li><li><p>$x_1, x_2, …, x_N, N = 2^n$中，$a_i \in \{ 1, 2, …, n \}$，求证$\exists i \not = j, x_i \cdot x_{i+1} \cdot … \cdot x_j$为完全平方数。</p><p>考虑前缀积，令$A_k =  \prod\limits_{i = 1}^k a_i = \prod\limits_{i = 1}^n i^{a_{i_k}}$，考虑在模2的意义下的$a_{i_k}$，这就是抽屉了。</p></li></ol><h3 id="Ramsey问题"><a href="#Ramsey问题" class="headerlink" title="Ramsey问题"></a>Ramsey问题</h3><p>（其实就是图的二染色啦）</p><p>证明：任意六个人中，必有三人相互认识，或者相互不认识。</p><p>上例表明R(3, 3) = 6。但是当m、n变大时，R(m, n)的值非常难确定。</p><h1 id="排列组合与二项式定理"><a href="#排列组合与二项式定理" class="headerlink" title="排列组合与二项式定理"></a>排列组合与二项式定理</h1><p>排列与组和的定义，排列与组和间的转换</p><p>技巧：捆绑</p><p>组合数和二项式系数的联系</p><h2 id="组合证明"><a href="#组合证明" class="headerlink" title="组合证明"></a>组合证明</h2><p>玄学东西，和代数证明相对的。比如，通过“式子本身的意义”能证明$C_n^r = C_n^{n-r}$。</p><p>另，通过“式子本身的意义”也能得出$C_n^r$是整数。</p><p>二项式定理，由其可以得出一些结论：$\sum C_n^k = 2^n, \sum (-1)^k C_n^k = 0, \sum 2^k C_n^k = 3^n$。</p><p>杨辉三角，及其中蕴含的递推关系（它的洋名字是“Pascal’s Identity”）</p><p>“杨辉等式”的组合证明：在全集中关注某特定元素，若取到，则为$C_n^{k-1}$，否则为$C_n^k$</p><p>Vandermonde等式：$C_{m+n}^r = \sum\limits_{k = 0}^r C_m^k \cdot C_n^{r-k}$（分组的思想，特别地，有$C_{2n}^n = \sum\limits_{k = 1}^n (C_n^k)^2$）</p><p>无名定理：$C_{n+1}^{r+1} = \sum\limits_{j = r}^n C_j^r$（证明有两种思路：①排序的思想，确定最大元；②杨辉等式）</p><h1 id="排列组合的推广"><a href="#排列组合的推广" class="headerlink" title="排列组合的推广"></a>排列组合的推广</h1><p>可重复元素的排列：$n^r$（模型：r长度字符串的可能个数）</p><p>可重复元素的组和：$C_{n+r-1}^r$（模型：取硬币的方法数，证明的思想在于将无序转换为有序，然后一一对应，计算时需要注意r是元素数而n是盒子数）//待补充</p><p>$x_1+x_2+x_3=11$这样的模型，既可以用栅栏法，也可以看作是可重复元素的组和。（$x_1$可看作是放数的盒子）</p><p>含可重复元素排列的重排数（模型：分发纸牌）</p><h2 id="物块放盒子"><a href="#物块放盒子" class="headerlink" title="物块放盒子"></a>物块放盒子</h2><p>放到盒子里，是不需要考虑顺序的，故这是组和问题而非排列问题。</p><p>不同的物体放不同的盒子（模型：分发纸牌）：可重复元素排列的重排数</p><p>相同的物体放不同的盒子：可重复元素的组和</p><p>不同的物体放相同的盒子（模型：四个学生分三组）：无封闭的公式，但可用第二类斯特林公式计算，记$S(n, j) = \dfrac{1}{j!} \sum\limits_{i = 0}^{j-1}(-1)^i C_j^i (j-i)^n$，则所求即$\sum S(n, j)$。</p><p>相同的物体放相同的盒子（模式：四本相同的教材分三组）：等价于$\sum a_i = n, a_1 \leq a_2 \leq … \leq a_j$的方法数，无封闭的公式。</p><p>需要补充：</p><p>Stirling数相关知识</p><p>球盒问题特殊情形</p><h1 id="生成排列与组和"><a href="#生成排列与组和" class="headerlink" title="生成排列与组和"></a>生成排列与组和</h1><h2 id="字典序"><a href="#字典序" class="headerlink" title="字典序"></a>字典序</h2><p>以排列a[1…n]与b[1…n]为例，前者按字典序比后者小即表明，出现第一个i满足a[i]&lt;b[i]之前，均有j&lt;i且a[j]=b[j]。</p><p>以abd与abs为例，容易发现前者的字典序更小。对于1,2,3的全排列，按字典序顺序有:<br><strong>1,2,3 &lt; 1,3,2 &lt; 2,1,3 &lt; 2,3,1 &lt; 3,1,2 &lt; 3,2,1</strong></p><p>我们不难发现，枚举1,2,3的字典序我们可以先令首位分别为1,2,3，再枚举后两项的字典序，这一做法是递归的。</p><p>从字典序的概念出发，我们可以得到从一个排列出发按字典序生成下一个排列的算法。</p><p>以2,4,3,1为例。我们发现末尾中4,3,1是从大到小排列的，没有下一项，故要考虑末位四项，其中3大于2，替换2与3的位置使首位成为3，后面依次递增，得到3,1,2,4</p><p>由此我们得到一般的算法框架：</p><h2 id="生成排列算法框架"><a href="#生成排列算法框架" class="headerlink" title="生成排列算法框架"></a>生成排列算法框架</h2><ol><li>从后往前，找到第一个令a[i]&lt;a[i+1]的i(即其后是逆序的)</li><li>在a[i+1…n]中找出最小的a[j]使a[j]&gt;a[i]，交换a[i]与a[j]的位置</li><li>令a[i+1…n]呈升序</li></ol><p>在给出具体的代码前，请读者演算362541的字典序下一项，以加深理解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码引自《离散数学基础（第二版）》，清华大学出版社</span></span><br><span class="line"><span class="comment">//参考习题：洛谷P1088</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">next_permutation</span><span class="params">()</span><span class="comment">//a[1...n]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = n<span class="number">-1</span>, j = n;</span><br><span class="line">    <span class="keyword">while</span>(a[i] &gt; a[i+<span class="number">1</span>]) i--;<span class="comment">//part 1</span></span><br><span class="line">    <span class="keyword">while</span>(a[i] &gt; a[j]) j--;<span class="comment">//part 2</span></span><br><span class="line">    swap(a[i], a[j]);</span><br><span class="line">    <span class="keyword">int</span> k = n;i++;<span class="comment">//part 3</span></span><br><span class="line">    <span class="keyword">while</span>(k &gt; i)&#123;swap(a[j], a[i]);k--;i++;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合数生成算法"><a href="#组合数生成算法" class="headerlink" title="组合数生成算法"></a>组合数生成算法</h2><p>这个和二进制对应一下就好了，不必多讲。</p><h2 id="r-组和的生成算法"><a href="#r-组和的生成算法" class="headerlink" title="r-组和的生成算法"></a>r-组和的生成算法</h2><p>还是通过例子先感受一下怎么得到“下一个”r-组和吧：{1, 2, 5, 6}的下一个是？（全集为{1, 2, 3, 4, 5, 6}）</p><p>5、6都“就位”，处于字典序的最终项了。所以下一项得把2换成3，后面再按字典序的开头来，就得到了{1, 3, 4, 5}。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//the code is from Discrete Mathematics and Its Applications</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">next_combination</span><span class="params">()</span><span class="comment">//a[1...r] is the subset</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = r;</span><br><span class="line">    <span class="keyword">while</span>(a[i] == n-r+i)</span><br><span class="line">        i--;</span><br><span class="line">    a[i]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt;= r;j++)</span><br><span class="line">        a[j] = a[j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学之美】离散数学及其应用：第五章 递推与递归</title>
      <link href="/2019/06/22/Discrete_Mathematics-CH05/"/>
      <url>/2019/06/22/Discrete_Mathematics-CH05/</url>
      
        <content type="html"><![CDATA[<p>通过学习这一章，你可以了解到：</p><p>①数学归纳法相关</p><p>②（我不知道）</p><a id="more"></a><h1 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h1><p>在第一章的最后我们也谈了谈数学归纳法，但并没有对其进行详细的探讨。所以这里还得补上。数学归纳法，本质上是一种递归的思想。明白了这一点，我们便能从大学而非高中的视角来看待它。</p><p>其正确性很容易为我们所理解，严谨地说呢，则源自良序性公理，集合中存在最小元。</p><p>数学归纳法是一种很强大的方法，用就是了，不用管对要证的东西理不理解。故较难的情形是在不显然的语境中找出使用数学归纳法的条件，这在下面的区间选择，馅饼战争乃至后文中的霍尔婚配定理上均有所体现。</p><p>因为数学归纳法可以无脑使用，它往往不能揭示所要证的命题背后的逻辑。如$\sum i^3 = [\frac{n(n+1)}{2}]^2$。数归一下就证好了。但为什么有这个式子呢？它是怎么被发现的？这都是数归所无法解答的问题。</p><p>数归被广泛地应用在证明和式，不等式，整除问题及算法分析上。简单的例子能够展现数学归纳法的有力之处，同时给予我们学习的信心；而复杂的例子则能给我们带来思维上的挑战。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>例题1：用数学归纳法证明n元的德摩根律。</p><p>例题4：三联骨牌覆盖问题。</p><p>例题2：用数学归纳法证明选区间问题中贪心算法的全局最优性。</p><p>//证明比较刁钻，也比较有创造性，待补充</p><p>例题3（Odd Pie Fights）：有奇数个两两距离不同的人，他们手中各有一个pie，会朝离自己最近的人扔pie。证明扔完一轮以后存在没被扔到pie的人。</p><p>证明（第二步）：由归纳假设，当人数为2k-1时原命题成立。考虑人数为2k+1的情况。</p><p>记AB间距离最短。考虑A，若他被B以外的人扔了pie，则因扔出的pie总数为2k+1，AB以外的2k-1个人只能被少于2k-1个pie扔到（AB被扔了至少3个），必然有人没被扔到。</p><p>若A只被B且B只被A扔了pie，那么可以先不考虑他们。剩下2k-1个人，由归纳假设，必然有人没被扔到。综上，证毕。</p><p>数学归纳法使用的谬误：要么前提错了，要么归纳不合理。这里要注意，归纳的合理性可能跟n的大小有关系。表面看看很有道理的归纳，可能在n较小的情况下不成立。请看下面的例子：</p><p>我们用数学归纳法证明所有的马都是同一颜色的。n=1，显然。n&gt;1，有归纳假设，前n-1匹马和后n-1匹马同色，而所以$color[head] = color[middle] = color[tail]$，证毕。</p><h2 id="第二类数学归纳法"><a href="#第二类数学归纳法" class="headerlink" title="第二类数学归纳法"></a>第二类数学归纳法</h2><p>在计算几何、博弈论等领域，使用第二类数学归纳法相比第一类更为方便。</p><p>例题1：证明任何大于1的整数可写为素数之积。</p><p>例题2：证明仅有2分和5分邮票就能组成大于等于5分的每种邮资。（思考，不可仅由m，n分邮票组成的最大的邮资是多少？）</p><p>例题3：$G(V, E), |V| = n \geq 3$为有向完全图，其中存在长度大于3的环，证明其中存在长度为3的环。（这个例子主要用于了解如何正确运用良序性公理）</p><h1 id="递归定义-待补充"><a href="#递归定义-待补充" class="headerlink" title="递归定义[待补充]"></a>递归定义[待补充]</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学之美】离散数学及其应用：第三章 算法入门</title>
      <link href="/2019/06/22/Discrete_Mathematics-CH03/"/>
      <url>/2019/06/22/Discrete_Mathematics-CH03/</url>
      
        <content type="html"><![CDATA[<p>这章中没有涉及到许多精妙的艰深的算法，它主要是普及基础性的的概念。</p><a id="more"></a><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>这一章我们要学些什么呢~</p><p>①基本操作：搜索（序列中）与排序</p><p>②具体算法：欧几里得算法、集合生成算法、最短路算法</p><p>③算法思想：BF算法、贪心算法</p><p>④算法限制：时空复杂度</p><h2 id="算法的概念"><a href="#算法的概念" class="headerlink" title="算法的概念"></a>算法的概念</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>实际的问题很多都能转化为数学模型，这是我们上一章的所学~转化成了模型之后，就可以用算法来解决问题啦~</p><p>说到算法，一个很好的类比是菜谱，它们的共性很多：都是有限步的可操作步骤的序列。</p><p>算法（algorithm）的名称来源于阿拉伯数学家阿剌子模（Al-Khowarizmi），也可以看作是“对数”（ Logarithm）的重排。</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>线性搜索、二分搜索（限于良序集）……</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>冒泡排序、插入排序……</p><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>贪心算法（Greedy Algorithm）是解决最优化问题（optimization problem）的一种方式，它常常很有效，但有时也会失效（局部最优不一定保证全局最优）。</p><h4 id="找零问题"><a href="#找零问题" class="headerlink" title="找零问题"></a>找零问题</h4><p>考虑这样一个问题：用25毛，10毛，5毛，1毛来找钱的问题，如何使得硬币总量最少呢？贪心即可。</p><p>并非所有的币值的组合都能保障贪心的最优性，如25毛，10毛，1毛，找30毛的时候贪心就会出问题。</p><p>为什么会有这样的不同呢？关键在于小的币值能否总是换成更大的币值。在第一种情况中，如果5毛有2个，那么换成一个10毛答案会更优。故而5毛不能超过1个。而在第二种情况中，10毛可以超过2个，而不换为25毛。</p><h4 id="区间选择问题"><a href="#区间选择问题" class="headerlink" title="区间选择问题"></a>区间选择问题</h4><p>有这么一些区间$[l_1, r_1], [l_2, r_2], …, [l_n, r_n]$，问如何选区间能够使选择的区间尽可能多并保证没有两个区间相交？</p><p>lrj有做过证明，证得不错，这本书的后面也有相关的证明。</p><p>//待补充。</p><h3 id="停机问题"><a href="#停机问题" class="headerlink" title="停机问题"></a>停机问题</h3><p><a href="http://www.matrix67.com/blog/archives/901" target="_blank" rel="noopener">http://www.matrix67.com/blog/archives/901</a></p><h2 id="大O与大-Theta"><a href="#大O与大-Theta" class="headerlink" title="大O与大$\Theta$"></a>大O与大$\Theta$</h2><h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><h3 id="Euclid算法的复杂度"><a href="#Euclid算法的复杂度" class="headerlink" title="Euclid算法的复杂度"></a>Euclid算法的复杂度</h3><p>由裴蜀定理，d可表示为a、b的线性组合</p><p>大家可能听过P/NP问题还有NP完全问题等等概念（Steve Cook，就是这崽子发明的稀奇古怪的名称，NP问题、NP完全问题、NP困难问题这样的名称看着真的难受），这里引m67的一篇博文以飨诸位：<a href="http://www.matrix67.com/blog/archives/105。" target="_blank" rel="noopener">http://www.matrix67.com/blog/archives/105。</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学之美】离散数学及其应用：第二章 基本结构</title>
      <link href="/2019/06/22/Discrete_Mathematics-CH02/"/>
      <url>/2019/06/22/Discrete_Mathematics-CH02/</url>
      
        <content type="html"><![CDATA[<p>通过学习这一章，你可以了解到：</p><p>①集合、函数、序列、前缀和、矩阵</p><p>②（我不知道）</p><a id="more"></a><h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>这里涉及的是康托尔的朴素集合论而非公理集合论。后者是为解决悖论（著名的罗素悖论）而出现的，更为抽象。</p><p>集合有两种表示方法：穷举抑或描述。</p><p>Venn图在证明关于集合的命题中比较直观，关于证明，还可以采取列真值表，等价推导的方法。</p><p>集合是无序的，而有序的概念是“元组”，有了顺序，乘法就有了规范。集合的乘法称笛卡尔积（Cartesian product），它不满足交换律，除非两边相等或有空集。</p><p>谈到笛卡尔，你的第一印象是否会是平面直角坐标系？（抑或是“Cogito ergo sum.”？）事实上，笛卡尔积正是坐标系的基础：$R \times R$的结果便是所有二元组$(x, y)$的集合。推广到更高维也同理。</p><p>正如前面我们提到的模糊逻辑，模糊集合在AI中有广泛的应用。另外，多重集合也用于表示复杂图。</p><h3 id="幂集"><a href="#幂集" class="headerlink" title="幂集"></a>幂集</h3><p>以下是一些关于幂集的结论。</p><p>$x \in P(S) \Rightarrow x \subseteq S$</p><p>$x \in S \Rightarrow \{ x \} \in P(S)$</p><p>$S \in P(S)$</p><p>$P(A) \in P(B) \Rightarrow A \in B, A \in B \not \Rightarrow P(A) \in P(B)$</p><p>$A \subseteq B \Leftrightarrow P(A) \subseteq P(B)$</p><h3 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h3><p>总计五种：交（intersection）、并（union）、补（complement）差（difference）、对称差（symmetric difference）。顺带一提，compliment和complement是易混淆的单词，它们的意思是什么呢？</p><p>集合恒等式：类似逻辑中的等价，证明也类似。</p><p>交集的元素个数，用交与并表示对称差，集合的计算机表示。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>提到函数，我们先要提映射。如同其他的很多概念一样，和图一样，映射也是架构在集合之上的。集合论，是现代数学大厦的基石之一。</p><p>映射相关术语：domain&amp;codomain，image&amp;pre-image（像与原像），range（domain的子集），map。</p><p>映射的类别：one-to-one（单射，亦称injection），onto（满射，亦称surjection），bijection（双射，亦称one-to-one correspondence）。</p><p>映射的逻辑表示如下</p><ul><li>one-to-one：$\forall x \forall y (x \not = y) f(x) \not = f(y)$</li><li>onto：$\forall (y \in B) \exist (x \in A) f(x) = y$</li></ul><p>习题：存在$f : A \rightarrow B$，$|A| = m, |B| = n$。求$f$分别为一般映射、单射（如果是满射，考虑逆映射就好了）以及$f$为partial时满足以上条件可能的f数目。（$key: n^m, A_n^m, (n+1)^m, \sum\limits_{k = 0}^m C_m^k A_n^{m-k}$）</p><p>//最后一项未经验证？</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>书中记了一些不是很常用的记号：$(f_1 + f_2)(x) = f_1(x) + f_2(x), (f_1 f_2)(x) = f_1(x)f_2(x)$。</p><p>$f(S) = \{ t | \exist s \in S (f(s) = t) \}$，以此可以较严谨地证明$f(S \bigcap U) \subseteq f(S) \bigcap f(T)$。</p><p>关于函数复合和反函数，有$(f^{-1} o f)(x) = x$。</p><h3 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h3><p>floor、ceil、fractional……</p><p>这里我们就主要讨论“底与顶”吧，恰好《具体数学》也就其写了一整个章节。</p><p>为什么引入底之后还要引入可以之表示的顶？为了形式上推理的方便，正如我们既有sin也有cos一样。</p><p>$-\lfloor x \rfloor = \lfloor -x \rfloor$不总是成立，但是$- \lfloor x \rfloor = \lceil -x \rceil$。</p><p>如要将$\lfloor x \rfloor$的括号除去，我们可以用不等式（根据n的位置，也有两种形式），或者将它表示出来：$\lfloor x \rfloor = x - \{ x \}$。</p><p>一个真命题：$\lfloor \sqrt x \rfloor = \lfloor \sqrt {\lfloor x \rfloor} \rfloor$</p><p>由其联想到的真命题：$( f(x)为整 \rightarrow x为整) \rightarrow \lfloor f(x) \rfloor = \lfloor f({\lfloor x  \rfloor} ) \rfloor$</p><p>//证明待补充</p><p>由上述命题引出的有用结论：$\lfloor \frac{x + m}{n} \rfloor = \lfloor \frac{\lfloor x \rfloor + m}{n} \rfloor$</p><p>一个假命题：$\lceil \sqrt x \rceil = \lceil \sqrt{\lfloor x \rfloor} \rceil$（思考：它何时为真？）</p><p>实用的问题：$[\alpha, \beta]$中的整数个数？左闭右开如何，左开右闭又如何，左开右开呢？</p><p>有趣的问题：具体数学赌场中的转轮赌轮有1000个（或n个）投币口，标号从1到n，若$\lfloor \sqrt[3]n \rfloor | n$则庄家赔我们五百块，否则我们给庄家一百块。问玩100局是否会被警察抓起来。</p><p>有趣的问题：没有两个谱是相等的；Spec($2$)和Spec($2 + \sqrt 2$)构成正整数的一个划分。</p><p>有趣的问题：隔两人处决一人的约瑟夫问题。</p><p>//细节待补充</p><h2 id="基数"><a href="#基数" class="headerlink" title="基数"></a>基数</h2><h3 id="无限的概念"><a href="#无限的概念" class="headerlink" title="无限的概念"></a>无限的概念</h3><p>无限实际上有两种：潜无限与实无限。前者表明一种趋势，比如微积分中的极限就是一种潜无限：比任意接近都更接近。而后者则是将无限作为一种实体考察，它是一个怪兽一般不符合常识的存在。古希腊人就不承认实无限的存在，他们的证明总是“素数的数量比任意给定的数都大”而非“素数有无穷多个”。另外，芝诺的悖论也令人们对后者感到恐惧。真正以科学而非思辨考察实无限的开拓者，大概就是康托吧。</p><h3 id="无限的大小"><a href="#无限的大小" class="headerlink" title="无限的大小"></a>无限的大小</h3><p>判断无限集合，我们唯一可以信赖的方法便是一一对应，而非“整体大于部分”的原则。这一规则是康托所提出的，它并非先验的，受到了当时（也包括现在）不少人的质疑与排挤，被认为是异端邪说。康托晚年深受精神疾病的折磨，可即便如此，他还是以一己之力将集合论发展到了一定的高度，为现代数学大厦搭好了基石。康托实在是个伟大的人，虽说我对他还并不了解。</p><p>所谓可数，指的是一个集合与有限集或是自然数集具有相同的基数，即可建立二者间的一一映射。</p><p>基数、势，讲的是一个东西，无限集基数相等称为等势。</p><p>先从简单的结论开始吧：证明正整数和整数一样多。（不妨从希尔伯特旅馆的角度再看看这个例子：我们所关注的是每个个体，而非不可描述的整体）</p><p>再来是集合论中经典而又令人惊诧的结论：正整数和正有理数等势；无理数较有理数势更高。</p><p>以上分别用了两种对角线，后者即著名的康托对角线法。</p><p>通过一系列的推导，我们知道整系数多项式是可数的，故代数数——整系数多项式的根是可数的，而超越数是不可数的，即它要比代数数多得多。有趣的是，我们能数的过来的超越数少之又少。//代数数的相关资料？</p><h3 id="Schroder–Bernstein定理"><a href="#Schroder–Bernstein定理" class="headerlink" title="Schröder–Bernstein定理"></a>Schröder–Bernstein定理</h3><p>给定两集合A、B。若存在$A \rightarrow B$与$B \rightarrow A$的单射（即$|A| \leq |B|$且$|B| \leq |A|$），那么|A|=|B|。</p><p>这一定理可用于证明$|(0, 1)| = |(0, 1]|$，构造g:f(x) = x/2是$B \rightarrow A$的单射即可。</p><h3 id="不可计算数"><a href="#不可计算数" class="headerlink" title="不可计算数"></a>不可计算数</h3><p>图灵机的指令数是可数的，而实数是不可数的，故存在不可计算的数，Chaitin常数便是一个，不过我并不知道它为啥不可计算……</p><h3 id="连续统假设"><a href="#连续统假设" class="headerlink" title="连续统假设"></a>连续统假设</h3><p>先看一道例题：从正整数到{0，1，…，9}的所有映射的集合的势与[0, 1]内实数形成的集合的势相等。</p><p>把上面的十进制改为二进制，可以得到$N$的幂集与实数集等势。</p><p>记正整数的势为$\aleph_0$，实数集的势为c，上述结论即$2^{\aleph_0} = c$。如果势是可数的，而且它们按大小可以记成$\aleph_0 &lt; \aleph_1 &lt; …$（所谓一个无穷集“小于”另一者，指的是前者到后者无法得到满射）。那么，连续统假设说的就是$c = \aleph_1$，也即在两者中间没有元素。</p><p>这里连续统假设的语言表述中假设了无穷集的势的集合是离散的，是可数的。</p><p>连续统假设长久没有得到解决，希尔伯特将其作为“第一问题”。之后哥德尔还有科恩证明了CH（continuum hypothesis）在ZF公理系统中不可判定。ZF公理系统是什么？区别于“朴素集合论”的公理体系，规范了一下集合的基本性质等等，具体有八条，至少我不懂。</p><p>连续统假设假设的是$2^{\aleph_0} = \aleph_1$，照这个思路，有“广义连续统假设”（GCH）：$2^{\aleph_i} = \aleph_{i+1}$，这似乎更加困难，不过先贤也已经证明了它在ZF公理系统还有ZFC公理系统中的不可判定。ZFC比ZF多了项选择公理，反正我不懂。</p><p>小声BB一句，这些ZF、ZFC系统的名字第一眼看到感觉比较随便，没有“黎曼几何”“罗巴切夫斯基几何”看着大气，让人感觉这些所谓“公理”有一些随便（个人意见）。</p><p>我有点不明白：为什么$|N| = \aleph_0$呢，即为什么正整数的势是最小的势呢？有没有比可数集更“小”的无限集呢？</p><h3 id="攻玉与其他"><a href="#攻玉与其他" class="headerlink" title="攻玉与其他"></a>攻玉与其他</h3><p>先贴一下m67的文章：</p><p><a href="http://www.matrix67.com/blog/archives/2172" target="_blank" rel="noopener">http://www.matrix67.com/blog/archives/2172</a></p><p><a href="http://www.matrix67.com/blog/archives/4812" target="_blank" rel="noopener">http://www.matrix67.com/blog/archives/4812</a></p><p>然后讲讲文学作品中的“无限”吧。</p><p>谈到基数，弱弱地安利一下刘宇昆的《可数集》。小说将理性与非理性、数学的简单与生活的复杂做了很好的映射，以别出心裁的方式（有些意识流，在这个设定下尤其自然）表现了两个世界的冲突：理性的学术（或者更柏拉图些，“理念”）与非理性的生活。当主人公走在康托的路上，觉察到数学的可怖与不可描述，体味到理念的无稽与诡谲之时，他也只得放弃自己曾经坚守的理性，成为生活的荒诞的一部分，在多种意义上。这篇用大刘的话说，是“从宏大的数学背景上重新审视人生”，颇具“科幻的诗意”。</p><p>谈到无穷，也不能不提博尔赫斯，《小径分岔的花园》《巴别图书馆》《阿莱夫》《沙之书》……不过这边就不展开了。顺便，《可数集》收录在《杀敌算法》里头，而《科幻世界》中的译名是“人生可数集”，我觉得是画蛇添足（原文<em>The Countable</em>）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学之美】离散数学及其应用：第一章 逻辑与证明</title>
      <link href="/2019/06/22/Discrete_Mathematics-CH01/"/>
      <url>/2019/06/22/Discrete_Mathematics-CH01/</url>
      
        <content type="html"><![CDATA[<p>通过学习这一章，你可以了解到：</p><p>①形式逻辑与谓词逻辑相关知识</p><p>②一些证明的方法</p><a id="more"></a><h1 id="命题逻辑"><a href="#命题逻辑" class="headerlink" title="命题逻辑"></a>命题逻辑</h1><p>逻辑中的符号系统：对自然语言的抽象，以便研究符号间的关系。</p><p>通过对复杂的语句进行编码，用逻辑学的方式讨论他们，那么语句本身的特殊性就消失了，含糊与歧义在一定程度上的被消灭了（但整个系统并非完备的，据哥德尔的证明）。这样语篇就被转化为了命题的组合，我们得以更容易地判断它们是否合乎逻辑的。</p><p>命题的定义即可判断真假的陈述句，故若将命题记作变量p，则它有两种取值，那么我们可以把它和二进制，和布尔代数联系起来。但世界上也存在多值逻辑与模糊逻辑。//虽然我根本不懂</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>命题（Proposition），“往矣”“可乎”“此言谬矣”等并非命题。</p><p>否定（Negation）</p><p>合取（Conjunction），$\wedge$，and的抽象。</p><p>析取（Disjunction），$\vee$，or的抽象。</p><p>异或（Exclusive Or），在自然语言向符号系统转化的时候尤其要关注关系是exclusive还是inclusive。</p><p>异或有个很漂亮的应用，博弈论中的Nimm’s Game，它涉及的性质是a^b=0当且仅当a=b，还有异或的交换律，所以这种博弈以所有数的异或和作为判断基准。（我瞎说的）</p><p>异或还有一些简单的性质，在有的题目中可能会用到。如a ^ b = c $\Leftrightarrow$ a ^ c = b，还有a - b $\leq$ a ^ b。这些并不难证明，但要想到它们就有一些难度了。</p><p>蕴含（Implication），关注only if和if的区别，充分条件和必要条件及其他表达。蕴含式的真值规则可以在生活中找到一些很好的例子，如合同，承诺等。</p><p>等价（Equivalent），注意它和$\equiv$还有$\Leftrightarrow$的区别，后两者是等价的。</p><p>真值表（Truth Table），多用于证明，但我不大喜欢这样的证明，感觉不如Venn图直观，也不如简单的推理来得漂亮。</p><p>概念还有运算符顺序、位运算。//运算符顺序为何如此？</p><p>习题1：有100句话，第i句说的是“这些话中恰有i句是假话”（变式：“这些话中至少i句是假话”），求哪些是真话哪些是假话。（lrj在他的鬼书里也有这样递归的鬼问题，但我不会啊qwq）</p><p>习题2：判断$(p \vee \lnot q) \wedge (q \vee \lnot r) \wedge (r \vee \lnot p)$何时为真，何时为假。</p><p>习题3：判断$(p \wedge q \wedge r) \vee (\lnot p \wedge \lnot q \wedge \lnot r)$何时为真，何时为假。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>1.翻译自然语言并判断其间的逻辑性。</p><p>2.对一大串语言能否同时为真做判断。因为语言所涉及的多为一个系统所以这也叫System Specification。如果同时为真，称they are consistent。</p><p>3.在数据库中检索信息，在网络中查找网页。（在吴军老师的书中有进一步的介绍，但我还没好好看）</p><p>4.Puzzles，如说谎者游戏。这些游戏可能能发展小孩的智力。道奇森在这方面有一定的建树，其著作《爱丽丝漫游奇境》就蕴含了作者丰富的数学思想和对儿童的深切的关爱。</p><p>5.表示逻辑电路（香农首次大规模将逻辑与电路连接起来，从而建立了通信理论的大厦）。</p><p>Exercise 15，16，17，//题干太长懒得抄</p><p>习题2：斑马问题（zebra puzzle）</p><p>题解：先冷静下来，放松一下心情。（怪我英语不好，把to the right和on the right意思搞反了，也懒得改过来了，就这么做吧~心路历程而已）</p><p>1.先观察房子颜色，题目中出现了全部五色房子，挪威人住第一间，他右边是蓝房子。房子颜色，经过简单疏理，是黄蓝红绿白或黄蓝绿白红，推出挪威人住黄房子，他是外交官，然后蓝屋子屋主养马。</p><p>2.绿屋子人喝咖啡，而中间屋子人喝奶，所以房子排列只能是黄蓝红绿白。英国人住红房子喝奶。</p><p>3.下面看职业和饮料。𠸄人嗜奶，意人嗜茶，挪威人是外交官，日本人是画家，故而喝橙汁的音乐家是西班牙人，他养狗，不住蓝屋子（马限制），不住红屋子（英国人已占），不住绿屋子（咖啡限制），住白房子。</p><p>4.意大利人喝茶，不住绿屋子，那么他住蓝屋子。排除法得日本人住绿房子，画家，喝咖啡。</p><p>4.再看宠物。摄影师养蜗牛，西班牙人白房子养狗，意大利人蓝屋子主养马，挪威人不是摄影师，那么摄影师是意大利人或英国人，若为前者，则后者是医生，旁边没狐狸，矛盾。所以英国人是摄影师养蜗牛，挪威人养狐狸。排除得日本人养斑马。</p><p>5.英国牛奶，西班牙橙汁，意大利的茶，日本咖啡。排除出来矿泉水挪威。</p><p>疑惑：为什么错误的前提也能推出正确的结论呢？是什么影响了答案的走向与其是否自洽？另外，这个题目是如何构思出的呢？怎样保证在讯息最少的情况下可解呢？</p><h2 id="等价"><a href="#等价" class="headerlink" title="等价"></a>等价</h2><p>等价、同构，将复杂的问题归而为一，充分展现了数学的奇妙与瑰丽。</p><p>等价涉及了一些概念：重言式或永真式，矛盾式，将这些概念和蕴含想结合定义等价会更方便。</p><p>说到等价，势必要讲到一系列定律，其中需要记的有德·摩根律（及其n元形态）、分配律、蕴含到析取合取的转化，而对吸收律等的运用要具备一定观察能力。</p><p>判断命题为真时的取值问题，习题3是个很好的例子。</p><p>上述问题的一个应用是解数独，貌似可以用bfs实现。//但我还不会啊qwq，而且书上那个记号是啥意思咧？</p><p>习题1：探索何谓对偶命题及为何等价的命题能推出其对偶命题也等价。//不会鸭。。</p><p>习题2：Exercise 41，有无更巧妙的构造方法？</p><p>习题3：什么样的取值能使$p \vee \lnot q \vee s, \lnot p \vee \lnot r \vee s,$ $ \lnot p \vee \lnot r \vee \lnot s, \lnot p \vee q \vee \lnot s$ $, q \vee r \vee \lnot s,<script type="math/tex">q \vee \lnot r \vee \lnot s,</script> \lnot p \vee \lnot q \vee \lnot s, p \vee r \vee s, p \vee r \vee \lnot s$中尽可能多的值为真呢？//普遍的算法？</p><p>//NAND，NOR这些都什么东西？干嘛要提它们？</p><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>命题的组和是无穷无尽的，但其真值是有限的。为了将不同形式下真值一致的复合命题归为一类，我们引入范式(normal form)的概念，其中有CNF与DNF两类(C for conjunction)，他们间也可以互相转化。//补充</p><p>不过，许多范式仍然不够漂亮，比方说$p \vee \lnot p \vee (q \wedge \lnot r)$。为了让范式更加规范，我们引入主(full)析取/合取范式的概念，这样范式就和真值表紧密相连了。而任何命题均可转化到范式，由真值表易知。</p><p>欲将复合命题转化为范式，一种做法是列真值表，这是比较容易的。如果得到了主析取范式，利用真值表也能够直接得到主合取范式。</p><p>另一种做法是直接推导。先将部分的$\lnot$（任何不是修饰原子命题的）及$\rightarrow$除去及重复的原子命题。这样原命题便被转化为$p_i, \vee, \wedge$的串，接着再大量使用结合律就好了，同时注意添项。//例子</p><h1 id="谓词逻辑"><a href="#谓词逻辑" class="headerlink" title="谓词逻辑"></a>谓词逻辑</h1><h2 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h2><p>谈到逻辑，一个相当经典的概念便是亚里士多德提出的三段论。然而，仅凭命题逻辑无法从小前提与大前提得出结论，因为前提与结论中有的只是内容而非形式上的联系（还记得么？命题逻辑中的if then前后的语句无需有任何关联。还有，包含未定变元的陈述句亦不成命题）。数学上，我们常要研究对象的性质问题，故需将问题细化，从命题逻辑深入谓词逻辑。</p><p>谓词逻辑中的对象一般是未定式，故在形式上一个谓词命题，P(x)，看上去更接近一个函数，x也有自己的定义域(domain)。看到变元就关注定义域是一个重要而良好的习惯。</p><h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><p>x的定义域是一个集合，其中的元素有的满足性质P，有的并不满足。为了表达定义域中是否存在满足性质的x这一需求，我们再引入量词(quantifier)的概念。常用的量词有$\exists, \forall$，不常见的有$\exists_1$等等。</p><p>量词的引入实则是对符号系统的一种简化，使其能更好地符合我们的思维习惯以提高推理效率。以$\forall x P(x)$为例，它等价于$\bigvee\limits_x P(x), x \in S$。因为这种等价性，含量词的复合命题在取否定有“存在转任意，任意转存在”的规则，这实则就是德摩根律的推广。</p><p>量词的一个重要要素就是它的约束范围，即它与哪一式子结合(bind)。$\forall x P(x) \wedge \forall x Q(x)$与$\forall x (P(x) \wedge Q(x))$在意义上并不一致。前者那样的写法在式子变得更加复杂时很可能引起一定程度混乱，故我们再引入前束范式(prenex normal form)的概念——将所有量词提前，可能产生歧义的变元用不同的记号标识（插一句，我觉得$\forall x (P(x, y) \wedge \forall y Q(y))$这样的写法很反人类）。</p><h2 id="等价-1"><a href="#等价-1" class="headerlink" title="等价"></a>等价</h2><p>涉及量词的等价，往往不能简单粗暴地列真值表了，而是要用推理了。</p><p>习题？证明$\forall x (P(x) \wedge Q(x)) \equiv \forall x P(x) \wedge \forall x Q(x)$和$\exists x (P(x) \vee Q(x)) \equiv \exists x P(x) \vee \exists x Q(x)$，举出$\exists x (P(x) \wedge Q(x)) \not\equiv \exists x P(x) \wedge \exists x Q(x)$还有$\forall x (P(x) \vee Q(x)) \not \equiv \forall x P(x) \vee \forall x Q(x)$的例子。</p><p>另外还有量词命题和无量词命题(null quantification)析取合取（如$\forall P(x) \vee A$）的等价式，一般情况下都是可以直接去括号的，但涉及蕴含的时候要小心点因为蕴含和否定是相关联的。</p><p>谓词和量词的概念就介绍到这里了，不过有了新的记号我们前面的翻译啊什么的也都升级了，毕竟这一章仍是前几章的推广嘛，中心思想仍未变。翻译中值得注意的一种类型是定义域较小的情况。比方说，令全集为生物，P(x)表示“x是狮子”，Q(x)表示“x爱喝茶”。则“所有狮子爱喝茶”是$\forall x (P(x) \rightarrow Q(x))$，而“有狮子爱喝茶”是$\exists x (P(x) \wedge Q(x))$。为什么会这样？其实只要关注狮子以外的动物就好了。</p><p>//书上的习题没怎么做，标*的也就是类似三段论的。</p><h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><p>上面讲的往往都是单个量词的情况，但现实是“更多量词，更多欢乐”。比如说，表示加法结合律，表示$\epsilon - \delta$语言，都要用到量词的嵌套。量词嵌套涉及到顺序的问题，里头的规则很简单：相同的能替换，不同的不能换，这也很好理解，可以在脑海中对所有元素遍历一遍来加深印象。</p><p>有新的概念引入，否定自然也是要实时更新的了，不过规则格外简单：存在变任意，任意变存在，否定移进去。</p><p>有新的概念引入，翻译自然也会更新了，除了和自然语言间转来转去，有了量词嵌套，数学语言也可以加入转换行列了，快来用最新的量词嵌套试试九种最基本的算数性质吧！</p><p>有了嵌套，命题者就可以用更<del>新颖</del>恶意的方式定义$\exists_1$等量词了。比如，好好的$\exists_1 b P(a, b)$会变成$\exists b \forall c (P(a, b) \wedge (b \not = c) \rightarrow \lnot P(a, c))$，更漂亮了对吧。</p><h1 id="推理与证明"><a href="#推理与证明" class="headerlink" title="推理与证明"></a>推理与证明</h1><p>在讲命题逻辑的时候，我们都是根据已有的命题组判断其真假性，涉及到的命题组还只是个封闭的集合。那么，我们能否由已知的命题推出新的命题，比如三段论中的结论？推理规则就要派上用场了，它能让我们进行推理——在假定premises均为真的情况下推出新的命题。</p><h2 id="推理规则"><a href="#推理规则" class="headerlink" title="推理规则"></a>推理规则</h2><p>关于推理规则有一整张表，但是我不喜欢列表，就逐项分析吧。</p><p>1.Modus ponens/tollens，它们和蕴含相关联。前提真则结论真，结论假则前提假，非常好理解。关于后者的证明可以直接感受也可以列真值表也可以用逆否命题来证，个人感觉最后一项比较漂亮，因为它涉及的是化归的思想。而且，使用逆否命题有时候可以让推理变得简单。</p><p>//关于modus ponens的中文命名“假言推理”我并不是很明白。同时这些规则为什么要叫这些名字呢？</p><p>2.Hypothetical syllogism，假言三段论，这就更好理解了。可以把它和析取三段论（Disjunctive syllogism）放一块记。</p><p>3.和析取/合取有关的规则。从单项到合取式是添项（Addition，$p \Rightarrow p \vee q$），从析取式到单项是减项（Simplification，$p \wedge q \Rightarrow p$），还有析取（Conjunction，$p, q \Rightarrow p \wedge q$）。很容易推，因为前提是真的。</p><p>4.Resolution，这个比较特别，两个析取推出一个析取，起到删项的作用。有点像一个元素和他的逆相乘然后抵掉这样的感觉。</p><p>推理规则和永真式是有所联系的，比如$p_1, p_2, …, p_n \Rightarrow q$是有效（valid）推理，那么$\bigwedge\limits_i p_i\rightarrow q$便是永真式。</p><p>一般情况下我们要推理的结论都是可爱的非复合命题，如果它长得比较丑陋，比方说，$p \rightarrow q$，该怎么办呢？不用慌，把p看作新的条件而q看作新的结论就好了。而如果它是析取项，可以考虑Resolution。</p><p><del>5.Fallacy of affirming the conclusion，错误推理。</del>比如，有萌新可能会发现这样的新大陆：$p \rightarrow q, q \Rightarrow p$。这非常的正确！而且它还有好多等价的涉及否定的变形，快来用它们拓展你的推理规则仓库吧！（手动滑稽）</p><p>5.涉及量词的推理，universal/existsential instantiation/generalization，共四个，可以望文生义。为什么要引入它们呢？因为我们具体推理地时候不能抽象地说“存在一个”“对任一”，而要用具体的符号表示“那一个/那一类”。但引入这些东西有时候也会造成推理的错误，但一般通过举出一个具体的例子这一方式还是能发现问题所在的。</p><h2 id="证明初步"><a href="#证明初步" class="headerlink" title="证明初步"></a>证明初步</h2><p>证明，首先有Formal Proof与Informal Proof之分，前者是上一节所要遵守的规范格式，很丑陋，很麻烦，很不人性，故现实中我们一般都采取后者，省掉一些“显然”的步骤来使证明在格式上更漂亮。但是要注意，“显然”有时并不“显然”，蕴含了跳步与可能的错误。为让愚昧的计算机理解智慧的人类的证明，我们只得采取Formal Proof。</p><p>关于证明，这里推荐张景中院士的《数学家的眼光》一书，虽然它主要面向中学生，但其中证明的思路与看待问题的眼光都是相当犀利的。（如果诸位了解同类型的优质读物请务必向我推荐，毕竟我对数学只懂些皮毛而已）</p><h3 id="证明策略"><a href="#证明策略" class="headerlink" title="证明策略"></a>证明策略</h3><ol><li><p>直接法</p><p>1-1：对$\exists$可以分类遍历，对$\forall$则可以分类枚举；</p><p>1-2：正向或反向或正向反向一起用证明（正向曰由因导果或“综合法”，反向曰由果索因或“分析法”）。</p><p>1-3：对$\exists$可以采用构造的方式（典例：证明存在连续10个合数），对$\forall$可以采取找反例的方式；</p></li><li><p>间接法</p><p>如果直接法不好入手（如“无理数”是实数排除“有理数”而生的概念，本身的定义不好用），可以考虑间接法。</p><p>2-1：证明逆否命题。</p><p>2-2：反证法，假设结论不成立，推出矛盾之处。反证法的理论基础是$\lnot p \rightarrow (r \wedge \lnot r)$，其中r是任意矛盾的命题，在$\sqrt 2$的例子中，即“m，n互素”。</p><p>关于反证法有很多漂亮的例子，此处列出一些，以飨读者。</p><p>典例1（数论）：证明$\sqrt 2$为无理数。</p><p>典例2（数论）：证明素数有无穷多个。</p><p>典例3（组和）：证明抽屉原理。</p></li><li><p>归纳</p><p>包括但不限于数学归纳法及其变种（第二类数学归纳法，反向数学归纳法，后者可用于证明n元的基本不等式）。</p><p>归纳（induction）不只是种证明的方法，它更是一种思维方式，“告诸往而知来者”，从特殊到一般的思想。与之相对的是演绎（deduction），从一般到特殊的思想。我们前面所学的推理便是都是演绎的典范。</p></li><li><p>其他</p><p>Vacuous Proof与Trivial Proof，相当没意思：证明条件为假或结论为真，于是$p \rightarrow q$必为真。</p></li></ol><h3 id="证明类别"><a href="#证明类别" class="headerlink" title="证明类别"></a>证明类别</h3><p>证明可以正向也可以反向也可以结合二者，反向的一个例子是Bash Game。</p><h4 id="存在性证明"><a href="#存在性证明" class="headerlink" title="存在性证明"></a>存在性证明</h4><p>对于存在性证明，有构造性的也有非构造性的，非构造性证明往往是分析性质，或是使用数学归纳法，而不会给出求解的算法，如霍尔婚配定理的证明。</p><p>对于“存在可被两种方式写为两立方数和的正整数”，我们可以算出$1729 = 10^3 + 9^3 = 12^3 + 1^3$。顺带一提，1729被称为“拉马努金数”，是一个“有意思的数”。（读者不妨对“有意思的数”展开一些思考，比如想想是否存在最小的正的“没意思的数”）</p><p>非构造性证明的一个漂亮例子是“证明存在无理数x, y使得$x^y$是有理数”。</p><p>对于非构造性证明，书中还给出了博弈论中的Chomp game，也是经典的例子。</p><h4 id="穷举法"><a href="#穷举法" class="headerlink" title="穷举法"></a>穷举法</h4><p>穷举往往是针对有限元的，而且数目不能太多，否则人类做着会烦。但是面对无限元也可以穷举不怂，因为把握精度或许能够将我们所面对无限集转化为“要穷举的”有限集。</p><p>//例子</p><h4 id="唯一性"><a href="#唯一性" class="headerlink" title="唯一性"></a>唯一性</h4><p>平面几何中有很多关于唯一性的证明，要用到同一律，例子有Ceva定理等。</p><p>对于一些新引入的概念我们也常要证明唯一性，如矩阵的逆（若存在）是唯一的，乘法逆元（若存在）在模p的意义下是唯一的。</p><h4 id="等价定理"><a href="#等价定理" class="headerlink" title="等价定理"></a>等价定理</h4><p>涉及一组等价定理的证明，我们可以采取$p_1 \Rightarrow p_2, p_2 \Rightarrow p_3, … , p_n \Rightarrow p_1$这样的策略，减少多余的证明。例子么，以下。</p><p>1.$f(x_1, x_2, … , x_n) = X^T A X$为正定二次型。</p><p>2.$f(x_1, x_2, … , x_n) = X^T A X$正惯性指数为n。</p><p>3.存在可逆矩阵B使得$A = B^T B$。</p><p>4.A的顺序主子式均大于0。</p><h4 id="完备性"><a href="#完备性" class="headerlink" title="完备性"></a>完备性</h4><p>希尔伯特等的乐观主义使他们希望在公理之上构建出至臻至善的数学大厦。他在20年代提出了建立一组公理体系来保证数学“完备性”“独立性”“相容性”的期望。所谓完备性，指的是一切数学命题在原则上可判定真伪。然而哥德尔不完备性定理击碎了这一期望。比如古德斯坦定理，其在皮亚诺公理系统中是不可证的，但用超出这一公理系统的方法则可证明。</p><p>//这一段如出现知识性错误，请指出。</p><h4 id="开放问题"><a href="#开放问题" class="headerlink" title="开放问题"></a>开放问题</h4><p>费马大定理（已解决），3x+1猜想。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>证明是一个大有文章可做的话题，即便是前面讲到的看上去没啥好说的直接法，里头也包含了方方面面的子方法，它们考察的对象各不相同。如在组合中，染色法有很大的作用。在证明和式相等的时候，图形证明则将数学之美展现得淋漓尽致。（如果觉得三角形数正方形数太小儿科，不妨用图形证一证Abel恒等式）</p><p>另外，证明的时候骚话不能多说，像什么“显然”；有的话该说得说，如“不失一般性”。</p><p>上面提到用反证法证明“素数有无穷多个”。不过事实上，这一相对简单的定理能以很多种方法证明，卢昌海于<a href="https://www.changhai.org/articles/science/mathematics/IP.php" target="_blank" rel="noopener">这篇blog</a>中汇总了九种方法（虽说有的有些重复），私以为这一篇的水准相当不错（卢昌海关于数学的科普写得少，但个人感觉都非超好）。这里简单分享一下欣赏完后的感想：后面的大部分方法依据的都是算术基本定理，结合或组和或数论或其他的方法精妙地推出了矛盾。而利用数列的证明还有用欧拉函数的证明看起来与其他方法均不同，较为特殊。好的科普就应该是这样的：拓宽认识问题的角度，并给予读者意料之外的收获（如对$\pi (N)$的粗略估计，各个领域的联通，等等）。</p><h3 id="证明误区"><a href="#证明误区" class="headerlink" title="证明误区"></a>证明误区</h3><p>警惕错误的前提还有错误的推理！一般通过常识还有举例都能够判断结论是否为真，然后挑错就是了。网上时常有神仙一言不合就推倒数学大厦，大家不妨从中找找乐子，顺带锻炼锻炼自己的挑错能力，好使逻辑更严密。</p><p>错误的推理包括但不限于命题逻辑中的错误推理（请参阅《推理规则》第五条），“除以0”等等也应纳入考虑范围。</p><p>还有种证明误区便是循环论证——（隐蔽地）利用结论来推结论。这和前面的错误也相仿，只不过它用的是“未定”的前提而非错误的前提。</p><p>其实，我们所用的语言本身就是循环自指的——字典上为诠释一词的意思必须用其他的词语来描述，来类比。在这样的情况下，用语言来探究哲学的基本问题是否值得？哲学是否只是文字游戏？若不借助文字，我们又如何组织思维？通过内在的感知？这又是否“理性”，是否合乎“逻辑”呢？等等。我对这些问题没有解答的欲望，我只是选择了游世的态度，在空虚的精神王国中回避着一切问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图灵之路】管理的困境——记project-tetris开发的心路历程</title>
      <link href="/2019/06/16/Project-Tetris/"/>
      <url>/2019/06/16/Project-Tetris/</url>
      
        <content type="html"><![CDATA[<p>切身体验，何谓人月神话。同时享受，心态雪崩的感觉……</p><a id="more"></a><h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>整个过程中并非徒劳无功的，我收获了什么呢？友情，一些较软的能力，经验教训。只是在程序设计能力上的收获，简直是负的……或者说我原来的能力就是负的吧。这是个简单的项目，但我在管理上的失误，把简单搞得无比复杂。</p><p>C大程的大作业，有四个选题：学生信息管理系统、CAD、俄罗斯方块、自主选题。搞模拟题搞怕了，不想弄第一个；没深入搞过CAD，第二个也不成；对要玩什么没啥想法，自主选题估计选个题就能憋死。这样看来只有俄罗斯方块能搞了。虽然我不太喜欢玩俄罗斯方块，但也只能选这个啦。俄罗斯方块，有什么可以创新的地方呢……（谈到俄罗斯方块，谈到创新，总会想到《伊莉丝症候群(<em>irisu syndrome</em>)》，想到这个兔子和猫的故事……不过这里头的玩法是和剧情相关联的，和俄罗斯方块还有些差别，而且我对剧情根本没有想法呀）</p><p>先不管这些，直接动手做吧。</p><h1 id="进展"><a href="#进展" class="headerlink" title="进展"></a>进展</h1><p>这个项目的进展……非常迷。题目布置得特别早，故项目的工时很长。</p><p>一开始的两三周先是研究这个libgraphics。通过demo看看它是如何运作的，学习回调函数的用法，学习基本的绘图套路。这个时候的心态尚不是很好。因为这些东西跟环境也有关联。明明知道这个东西这么写是对的，可为何就运行不起来呢？总归是某个小地方出了问题，但就是不知是哪里的问题，就很烦。搞前端的时候也经常碰到这样的问题，trivial，麻烦。</p><p>知道了库该怎么用，接下来该是游戏的设计阶段了（我直接跳过了需求理解的部分）。我的想法是先搞下落、消行这些东西，再来搞tetris的类型，旋转啊那些。于是先把所有tetris简化为1*1的方块。下落便是改变中心点的位置，消行便是检测单行的block数。这些现在看来非常容易实现，但写的时候想法很多，一会感觉可以这么写，写着写着感觉那样会更好，就经常重构代码，一会儿换成这种风格，一会儿又是那种风格。重构一时爽，但重构完后就会发现自己啥也没干，就会开始怀疑自己。这是很不好的。探索固然有趣，但要有规划的探索，那应当更为有趣且有收获。</p><p>上面那些写好后，过了若干周，感觉可以开始设计tetris的结构了。怎么设计呢？考虑邻接矩阵吧。设个数组存邻接点的个数，再设两个数组存邻接点的坐标。好，那先弄个“田”出来吧，这一搞发现出了好多问题……比如在边界上的处理。等等。这些解决方案也是一点一点试出来的，主要是细节没搞清楚，我好像也没仔细记录。</p><p>后面的思路好像比较乱了？每次都不知道自己在搞什么，就东搞搞西搞搞，时间就搞过去了。这或许是需求理解和进度规划上的不明确导致的。</p><p>另外，整个项目没有一气呵成的感觉，往往是干个两三天，停个十几天，再来干两三天。然后中间把锅分出去之后就收不回来了，直到快交作业那星期进度才开始提上来。此时我的psycho-pass陡增。看着屏幕上的代码，时常会感到一阵，持久的，沉重的，虚无。</p><h1 id="个人层面的管理"><a href="#个人层面的管理" class="headerlink" title="个人层面的管理"></a>个人层面的管理</h1><p>首先是心态的管理。一方面是要有信念，对自己的信心，对别人的信心，对emergency的解决方案的信心。同时，需要有足够的管理能力提高对项目的把控能力以支撑信念。以下，是此次项目中没能表现出来的能力。</p><p>组织思路与组织代码。不需要很详细的文档，可以是函数调用关系图，可以是对一个功能在实现前的规划草稿，还有把类似功能的函数集中到一块。在开始想好方案不要改，或者事后再重构。封装常用功能。通过肉眼查重降低冗余度。保留档案。</p><p>文件管理。把不同类型的文件搞到不同的文件夹里面，保持树状结构。文件名规范化（”tetris-ln-190616-2117”），并维护更新信息。</p><p>预设测试情形，想好有哪些功能是需要测试的。每拿到一个新的不同版本的文件测试并做标记（“ranklist——符合预期”，“editbox——异常退出”）。</p><h1 id="ui设计中的管理"><a href="#ui设计中的管理" class="headerlink" title="ui设计中的管理"></a>ui设计中的管理</h1><p>（好吧这个标题和上面的标题下面的标题都不对应，不过这个东西有必要讲讲的）</p><p>ui的设计是所见即所得的，能够给予开发者一定的成就感，但也容易利用这成就感极大地耗散开发者的时间与精力，降低其效率。故ui的设计虽然好玩，但也不能仅仅抱着玩的心态看待，它也是需要分析的。</p><p>怎么分析呢？可以先明确一下一个小的阶段中要达成的效果：设计出ranklist的实现样式。这需要先搞出一个原型，提炼出需要使用的控件，确定好控件的颜色，确定好背景，等等。有了原型，设计的时候能更有针对性，而不是这搞搞那搞搞。</p><p>放置控件时我们也经常会想“欸这个放在这里是不是更好看”“欸这个拉长一点会怎么样”。这些常常会在占去大量的时间，但最终效果相差无几。修参的工作最好集中出一块时间来做，同时在这过程中要保证有效的调试手段，如键入位置信息、颜色信息等，而不能总是关闭-重运行。</p><h1 id="沟通与团队协作"><a href="#沟通与团队协作" class="headerlink" title="沟通与团队协作"></a>沟通与团队协作</h1><p>个人观察发现，三人小组往往会退化为两人小组或是一人小组，尤其在组员间相互不是很熟的情况瞎，因为团队的凝聚力不总是很高。作业做着做着有时候就感觉累了，宁愿自己做也不想把任务分出去，或是对这个项目不上心就把它鸽了。但在tetris这个项目中，团队的凝聚力还是较高的，个人认为原因在于组员间有一定的了解，能够相互理解与体谅，所以退化并没有发生。（如果我前几个星期不是特别忙也对tetris特别感兴趣的话，也许io、加密、ui还有其他部分我都揽过去了？这样项目的结束可能会早一些，但也只会像我高中时候的其他作品一样吧，其间我无法收获管理等其他方面的教训。然后我和她们也不会有更多的交集了，应该。）</p><p>一个团队是否总会发生马太效应？能者往往多劳，故强者愈强，弱者愈弱。“弱者愈弱”指的并非在能力上发生倒退，而是指的不受待见的沮丧，对自身能力的怀疑，这么一种心态。这在计算机学科的学习中是非常危险的，因为实际上，许多课程的。个人常秉持这样的观念：别人的东西看不懂，主要原因不是我太弱（这种话都是事后说的），而是对方写得不够清晰。变量名混乱，代码冗余度高，逻辑清奇（尤其这一点！）都是对方而非自身的过错。我已尽自身一部分所能梳理清楚其逻辑但仍对其总体架构抑或细节实现不甚明了，这反映了对方在对程序的运行逻辑的理解上也不够清晰（至少没有表现出来），故我当见不贤而内自省。</p><p>当然……问题也不尽是别人的问题，很多也是自己的问题。只会写hello world然后被lisp系的语法绕晕难道总是语言设计者的过错？在连最基本的图遍历算法都没写过的情况下看不懂人家的tarjan算法难道应该怪对方的代码不友好？这些问题，确实是自身能力不足所造成的，故我们在骂街之余当积极寻求解决方案。这个过程中尤其要注意解决方案面向的对象。在赛场上可以不加注释，但写题解时还应将各个细节点得清楚明白而不是把AC的代码往上一扔。要读懂这段代码需要什么样的前导知识，这些，我认为都是必要的，是将零散的知识点串成一环的有益疏理，也为对这一知识点尚不熟悉的同学提供了学习的方向。但遗憾的是，至少我很少看见这样的尝试，而与之相悖的做法（扔代码，玄学证明）倒是数见不鲜。</p><p>以上的情形更多发生在个人中，与团队中的情形略有不同。团队降低了沟通的成本（在网上发问，指不定有人会理你），但并没有降低沟通的难度（“你在说什么？”）。在这样的情况下，简单的沟通能够传递一些好的习惯，同时解决一些琐碎的问题；而更深入的沟通呢？至少还没想清楚……这或许还需要在长期的实践中思考才好得出一般性的方法论。</p><p>团队协作无可避免地涉及到交易成本——在软件工程中，集中表现为沟通的成本，理解代码的成本，等等。看自己的代码交易成本往往是比较低的，因为潜意识中对一些细节大脑已经做好了思考，整个程序的脉络也往往较为清晰。但是如果过了几个月，代码逻辑比较复杂还没什么注释，那么看自己的代码交易成本可能就上来了。至于看他人的代码，一般也都要付出高额的交易成本——时间、精力、信心。</p><p>那么如何提升交易的能力呢？我们注意到，项目的一部分的代码是整体性的，是许多点连成的面，很稠密，复杂度很高。虽然理解整个面或许较为困难，但是理解一些要点相对来说会简单一些。（CTF一般都是找关键点，在复杂的题目中）于是可以提取关键点，抓住主要矛盾，逐个击破，同时梳理好打持久战的意识，可能会有一些帮助。</p><h1 id="Leadership"><a href="#Leadership" class="headerlink" title="Leadership"></a>Leadership</h1><p>（我可能不具有这个东西，但理应具有这个东西）</p><p>一般而言，组长对项目的把控等级是最高的，ta决定项目宏观的方向，整体的架构。这些尚是个人层面的。在团队的层面，协调就麻烦了……</p><p>要分工，需要要了解他人的相性，了解其所面临的问题，了解其心理状态。这些都不容易做到。机器式的监督只会降低团队的凝聚力，但深入的了解也并不容易，这需要机遇，需要耐心，等等。</p><p>可能还是solo比较容易吧？</p><p>但把有着坚韧意志的厉害的女孩子一直置于对项目的焦虑与对自我的否定中，这实在不应该吧。</p><p>于是我只能随性地瞎指挥了。结果尚可，只是本来能更好。</p><hr><p>开始于2019-06-07</p><p>完稿于2019-06-16</p>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图灵之路】踏过的坑（2019-06-10更新）</title>
      <link href="/2019/06/10/Other-Programming_Pits/"/>
      <url>/2019/06/10/Other-Programming_Pits/</url>
      
        <content type="html"><![CDATA[<p>伤痕，与并不美好的记忆……</p><a id="more"></a><p>（不定期更新，一般心情好的时候会咕）</p><h1 id="2019-04-15"><a href="#2019-04-15" class="headerlink" title="2019-04-15"></a>2019-04-15</h1><p>Merge的函数题，没有保存变量就直接elem[i] = elem[j++]，导致数据丢失。从22：06：04到23：26：41，提交共十次。</p><h1 id="2019-04-16"><a href="#2019-04-16" class="headerlink" title="2019-04-16"></a>2019-04-16</h1><p>大数阶乘，压位做法。在j从0到len遍历的前提下把res[j] *= i和res[j+1] += res[j] / MOD混在一起写，这样的运算顺序是有误的。从1：36到1：52。</p><p>最近点对问题。将Points_x与Points_y混淆以致造成了难以发觉的错误。疯狂对拍但几无成效，在四个点的情况下还是直接调试更能发现问题。一开始在Merge中使用了n导致超时。从18：30到20：00再到22：00。</p><p>文件名的问题倒是一下就能发现。</p><h1 id="2019-04-17"><a href="#2019-04-17" class="headerlink" title="2019-04-17"></a>2019-04-17</h1><p>有序序列中位数问题，一直纠结于二分，没想到顺序一下就成。思路没打开。</p><h1 id="2019-05-06"><a href="#2019-05-06" class="headerlink" title="2019-05-06"></a>2019-05-06</h1><p>凸包旋转卡壳的算法中，用$&gt;$出现了问题，换成$\geq$则没事了。凸函数不一定严格单调啊。</p><p>调试时候把数组改小了记得做标记……不然看到RE很惭愧。</p><p>括号很多的时候记得检查，否则调试起来心情差。</p><h1 id="2019-05-10"><a href="#2019-05-10" class="headerlink" title="2019-05-10"></a>2019-05-10</h1><p>这一个标题下尽是，愚蠢的问题和糟心的状态……</p><p>5月8日期中考，旁边的人键盘敲得很响，想起了校赛时候的不适应，我的心境仿佛又回到了高中时代……偏执、疑虑、焦躁……今早的离散考试时状态亦复如是。</p><p>得冷静下来。这不仅是关于programming的问题了，它关系我的学习观，关系我对自己与他人的看法。Just admit it, scorn it, surplus it.</p><p>最后，“Cheers to the goddamn life, society, and everything.”</p><p>①他妈的”由裁判实现细节不表“！Sample都跑不起来的代码就交上去，这是计算机学院的学生做的事情吗？但不光是这一项，对dev的不熟悉，对于win7环境的不熟练还有内心世界的混乱都给解题的过程添了不少堵。一项一项的，都给我去死吧！</p><p>猪头临沂大学的漂亮代码是这样得：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span>  KeyType;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  KeyType *elem; <span class="comment">/*elem[0]一般作哨兵或缓冲区*/</span></span><br><span class="line">  <span class="keyword">int</span> Length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">CreatSqList</span><span class="params">(SqList *L)</span></span>;<span class="comment">/*待排序列建立，由裁判实现，细节不表*/</span></span><br></pre></td></tr></table></figure><p>那这个CreatSqList怎么实现呢？从Sample可以看出是要先读长度，然后一项一项读进来。因为参数是(SqList *L)，所以下面都要用-&gt;，直接L.Length就报错。但是实践之后发现只能读Length，读elem就会报错，为何？因为没有分配地址。所以这笔函数要这么写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">CreatSqList</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">L-&gt;elem = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span> *));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;L-&gt;Length);</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= L-&gt;Length;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;L-&gt;elem[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我一万年没有用malloc了，写这个函数的时候就慌得一批，之后想着要分配元素嘛，就写L-&gt;elem = 1000<em>(int </em>)…，但是这样是不行的。因为它elem啊，只是一个指针而已。</p><p>我不喜欢指针所以平时也不怎么用指针，自己写写代码基本不会有这方面的问题，但一到考试就凉透了！5月7日晚”复习“的指针完全没用。</p><p>这些几把考试不让查资料，所以把语法搞清楚很重要。血的教训！</p><p>②快排在5月7日晚上有“复习”，但是考试的时候还是一团乱麻。要理解快排，先要用例子建立直观的概念模型，从简单的例子到复杂的例子。简单的例子不包括重复项如“3 2 4 1 9 0 7”，还有不直观但容易调试的例子如“1 2”“2 1”等，乱七八糟的例子如“1 1 1”。理解之后是处理细节，考虑重复项他喵的该怎么搞，这样这样，基本就没问题了。</p><p>③有理数均值，特判！0/10这样的。要么在输出分母的时候加上去，要么把euclid写得更鲁棒一点，而不要少怀疑sscanf的有效性，虽然我之前的写法也很漂亮。</p><p>④整数分解，又是傻逼题一道……复习还是有一丁点用处的，因为当时也没有用心对待这题。本质就是个dfs，参数里设m——本次要分解的数，last——上次传下来的最大值，d——当前层数。对于;和\n搞个全局变量mark还有其函数专门处理。就这样，然后细节瞎搞。有的地方?:之类能让代码更简洁。</p><p>综上，关键词如下。<strong>高效复习</strong>、<strong>语法</strong>、<strong>模拟</strong>（从易到难、细节）、<strong>代码风格</strong>（优雅、鲁棒）、<strong>心态</strong>……</p><p>层层深入。</p><h1 id="2019-06-10"><a href="#2019-06-10" class="headerlink" title="2019-06-10"></a>2019-06-10</h1><p>今天补CF的状态……实在……一言难尽。题目是<a href="https://codeforces.com/contest/1176/problem/D" target="_blank" rel="noopener">这个</a>，看着很像密码题，它勾起了我关于ACTF的一些回忆……</p><p>一开始先是把题目看错了，不知怎地就把$p_{a_i}$理解成了$p_i$，导致处理$a_i$为质数和$a_i$为合数的方法产生了很大的分离，代码很冗长，而且写完后才发现有细节没想到，要处理非常麻烦。重新看题才发现是自己理解有误，只得把代码推倒重来。</p><p>之后是采用贪心的思路，分别用last_prime与last_composite维护$a_i$为质数/合数时$b_i$的index。但是在处理$a_i$为质数时，没有真正搞清楚变量的真实含义，以致屡出问题。在认识到所谓last_prime本质上是一个index后才对代码的正确性有了更深入的感受。</p><p>但这样还是碰到了一个很诡谲的error……本地测试没有问题，但是提交到服务器上便出错，此记录如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// origin</span></span><br><span class="line"><span class="keyword">while</span>(primes[nodes[last_prime].num] &gt; nodes[i].num)</span><br><span class="line">last_prime--;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polished</span></span><br><span class="line"><span class="keyword">while</span>(nodes[last_prime].num &gt;= <span class="number">200000</span>) <span class="comment">// caution</span></span><br><span class="line">last_prime--;</span><br><span class="line"><span class="keyword">while</span>(primes[nodes[last_prime].num] &gt; nodes[i].num)</span><br><span class="line">last_prime--;</span><br></pre></td></tr></table></figure><p>隐蔽的数组越界。以后在手工模拟是要尤为注意，越界与否，这样的问题。</p><p>在越界的问题上，还碰到了RE的问题。RE是因为题目中给定的n最大规模为2e5，但是输入的是2n，故而该规模需×2。在校赛时也碰到了类似的问题，还需要多加注意。</p><p>之后在跑一个点时出现错误。debug的思路为：判断output和answer中不一样的数，发现answer中一个位置为质数而output中对应的位置为合数。猜想nodes[last_composite].used = 0出现问题。调试发现last_composite对应的位置存在问题！last_prime确实可用贪心维护，但是last_composite并不能用贪心维护！于是手写了一个lower_bound，才得以通过此测试点。</p><p>然而这样还是碰到了TLE的问题。观察测试点发现它有相当多的重复数据。于是此时，lower_bound的复杂度会由二分退化为线性。需要添加记忆化的操作。至此，此题成功AC。</p><p>有何启示？明天再说……</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图灵之路】如何在CTF中考察算法能力——从ACTF中的rev和crypto谈起</title>
      <link href="/2019/05/28/CTF-Algorithm/"/>
      <url>/2019/05/28/CTF-Algorithm/</url>
      
        <content type="html"><![CDATA[<p>CTF，能和ICPC碰撞出什么样的火花呢？</p><a id="more"></a><h1 id="rev中的算法题"><a href="#rev中的算法题" class="headerlink" title="rev中的算法题"></a>rev中的算法题</h1><p><del>戳我获得题目链接</del></p><p>这次ACTF中，做到这么一个rev：</p><p><img src="/2019/05/28/CTF-Algorithm/question.jpg" alt></p><p>其中a1，a3都是已知的整数数组，a2是要求的整数数组。因为是字节的运算，涉及到的常数初看乱糟糟的，可能会把人看晕掉。我们把这段话用C语言（伪代码，有错请指出）重写一遍使之更清晰先：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> last;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> plain[], <span class="keyword">int</span> key[], <span class="keyword">int</span> cipher[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *ptr_plain = plain;</span><br><span class="line">    <span class="keyword">int</span> *ptr_cipher = cipher;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">37</span>;i++)<span class="comment">// 5476 / 148 = 37</span></span><br><span class="line">    &#123;</span><br><span class="line">        last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">37</span>;j++) <span class="comment">// 148 / 4 = 37</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = *(ptr_plain + j) * *(key + j);</span><br><span class="line">            <span class="keyword">int</span> ans = last + temp % <span class="number">79</span>;</span><br><span class="line">            ans %= <span class="number">79</span>;</span><br><span class="line">            last = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        *ptr_cipher = ans;</span><br><span class="line">        ++ptr_cipher;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这看着并不好搞，直接暴力搜索的复杂度显然不合理，逆推也不好推。想了好久，才想到要是把最后得到的ans的计算方式写出来，能得到一个线性同余方程。37个方程，37个未知数，这不便可以用高斯消元法解决么！于是，我想起了自己从没有写过高斯消元法的板子……</p><p>这道题本身并不难，但我们是否能从其身上得到进一步的启示呢？比如，如何从众多CTFer中筛选出ICPCer？</p><p>这好像是个<del>鬼畜</del>有趣的值得探讨的话题……</p><h1 id="模式异同"><a href="#模式异同" class="headerlink" title="模式异同"></a>模式异同</h1><p>在把这两个竞赛联系起来之前，我们有必要看一看它们间的模式。</p><p>ICPC：根据题目描述，设计出<strong>高效</strong>的算法，通过input计算得output。</p><p>CTF：根据题目的描述，通过<strong>可行</strong>的方法，获得flag。</p><p>在效率上，ICPC较为严格，留给程序的时间多以秒或毫秒为单位。考虑到数据的量级，一般而言O($n^3$)以上的算法都通不过。而CTF对于效率要求较低，更关注正确性。所以一般多项式级别的算法都可以。虽然CTF对效率没有过高的要求，但它也不会纵容无脑的暴力搜索。许多RSA的题目就是很好的例子。</p><p>无脑的暴力搜索的一种方案便是枚举答案，看它是否能够算出flag。在实际的情况中，flag中的各位间应当缺乏联系（迭代的关系也可以，还有什么关系呢？）。这样暴力枚举的复杂度便是组和量级的。故而参赛者只得找出加密/检验算法中的vulnerability，以快速而优雅地解出flag。</p><p>多数CTF题是没有input的，除了crypto（好吧，misc里给的图片算是input吗？）。为了向ICPC看起（虽然也有少量ICPC题目中无输入，这里头很多毒瘤题），我们一般可以在crypto题中加入算法的要素。也不只是crypto，rev、ppc都可以。从这个角度看，这三类题还是共性大于个性的。</p><p>于是，通过设置解密的模式，给参赛者cipher，（文章开头提到的那道rev的模式也是类似的：please enter the flag，然后检测输入的flag是否能通过检测），我们可以检验与赛者的代码阅读理解能力，对算法的理解能力，还有各方面杂七杂八的能力。</p><p>不过，也有另一种思路。</p><h1 id="关注复杂度"><a href="#关注复杂度" class="headerlink" title="关注复杂度"></a>关注复杂度</h1><p>说到复杂度，这次ACTF里还有另外一道rev，说是只要耐心等程序跑完就能拿到flag。用IDA一看，是个递归方程，没有记忆化，复杂度妥妥的O($k^n$)，等它跑完宇宙都凉了（好吧，是热寂，热得凉了）。怎么破呢？很简单，加个记忆化自己跑一遍就完了。</p><p>这个题目能够给我们一些复杂度上的启示：提示与赛者优化算法的复杂度。但是这个方向，私以为比较狭窄。把O($k^n$)和O($n!$)一类优化到多项式级别固然是一种思路，但是复杂度这样大得可怕的算法也不多，尤其是较为有名的。如要控制O($nlogn$)能通过而O($n^2$)不能通过，这也不好操作（除非是和服务器交互然后超时了它不给你flag，不过这样不就<strong>变成</strong>ICPC模式了吗……）。比如，我想这么出题：给定平面上n个点，求两个点间的最大距离。这个数取整再转为16进制再转为字符，就得到了flag。然后，控制n的规模，使得了解凸包的选手能在稍短的时间内跑完得到flag，而只会暴力的选手则在比赛时间内都跑不完。</p><p>理论上这个思路确实可行，但实操起来……假设一场比赛赛程十天，那么十天都跑不完的O($n^2$)中的n要多大？还能不能跑起来？如果能跑起来，还有没有其他的思路？比如用划分一下数据范围多台机子一起跑等等……总之这个方向看上去不是很漂亮，也不能很好地检验算法能力。而要真正检验算法能力，还是O($n^4$)，O($n^5$)更加适合，可问题在于我们也少有接触过这个复杂度量级的算法……</p><p>（以上是关于时间复杂度的，关于空间复杂度还莫得思考）</p><h1 id="解密模式"><a href="#解密模式" class="headerlink" title="解密模式"></a>解密模式</h1><p>上面讲到了解密的模式，我们再来更深入地看一看。</p><p>首先是阅读理解代码，阅读crypto中给出的代码，或是IDA反编译出的伪代码。这些代码的码风和我们自己写的不尽一致，故而阅读理解并不总是很轻松。阅读时，当在草稿上画出函数间的流程图，标记出重要的，还未完全理解的语句。将代码转化为等价的更容易为自己接受的形式。再来是保持清晰的头脑。这样就差不多了，能够对这段代码做了什么，效率如何，产生初步的理解。</p><p>然后是关注关键点了，比如以上的例子中，ida里头那一段代码。它反映了什么知识点？这是很难从代码反推出来的，除非我们已对这一知识点有了一定的认识。我们能做的，只是将代码转化为尽可能多的，等价的形式，从各个角度看能否解出更多的信息。这对于与赛者而言，无疑是充满挑战的。</p><p>而站在命题人的角度，我们能怎么调戏参赛者呢？</p><p>自行设计加密/检验算法想想也很伤脑筋，还是结合已有的算法更能体现CTF的精神。结合已有的算法的时候，不能像ICPC那样关注剪枝啊，数据结构之类，往模板题或是毒瘤题的方向靠拢或许更好。</p><p>比如，这次ACTF就考察了以下方向（这里只列了我会做的555）。<del>戳我获得题目链接。</del></p><p>1.异或的性质，利用它来构造密钥</p><p>2.LFRS（线性迭代加密）的vulnerability</p><p>3.块加密中，每块的加密方式为映射的迭代</p><p>4.其逆映射不是函数（每个象均只有一个原象）的映射</p><p>5.线性同余方程组</p><p>（如果看不了题，可以想想从这些方向出发，能怎么调戏参赛者）</p><p>除了这些方向，我们还可以在CTF中考察什么样的算法呢？</p><p>线性基（类似上面线性同余方程组的检验方法）？尼姆博弈（逐位检验）？欧拉函数？……</p><p>以上的方向还没有归类，或许需要进一步的探讨。</p><hr><p>开始于2019-05-28</p><p>完稿于2019-05-30</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 信息安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【围炉夜话】ACTF十日谈</title>
      <link href="/2019/05/21/Competition-ACTF/"/>
      <url>/2019/05/21/Competition-ACTF/</url>
      
        <content type="html"><![CDATA[<p>不开心。</p><a id="more"></a><h1 id="随想"><a href="#随想" class="headerlink" title="随想"></a>随想</h1><p>今年打的第二场比赛，远没有之前校赛中玩得开心，心态崩地可怕，心情很是不稳定，尤其在退赛（伪）后。也算是教训了，又一次地，无比清晰地感受到了自己的菜，无比清晰地感受到了他人的强，无比清晰地感受到了生活的满满恶意，各式各样各个方面的满满恶意。唉，并不可爱的，世界的另一面呀。</p><p>这次CTF打得很是孤独，作为hacker（伪），我要辗转地搜寻零散的信息，不能和人交流，不能说话。但我觉得，交流是非常必要的，能够使模糊的认识转化为清晰的表达，而且在找那种细密而恼人的bug上有奇效。比赛中我也会和没打的同学分享自己的感受，但并未感到孤独感有所散去，而是始终存在。这或许是CTF的专属特点吧。可能团队赛情况会好一些。</p><p>孤独还体现在无人理解上面。当时看群里就没几个熟悉的人，我跟很多人的关系都是单向边——我认识人家，但不了解人家，人家不一定认识我。包括但不限于MSC的那帮人，还有学长如Heltion、小栗酱、sub（结果他们全是来打酱油的……）。身边人的话，zc对具体的问题就没有表现出解答的兴趣，zwk也是。学长肯定是不能问的，只能“宏观地”讲讲自己的情况和心理状态（这些天跟学长的交流真是失败）。唯一的战友便是ljq了（哦，还有xndl，不过我们的交流实在是少……之后发现yyt也进群了，随便聊了一下，但也没怎么聊），这几天跟她聊得也多，比较开心，当然，也不总是开心……</p><h1 id="抱佛脚"><a href="#抱佛脚" class="headerlink" title="抱佛脚"></a>抱佛脚</h1><p>我开始了解到ACTF，是5月6号，而比赛是13号到23号，还有一周可以准备。本来想继续刷BugKu的，但进了群发现大家都在做School-Bus，也便入坑了。</p><p>School-Bus……对我来说好难的。印象里两三天都没能搞出一道题，很让人沮丧。搞出来方式也不够elegant。这些，都暗示了我在安全领域的瞎搞和无知的本质。</p><p>School-Bus上Web题占多，而我对Web相性不佳，也没从中得到什么提升。工具用得不顺，自学缺乏方向，对知识没有系统性的认识，这便是我了。</p><p>不光Web搞不来，ppc、rev，misc也都做得非常艰难。crypto基本没做。对较复杂的东西，如DES没什么认识，对简单的一些点也没有完全了解。</p><p>虽然School-Bus做得比较挫败，但还是从中得到了一些小经验包的，calculator啊，php include啊，在ACTF中也有用到。不过Web还有好多水题没搞出来，这就比较烦了……Web，得盘。</p><h1 id="中程赛事"><a href="#中程赛事" class="headerlink" title="中程赛事"></a>中程赛事</h1><p>ACTF持续的时间为10天，说长不长，说短不短，较之ICPC这样的五小时集中解题更能考验选手在处理好比赛与生活、心态等方面的素养，较之动辄数月的长期赛事则更加紧张刺激。我可能还不太适应这样的模式吧，被摆了一道呢：没有处理好比赛和生活的关系，心态在两个极点中极速变换，太过看重rank但又不具备与这个排名相匹配的能力，我还有得学啊。</p><p>本来的预想是先拼命做个两天，之后应该就没题做了，连着划水若干日，最后再苟苟，中间始终要维持好心态。很完美的预想，只是和现实完全不符。我拼命做了五六天，做得心神憔悴，神魂颠倒，身心俱疲。主办方也隔两天放一波新题，让人喘不过气来。最后实在做不动了，才作罢，可心中仍有千丝万缕的挂念，这就很揪心了。不甘落后于人，但又没有改变现状的能力，只能假装心无挂念地逃避着这一切，<strong>逃避着这沉重的绝望感，无力感，压迫感和由自身不断外溢的不满与控诉</strong>。</p><p>比赛期间心理状态真心是崩地可怕，晚上觉也睡不好，想七想八的。跟学长交流了一下，觉得把思绪整理一下为好。于是想了一下为什么睡不好，发现天太热了（不是），所以心不静，那么心还为什么不静呢？又可以整理出三个方向，列在下面了。</p><p>首先是处理好CTF和生活的关系，这个比较现实，就不贴上来了。因为要打比赛，作业也没写，课也没听，然后乱七八糟的琐事还很多，就感觉很烦——时不时想起来啊这个东西还没搞。所以就整理了一下，这下倒清晰多了，琐事也不是很多嘛。评估一下，感觉还是协调得来二者的。</p><p><img src="/2019/05/21/Competition-ACTF/mindmap1.jpg" alt></p><p><img src="/2019/05/21/Competition-ACTF/mindmap2.jpg" alt></p><h1 id="时光回放"><a href="#时光回放" class="headerlink" title="时光回放"></a>时光回放</h1><h2 id="启程"><a href="#启程" class="headerlink" title="启程"></a>启程</h2><p>紧张刺激的第一日，本以为是传奇的开始，谁料是噩梦的开端呢……</p><p><img src="/2019/05/21/Competition-ACTF/fake_success.jpg" alt="这都是虚的……"></p><p>（这个排名，虚的……保不了半天）</p><p>微积分做到一半开始打比赛……以为动态计分制是说越早做出来分越高（后来发现根本不是这回事……），于是从课程中间一直打到了十一点多……做了不少水题，意外地高兴了一阵子（$\leq 3h$）呢。</p><p>中午crypto的warmup1有了一丢丢思路，但还不是很清晰……先去跟学长约饭吧！这次交流不是很有效，我没能提出自己面临的具体的问题，而对于学长在大方向上的提问我也有些心不在焉。</p><p>下午一开始感觉自己还是可以的，大概是到视听说口语考试的时候吧，心态还比较正常。（马上就要消失的迷之自信）</p><p>但是下午微积分习题课的时候，就发现排名已经噌噌噌地掉下去了，痛心疾首之际，发现这已经无法挽回了……（这时候也才了解到动态计分制的真实含义……）习题课上后面的人唧唧歪歪的，“什么阿猫阿狗都在打CTF”。</p><p>晚上突然看到ljq的尬膜表情包，于是了解到人家也打CTF。有些惊喜，也有些紧张。</p><blockquote><p>“dl加油鸭”</p><p>“拿了prize记得bg”</p></blockquote><p>开心！（可，这也是个<strong>flag</strong>啊……）</p><h2 id="中程"><a href="#中程" class="headerlink" title="中程"></a>中程</h2><p>完全没印象后面的若干天是如何度过的。大致是这样吧？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(faith):</span><br><span class="line">    ideas = read(problem_index)</span><br><span class="line">    <span class="keyword">for</span> keywords <span class="keyword">in</span> ideas:</span><br><span class="line">        search(keywords)</span><br><span class="line">        <span class="keyword">if</span>(feeling_disgusting()):</span><br><span class="line">            sleep(some_time)</span><br><span class="line">        learn(keywords)</span><br><span class="line">        ask_myself(<span class="string">'where is the flag'</span>)</span><br></pre></td></tr></table></figure><p>看看提交记录（firefox的历史记录就懒得翻了……人类在搜索时的心理状态好奇妙），发现自己在第二天（14号）搞出来了warmup 3（啊，0：30的寝室之光），搞出来了baby_rev（这下能开搞一类题了，rev！）。另外在晚上搜出来了another php（序列化教我做人……）。</p><p>第三天（15号），开新题了，累啊！这天搞出来了file inclusion 2，what’s this 1，real child（哭！不是单射，错当单射），what’s this 2-3（又是11点半，还好刚好在睡觉的点搞出来了）。</p><p>第四天（16号），open your eyes，asm tour（累毙了），warmup 4（思路其实还是简单的，主要是被恐惧感支配了），查出来了file inclusion 1和baby php，搞出了Endless ELF（此题分虚高了，不过还是希望其他题分能虚高一点……）。</p><p>第五天（17号，今天是ljq的生日！），easy reverse，babyrev（高斯消元法码不对于是开始怀疑一切的痛苦，有谁，能领会呢）。</p><p>第六天（18号），shell master（累毙了！可我还是不知道linux的学习路线是怎样的，哭），md5 Hacker（看错变量名的尴尬，自行命题的愚昧）。</p><p>自从第一天掉到14+后，之后就没再爬上去过。时不时还被挤到20+名去，慌啊。艰难地，在rank 20的边缘徘徊，那些人都好可怕。打了六天，实在打不动了，faith=0了，心累了，尽量不挂念着这个吧……慢慢爬回原先的轨道上，从补作业开始……但是看到群里dl复出的消息时心中还是不免一震，感到，一阵，持续的失落。</p><p>（可能是生活对于我自视甚高的惩罚吧。退赛之后，原先清晰的目标模糊了。不知道自己想做什么，脑袋空空如也。这几天不是很想吃饭。）</p><p>信念确实是在做完了crypto和rev的水题后消失的。本来还想做做pwn，但在authtoken验证失败后突然，感到一阵无与伦比的疲惫。不想做了。什么aes，也不想看了。好累。虽然坚持做完了crypto和rev的水题，但我的信念还是不够啊。总是被trivial的事情困扰，我的问题真不小。</p><p>第八天自己出了题给妹子做，结果搞错了两个点，系数忘乘了，图像是反的。让人家算了一晚上都没得到正确结果。没睡好，第二天三点起来，意识到了自己哪里算错了。是算错了啊，是算错了啊。</p><h2 id="沉没"><a href="#沉没" class="headerlink" title="沉没"></a>沉没</h2><p>没怎么管，就……结束了？最后还要交wp，看见群里讨论地火热，可他们提到的那些词自己都不认识，突然感到一种距离感，以及疏离感。</p><p>wp零零碎碎地写了一天，写得真心累。尤其是crypto，做得吃力，得分又低。我都不知道自己怎么怎么想出那么混乱却正确的思路的，怎么用那些丑陋得可怕的代码把题目做出来的。看着并不漂亮的wp，又一次发现自己和强者存在的差距，在心理状态上的差距，在思维方式上的差距。</p><p>不过差距毕竟是客观存在的，老是盯着自己比不上别人的地方看也没意思。我就随便补补题，拓宽一下知识面好了。还是要过得开心呀~</p><p>看上去并无所学？并非如此，起码我暴露了很多问题。这些！都是要搞掉的！</p><p>①对metadata的敏感性；</p><p>②对图像的敏感性（可以自己再思维发散下，想想自己要怎样把数据藏到图像里）；</p><p>③联想，脑洞（加强交流，提取关键点，在概念间做连接，复杂度不就是$C_m^n$嘛）；</p><p>④阅读理解代码的能力（尤其是IDA里那些）；</p><p>⑤密！码！学！security book（还没拿到hhh）有空整理（啊，又是“有空再做”）。</p><p>web还是放放好了，打算是先和同学交流，了解一下要怎么入坑吧。</p><h1 id="补题时间"><a href="#补题时间" class="headerlink" title="补题时间"></a>补题时间</h1><p>这次比赛好像有80+道题呢……还没有官方的wp，显然不能像校赛那样把补题过程写到随笔里了。</p><p>所以就记一下大概要努力的方向吧~毕竟这是<del>快乐</del>鬼畜的CTF啊~</p><p>（以下，按优先级排序）</p><p>1.初探Linux（读一读关于操作系统的课本，对它有个概念先？）</p><p>2.asm的第一个程序，如何编译运行查看断点？</p><p>3.补misc的题，抄wp，戳脑洞</p><p>4.回顾rev的题，补其他题</p><p>5.想想warmup系列有无elegant的做法，如能，再将CTR熟悉一下</p><p>6.在其他地方（pwnable.kr）补点pwn，熟悉一下套路</p><p>7.了解一下Blockchain，及其他p2p方案</p><p>8.怎么用一台client和一台server模拟upload的效果呢？（嗯，首先我得有一台server……）</p><p>wp的话……我想可以参见<a href="https://www.xtxtmtxtx.xyz/articles/ACTF%202019/" target="_blank" rel="noopener">这里</a>，（呜呜呜我不知道自己都大一多少名了我好菜呜呜呜）</p><hr><p>开始于2019-05-21</p><p>完稿于2019-05-25</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 信息安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【围炉夜话】打开CTF之门</title>
      <link href="/2019/05/19/Toughts-CTF/"/>
      <url>/2019/05/19/Toughts-CTF/</url>
      
        <content type="html"><![CDATA[<p>Interested in information security yet not sure where to start?</p><a id="more"></a><h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>第一次听到“CTF”这个词是在大一上，忘了是在哪个群里。那场是科大办的，我不知哪根筋抽了想去玩玩看。可惜当时对此还完全不了解，不了解它的具体内容，不知道从何开始练习，于是便鸽掉了。但当时还是埋下了对CTF的一些<del>臆想</del>希冀的。</p><p>寒假里闲得没事，不知哪根筋又抽了又想到了CTF（想起来了，听英语听力听到writeup一词去搜然后……）。这回找到的网站比较友善，能让我成功拿下一血，wp在网上也很容易找。于是就每天一道或是两道地在上面<del>抄答案</del>做题目。由于我对Web的认识实在肤浅，寒假里真正让我入迷的是社工和加密。当时感觉像见到了老朋友一样，分外亲切。一个题目，一个知识点看似零散，但它们无不联系着更为宏大的，我所未曾了解过的知识块，犹如一箱箱秘宝，予我以莫大的喜悦之感。更重要的是，它们作为一个整体，折射出了一种hacker spirit，一种独到的、创造性的、艺术的看待世界的方式。这一切无不充满我以激情。</p><p>当时的日记中也写了一些自己对其的想法，有些话现在读来仍分外亲切，摘要并记录如下：</p><blockquote><p>这些东西怎么会这么有意思呢？完全让我陷进去了，简直是恋爱般的喜悦呐φ(゜▽゜*)♪（虽则我不懂何谓“恋爱般的喜悦”╯︿╰）（2019-03-17）</p><p>总之<strong>社工</strong>这个概念给了我很大的冲击，这是个和生活很贴近的话题，简直可以把日常生活过成推理小说啊！实在浪漫，实在有趣，不过我对此还应有进一步的认识，而且我还是一个社工库也没找到……哈尔滨的杜甫，死活搜不到唉……结果社工题被做成了密码题啊✿◡‿◡（2019-03-15）</p><p><strong>密码</strong>的话，除去zip伪加密（压缩我还不懂，winhex那界面我目前还适应不了，于是我也只会09改00这样了……）其实也就做了Ook还有Brainfuck两个题，这个时候我有些撑不住了……本来只是去搜一下Brainfuck是个什么算法的，不想这竟然是个编程语言？？？还™符合图灵完全思想？哈，哈，哈，有意思！不过看到处理个加法都这么麻烦还是有些心累啊。可，啥啥啥？M67还写过这东西的博客？？？还有更好玩的叫WhiteSpace的语言？Shakespeare？Chef？哈，哈，哈，今天都遇见了什么神仙玩意儿啊！晚上吃饭的时候还看了看乘法什么的实现，嗯……我也要写编译器！（2019-03-15）</p><p><strong>密码题</strong>……今天真心没状态，网上搜搜竟然连在线凯撒加密都没有，真伤脑筋，只能自己动手了…….水是水过去了，反正对这个不大有兴趣也找不到参考资料。base64那题是真的有意思：从base64，到八进制，到十六进制，到unicode，到十进制，再是unicode……因为不了解unicode的机制捣鼓了半天，这个可以深究一下。杰斐逊在百度上死活搜不到，狗日的百家号。后来只能对着writeup，傻子一样手工算，O(n)，再找规律。写了个辅助程序，tmd出了不知道什么鬼问题。想换用python，但苦于还不会用python处理字符串，鸽了吧鸽了吧。之后想了解一下那个富强民主是什么原理的，发现一帮人用这东西开车，想想也是挺好玩的✿◡‿◡说到底今天根本无所学啊(,,Ծ‸Ծ,,)（2019-03-19）</p></blockquote><p>不过，也有沮丧的时刻：</p><blockquote><p>今天搞网络的部分吧？post与get，php中的==与变名变量，还有又是看源码又是console，以及hosts……感觉自己学得完全不系统，这样下来自己能学到什么呢？略感失落便不再做了……（2019-03-22）</p></blockquote><p>这过程中有兴奋也有失落，但不论如何，从中都可以看出CTF是个有其价值的东西，是好玩的东西，是能把人深深揪住的让人先是沮丧而后豁然开朗并大感喜悦的该死的又真他妈有意思的东西。</p><p>但是在百度上搜“CTF”（Google的话就好多了，再次抱怨百度真是，太垃圾了），查到的多是让人摸不清头脑的题目，予人困惑的各式各样的工具，还有稀奇古怪的软件。这很容易劝退萌新，让他们对此感到恐惧，觉得自己啥也不会。我觉得这样不好，毕竟每个人都是从啥也不会走过来的。我认为，只要有一些基本的对于计算机（各个方面）的认识，一定信息处理能力，还有坚韧的意志，以及强大的学习与反思能力，等等，都能从CTF中找到乐趣。（只要你<strong>相信</strong>自己能获得这些能力，很大概率你都能获得它们，虽然不一定深入）</p><p>这里，我想记录的是自己的心路历程，给予喜欢信息安全但苦恼不知如何入门的同学一些启迪，如果真能有所启迪那便太好啦！</p><p>（后文，dl请忽视）</p><p>OK. Let’s jam.</p><h1 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h1><p>假设，你面前有一个TextBox，上面有一串字符，比方说，flag{Y0U_3nj0y_cTf}；右边有一个“submit” button。把flag粘贴进去，click on the button，然后它弹出个MessageBox：”correct! And you scored 30 pts”。OK. It’s easy, and it’s for babies.</p><p>这大致就是CTF的基本模式了，很简单，是不是？问题在于flag没这么好找。正因如此，这个比赛才叫“Capture The Flag”。作为与赛者，我们要找到隐藏着的flag，submit it。而作为组织者，其任务便是藏好这个flag，千方百计地藏好它，同时要给选手一线，也仅有一线的希望，以制造竞技性与趣味性。</p><p>如果你要藏flag，思维发散一下，你会怎么藏呢？既要把它藏得绝对巧妙，也要留出希望，有哪些方案呢？</p><p>你可以把它藏到写好的可执行文件里，让选手下载，反编译这个文件并通过阅读理解其中的代码而得到flag，这一类型的便是<strong>rev</strong>，逆向。</p><p>（rev给出的一般是exe文件、elf文件，如果是apk包，那这就是<strong>android</strong>题了——虽然两类题中心思想都一致）</p><p>你可以把它藏到网页中，藏到源码里，藏到备份文件里，藏到HTTP的header标头里——怎么藏都可以。或者你可以不藏，只要用户“无法”访问这个网页就可以了，比如，给人家个403错误，302重定向一下……都可以。这一类关于网络安全的统称<strong>web</strong>题，它有很多小的分支，此处便不细讲了。需要说明的是web的很多套路都是依据历史上的漏洞改编出来的。能够走先代hacker走过的路，这怎能不叫人眼前一亮呢？</p><p>如果你觉得藏东西太没意思，不妨干脆些，直接给出flag——的变体。比如要交的flag是flag{Y0U_3nj0y_cTf}，你可以给我ZmxhZyU3QlkwVV8zbmoweV9jVGYlN0Q=。当然，it’s still for babies。也可以给我个9f19c7ac384e737be7d5015461fd988f，但这样就太没意思了，只能反映出你水平不太够，还比较恶意。这类关于加密的便是<strong>crypto</strong>题，可分为古典与现代两种。（有的赛事会把古典密码学给放到misc里面）</p><p>我还可以脑洞大开，放flag到破损的二维码中，“残缺”的图片中，“奇怪”的压缩包里。等等，这些就很杂了，所以称<strong>misc</strong>，杂项。</p><p>以上是一些基本的题型，还有一些其他的分类方法，比如从web里拎出<strong>代码审计</strong>作为一类，还有<strong>pwn</strong>，等等。如果是萌新（比如我）的话还是先了解简单的情形，形成个大概的印象为妙。而不要过度纠结对于题型的划分及一些稍难入门的题型。</p><h1 id="一次友好的对话"><a href="#一次友好的对话" class="headerlink" title="一次友好的对话"></a>一次友好的对话</h1><p>我们拿道水题来进入CTF的奇妙世界吧！网上针对水题的博客一般短得可怕，只有解答，没有思索，私以为这样意义不大。我觉得人的思路是值得记录的，无论是深入的沉思，还是无谓的纠结。</p><p>比方说，上面的ZmxhZyU3QlkwVV8zbmoweV9jVGYlN0Q=，我说it’s for babies，这话相信绝大多数CTFer都会赞同，但是如果你没碰过CTF也不了解□□□□□□，你可能会一脸懵逼“wok这啥啊我怎么啥也看不懂好难啊”。别着急，下面是面向萌新的友好讲解~</p><p>分析上面的“密文”，它有什么结构呢？大小写都有，还有数字，最后是一个等号。如果你对编码这个词有概念的话，你便可以search for “等号 编码”（注意不要搜”= 编码”），然后你会发现“base64” “utf-8”之类的字样。这些都是啥？搜就是了。搜base64，你看到了“在线解密”的网站，抱着试一试的心态，你成功拿到了flag……</p><p>要是你没有关注到这个等号的话，也没事。search for “大写 编码””大小写 编码”，一个个试过去，这个过程可能让你很烦躁，因为你可能没找到有效的信息。没事，search for “CTF 编码”。都可以呀。</p><p>如果你对“编码”一词没概念，那也没事。search for “CTF”呗，看看它有哪些题型，看看人家的wp都有啥套路，没准你还会找到CTF wiki这样的网站……总之应该会对“编码”有概念的，应该。</p><p>再不成，直接把这串东西拿去搜也行，即便出不来结果，这也是一种尝试。</p><p>从上面的例子不难看出，CTF解题的途径是多样化的。就说搜索，也有很多的搜索方案，为什么搜这个可以而搜那个不行，这些，私以为都是需要记录的。而在工具上的选择就更多了，手写脚本、现有工具……达到目标的途径虽然大体思想上一致，但在细节上是有所差异的。player不应只停留在“解题”的层面，而当想想什么样的做法是elegant的（尤其在脚本的编写上），这样或许更能有所提升。</p><p>至此你搞出了这道题，但是你可能对于base64还是一脸懵逼：这鬼东西是怎么运作的？于是你search for “base64”，然而搜到了很多重复的内容。要想深入了解这东西，得到“专业”一点的地方，所以要search for “博客园 base64”“简书 base64”<del>“CSDN base64”</del>。（虽然重复的东西还是很多，人云亦云和抄袭的现象仍然很严重，唉国内的互联网环境啊！）走马观花一阵子后，你大致了解了一下这个东西的原理，提出的背景，复杂度，等等。你可以从这个概念扩展出去，了解base64，base32，base16的异同；了解其他简单的编码方案；了解python中encode()的用法，以便今后的解码……有很多方向可供延伸。</p><p>以上，都是从一题延伸出很多方向的例子，也是“以赛促学”的例子。CTF能够让你了解一些有趣的好玩的此前可能未曾了解的东西，为你打开新世界的大门，让你有事可做，有东西可学。</p><p>打CTF的流程大致便是这样的：看题-&gt;不懂-&gt;自学-&gt;大概懂-&gt;下一题。然后是赛后总结。安全的水很深，涉及的概念多的去了，于是选手也得拼命学，既耗脑力，也费体力。CTFer在赛后脑袋里可能会新增加一箩筐奇奇怪怪的知识，有点像，博物学家？这个词是从卢昌海的博客上找到的，私以为这个比喻实属绝妙。虽然他讲的是软件领域，但是在CTF上这段话也是很适用的，尤其是在接触到了CTF的七七八八的工具之后……</p><blockquote><p>越来越觉得， 某些领域的软件工程师越来越像博物学家。 二十多年前， Java 刚问世， 是学校计算机课的宠儿， 那时的 Java 编程， 每个 class， 每个 method 等等都要设计， 确实有工程师的感觉 (当然， 在 C 程序员看来， 那可能已经是博物学家了)。 然而很多年后再看 Java 编程， 重心变成了从数以百计的 framework 里挑选有用的， 明了其用法， 搞定各种 package 的依赖关系 (当然， 有 Ant、 Maven 等等帮你做这事， 你也得知道那些)， 知道各种 annotation 的用法， 等等。 class 和 method 则大都限定到了跟做填充题差不多的程度。 简直可以这么说， 某些领域的软件工程师依赖记忆越来越多过技术， 若不是对现成软件有博物学家般的知识， 几乎寸步难行。</p></blockquote><h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><p>信息搜集在CTF中占据相当重要的地位。找到flag便是一种信息搜集，不过这是最终目标。要找到flag，先得了解相关的知识点，而这又要通过信息的搜集。注意在这里，搜集不等于收集。</p><p>前面稍稍提了一点搜索在CTF中的应用，可事实上，“搜索”这件事本身还很值得深挖。比如，信息的来源如何？在一个网页中，我又如何筛选出自己需要的信息？针对前一个问题，我们便不能再是总是简单地在百度，综合性的搜索引擎上搜索这一问题，而是倾向于在有着有效信息的网站中搜索，如wikipedia，stack overflow……</p><p>百度也不是完全不能用的，虽然它越来越恶心了，百家号也是真的蠢，百度百科也越来越不行。简单地search for “百家号 屏蔽”诸如此类的东西，都可以找出净化百度的方法，然后你还可以了解一下，使用搜索引擎有什么其他技巧。</p><p>搜索什么东西也是要考虑的，这应当依据我们现有的疑问来。我困惑于不知这种编码叫什么，所以依据结果的特点去搜索：“等号 编码”；我只想先苟出题目，所以依据需求去搜索：“CTF 编码”，等等。还有，有时候一段很长的文本掺了一些干扰搜索结果的废话，那么这段“废话”得删去。如此的技巧和思路还有很多，这是一个非常零散而大有可谈之处的话题，有空再聊。</p><p>搜索也不仅限于搜索引擎中的“search”，在文本中找到有效的信息也是重要的本领。首先，是要了解什么信息是自己需要的，比如文件的文件头，比如ida中这个地址上的变量，比如暴露在文件中的光秃秃的flag。然后便是search for it了，F3。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>首先CTF是有些解谜的意味的……尤其是misc。关于解谜我在其他地方谈过一点。这里简单谈谈好了，主要是<strong>缺乏反馈</strong>——你完全不得而知这样做是否正确，是不是达到flag的其中一步，抑或是一条弯路。具体该走什么样的路，当前走的路是否正途，不会有hint告诉你。（但可以推断出来）在很多情况下，所需要的是脑洞，奇想，灵感。这正是解谜的一大<del>原罪</del>乐趣。灵感并非死盯着题目能“格物致知”出来的，所以还是要快乐CTF呀。</p><p>还有是要了解各式各样的知识，对某个事物是如何运作的形成基本的概念模型——不需要很精确，把握好要点就行了。某个领域可能有前人深挖过了，写成文章，得看；某个领域可能有前人深挖过了，做出轮子，得会用。等等等等。无需过度了解背后的原理，大概的了解就够了，但这也并不轻松，需要“特定”的自学能力。（博物学家没这么好当，何况是信息时代的博物学家呢）</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>看完这些，你就可以去做<del>水</del>题啦！</p><p>上面的篇章对于解具体的题型可能并无帮助，但它们对CTF的基本模式还有一些全局性的要点给予了直观而较为亲切的介绍。面向的对象是想入坑但心中仍有一丝畏缩的同学，比如之前的我自己。</p><p>Stay positive, just enjoy it.</p><hr><p>开始于2019-05-19</p><p>完稿于2019-05-24</p>]]></content>
      
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
            <tag> 随想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学之美】微积分下-苏德矿版：第十一章 级数</title>
      <link href="/2019/04/27/Calculus_Vol2-CH11/"/>
      <url>/2019/04/27/Calculus_Vol2-CH11/</url>
      
        <content type="html"><![CDATA[<p>级数，是用于<strong>表达函数</strong>的<strong>数值计算</strong>的工具。（<del>我口胡的</del>）</p><p>我们要学的级数与数列息息相关，可以说是后者的加强版本。两者从敛散性开始便有了亲密的联系。</p><a id="more"></a><h1 id="级数的概念"><a href="#级数的概念" class="headerlink" title="级数的概念"></a>级数的概念</h1><p>级数，是用于<strong>表达函数</strong>的<strong>数值计算</strong>的工具。（<del>我口胡的</del>）</p><p>我们要学的级数与数列息息相关，可以说是后者的加强版本。两者从敛散性开始便有了亲密的联系。</p><h2 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h2><p>1.n阶Koch雪花的边长与面积。</p><p>这个例子中重要的是分析n阶与n-1阶的递推关系。而分析时则应牢牢抓住一条单独的边。</p><p>结论如下：$C_n=\dfrac{4}{3}C_{n-1}$（每条长为3的边均分裂成了4条长为1的边）</p><p>$S_n=S_{n-1}+\dfrac{3 \cdot 4^{n-2}}{9^{n-1}}S_1$（S1的系数中3表示分裂出三个子图形，4表示边的数目，9表示面积的缩减程度）</p><h2 id="敛散性"><a href="#敛散性" class="headerlink" title="敛散性"></a>敛散性</h2><p>回忆数列的敛散性，我们掌握了夹逼定理、单调有界、取子列、柯西准则等方法。而在这一章中我们会学习更多的方法。</p><p>1.几何级数的敛散性（分四类讨论即可）</p><p>2.调和级数的敛散性</p><p>方法有积分判别法、柯西准则或其变形，还有放缩。</p><p>3.p级数的敛散性</p><p>可用积分判别法或放缩判断。</p><h2 id="计算性质"><a href="#计算性质" class="headerlink" title="计算性质"></a>计算性质</h2><p>1.线性运算法则</p><p>2.级数可改变（增/减/变）其有限项而保持敛散性不变</p><p>3.结合性</p><p>//对于结合性，我还没有理解一些细节</p><p>4.$\sum\limits_{n=1}^{\infty}u_n$收敛，则$\lim\limits_{n \to \infty}u_n=0$。</p><p>4的推论即其逆否定理：$\lim\limits_{n \to \infty}u_n\not=0$或者不存在，则$\sum\limits_{n=1}^{\infty}u_n$必发散。（逆命题的反例：调和数列）</p><p>5.级数收敛的柯西准则//什么时候用呢？</p><h1 id="正项级数敛散性的判定"><a href="#正项级数敛散性的判定" class="headerlink" title="正项级数敛散性的判定"></a>正项级数敛散性的判定</h1><p>负项级数可向正项级数转化，正如负定二次型可向正定二次型转化一样。故此处我们只研究正项级数。</p><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><p>找上界是一种方法。（化归到单调有界定理）</p><p>还可以通过计算$\lim\limits_{n \to \infty}u_n$来判断。</p><p>柯西准则。</p><h2 id="方法2：比较判别法"><a href="#方法2：比较判别法" class="headerlink" title="方法2：比较判别法"></a>方法2：比较判别法</h2><p>比较判别法常用于有三角函数的情况，如sin x, cos x可以替换为x。</p><p>比较判别法有两处可减弱的条件（忽略前有限项，常数），它们强调了问题的主要部分，使原本可能需要的特判不再需要，因而小幅降低了问题的复杂程度。</p><p>例题1：求证$\sum(1-cos\dfrac{a}{n})$收敛。</p><p>例题2：已知$\sum a^2$收敛，求证$\sum \dfrac{|a_n|}{\sqrt{n^2+\lambda}}$收敛。</p><p>例题3：$a_n &lt; b_n &lt; c_n, \sum a_n,\sum c_n$均收敛，求证$\sum b_n$收敛。</p><p>例题4：设$a_n = \int_{0}^{\pi/4}tan^nxdx$，求证$\sum \dfrac{a_n}{n}$收敛。</p><p>较比较判别法更容易使用的是它的极限形式。</p><p>例题5：求证$\sum(\sqrt{n+1}-\sqrt{n})^p ln\dfrac{n+1}{n-1}$收敛。</p><p>例题6：求$\sum [e - (1+ \dfrac{1}{n})^n]^p$的敛散性。</p><h2 id="方法3：达朗贝尔判别法"><a href="#方法3：达朗贝尔判别法" class="headerlink" title="方法3：达朗贝尔判别法"></a>方法3：达朗贝尔判别法</h2><p>达朗贝尔判别法与柯西判别法的作用实际在于将原级数放为几何级数，但在lim = 1时会不起作用，因为存在“波动”的可能性。</p><p>这两项判别式的条件充分而不必要，因极限不存在的级数也可能收敛，如$\sum \dfrac{2+(-1)^n}{2^n}$。</p><p>例题1：求证$\sum \dfrac{ncos^2 n\pi}{2^n}$收敛。</p><p>例题2：判断$\sum \dfrac{n! a^n}{n^n}$的敛散性。</p><p>在例题2中，对于a=e的情况，最后还要结合基本方法，这是道较为灵活的题目。</p><p>例题3：判断$\sum \sqrt[n]{a} - \sqrt{1+\dfrac{1}{n}} $的敛散性。</p><p>答案：$lna = 1/2$时收敛，否则发散。</p><h2 id="方法4：柯西判别法"><a href="#方法4：柯西判别法" class="headerlink" title="方法4：柯西判别法"></a>方法4：柯西判别法</h2><h2 id="方法5：积分判别法"><a href="#方法5：积分判别法" class="headerlink" title="方法5：积分判别法"></a>方法5：积分判别法</h2><p>例题1：判断p级数的敛散性。</p><p>例题2：判断$\sum \dfrac{1}{n(lnn)^p}$的敛散性。</p><p>答案：p&gt;1时收敛，否则发散。</p><p>例题2的变式还有$\sum \dfrac{1}{ln(n!)}, \sum \dfrac{lnn}{n}, \sum \dfrac{sin\dfrac{1}{n}}{lnn}$等，它们都可以转换到上式。</p><p>例题3：求证$\sum \int_n^{n+1}e^{-\sqrt{x}}dx$收敛。</p><p>例题4：求证$\sum \int_0^{1/n} \dfrac{\sqrt x}{1 + x^2} dx$收敛。</p><h1 id="幂级数"><a href="#幂级数" class="headerlink" title="幂级数"></a>幂级数</h1><h2 id="收敛半径"><a href="#收敛半径" class="headerlink" title="收敛半径"></a>收敛半径</h2><p>Abel定理：若$\sum a_n x^n$在$x=x_0$处收敛，则它在满足不等式$x &lt; x_0$的一切x处绝对收敛；若$\sum a_n x^n$在$x=x_0处发散$，则他在满足不等式$x &gt; x_0$的一切x处发散。</p><p>至于证明，将$a_n x^n$转化成为$a_n {x_0} ^n \dfrac{x^n}{ {x_0} ^n}$即可。</p><p>由Abel定理我们可知幂级数的收敛域是关于原点左右对称的，故可引入收敛半径和收敛区间的概念。它们相对收敛域是较弱的概念。</p><p>Cauchy-Hadamard公式与其根式形态。</p><p>注意：若幂级数为缺项级数，不可直接由Cauchy-Hadamard公式求，需应用定义法求。</p><p>//Cauchy-Hadamard公式无极限时候的意义？</p><h2 id="和函数"><a href="#和函数" class="headerlink" title="和函数"></a>和函数</h2><p>简单的变式：对涉及$\dfrac{1}{x^n}$或$x^{2n-1}$这些项的“伪“幂级数，换元即可。</p><p>幂级数的和函数满足连续、可微、可积这样的分析性质，并且微分/积分后收敛半径不变。</p><p>值得注意的是，虽然收敛半径不变，但收敛域是可能发生改变的。$f(x) = \sum \dfrac{x^n}{n^2}$和他的导数及二阶导数在收敛域上的差异就是一个很好的例子。</p><p>唯一性定理：S(x)为幂级数在x=0某邻域的和函数，则其各项系数满足$a_n = \dfrac{S^{(n)}(0)}{n!}$这一关系，这使得幂级数由其和函数的导数唯一地确定下来。</p><p>对幂级数除法的直观感受：$\sum a_n x^n = 1, \sum b_n x^n = 1 - x$，其商收敛半径远小于原式收敛半径。（$R &lt; min(R_a, R_b)$？）</p><p>通过求幂级数的和函数，我们得以从一般到特殊，求出一些幂级数的取值，如$\sum \dfrac{(-1)^n}{n} = ln 2$。</p><p>例题：求$\sum \dfrac{x^n}{2n + 1}$的和函数。</p><p>//幂级数的加减乘除结果的收敛半径满足什么条件？</p><p>//和函数在收敛半径之外为何仍有取值？</p><p>//在算和函数时可能会算错，有什么好用的检错算法呢？（代入边界值貌似行不通？）</p><h1 id="函数展幂级数"><a href="#函数展幂级数" class="headerlink" title="函数展幂级数"></a>函数展幂级数</h1><h2 id="展开"><a href="#展开" class="headerlink" title="展开"></a>展开</h2><p>相较于微积分I中直接的求导，在这里泰勒级数的面貌显然要复杂得多了——要确认收敛半径，还有有$lim R_n (x) = 0$的先决条件（不然，有反例$f(x) = x ? e^{- \frac{1}{x^2}} : 0$）</p><p>习题：求$2x - \dfrac{4}{3!}x^3 + \dfrac{6}{5!}x^5 + …$的收敛域与和函数。</p><p>求基本的五种级数的麦克劳林展开：$e^x, sin x, cos x, ln(1 + x), (1 + x)^a$。</p><p>其中$cos x$可以化归到$sin x$，而$ln(1 + x)$用积分的方法会更加好算。这些是基本的方法，也是在后面的求解中会渗透进去的。至于$(1 + x)^a$，猜出结果再反推回去也未尝不是一种方法。</p><p>$(1 + x)^a$本身在端点处的收敛性与a的取值有关：$a \leq -1$两边开，$a &gt; 0$两边闭，否则左开右闭。另外，这个展开本名是“牛顿二项式展开”。</p><p>有了基本的五种函数的展开还是远远不够的，不过有了它们我们就能推出更多的级数展开了。请先展开$\dfrac{1}{1 + x^2}, arctan x$。</p><p>接着，再展开$\dfrac{1}{\sqrt{1 + x}}, \dfrac{1}{\sqrt{1 - x^2}}, arcsin x$。</p><p>一些多项式的函数也可以展开了：如$\dfrac{x}{1 + x - 2x^2}$。//$\dfrac{1}{x^2 + x + 1}$则如何呢？</p><p>一些复杂的函数，因为可以写成简单函数的组和，也是可展开的。如$\dfrac{1}{4} ln \dfrac{1 + x}{1 - x} + \dfrac{1}{2}arctan x - x$。不过，先求导再求积可能更为方便。</p><p>变式：非标准情况下的幂级数展开，如展成关于$(x - 3), ln \dfrac{x - 1}{x + 1}$的幂级数之类。</p><p>//级数展开的端点值问题？</p><p>//$sin^3 x$如何展开幂级数？这个问题本身是否值得研究？</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>1.计算积分的近似，如$\int \dfrac{sin x}{x}$//$\int \dfrac{x}{sin x}$则如何呢？</p><p>2.计算高阶导数，如$f(x) = e^{x^2}$，求$f^{(n)}(0)$。</p><p>3.导出欧拉公式，联通实数域与复数域。</p><p>4.数值计算，如计算$sin1°$。</p><h1 id="傅里叶级数"><a href="#傅里叶级数" class="headerlink" title="傅里叶级数"></a>傅里叶级数</h1><p>三角解函数的正交性为傅里叶级数的求解各项系数提供了依据，也提供了具体的算法，但是它虽容易接受，却并不容易计算。$a_0$与$a_n$还需要分开讨论，因为$cos 0x$不能积分成$sin 0x$。</p><p>周期函数是否能够展开需要用到迪利克雷定理，条件十分的特殊，相较级数展开也比较弱，但书中并未给出证明。</p><p>计算傅里叶级数的时候要关注函数的奇偶性，因为这样也许可以大大简化计算步骤。</p><p>例题：计算巴塞尔级数的值。</p><p>（假设我们还不会算）首先我们来分析一下，这一节在讲傅里叶级数，所以应该把一个函数展开成傅里叶级数然后再算。为方便起见，算f(0)好了，这样$f(0) = a_0 / 2 + \sum a_n$。我们希望$\sum a_n = \sum \dfrac{1}{n^2}$或是与之结构相似。</p><p>展什么函数好呢？先从简单的情况开始分析吧。试试$f(x) = x(-\pi &lt; x &lt; \pi)$，展开得$f(x) = 2 \sum \frac{(-1)^{n+1}}{n} sin nx$，嗯，根据$b_n^2$的形式可以用一用帕塞瓦尔等式，至此题目就做完啦。</p><p>（不会帕塞瓦尔等式也不要紧）展开$f(x) = x$的过程中我们看到$\int x sinnx dx$在分部积分时会生成系数的$\dfrac{1}{n}$，$\int x^2 cosnx dx$或许就能给出我们梦寐以求的$a_n = \dfrac{1}{n^2}$。那么试试$f(x) = x^2 (-\pi &lt; x &lt; \pi)$，（虽然复杂度已经有些高了hhh）能不能得到$\sum a_n = \sum \dfrac{1}{n^2}$呢？嗯，$a_n = (-1)^n \dfrac{4}{n^2}$，形式相仿！然后瞎搞一通也就做好了……（这样的分析有点马后炮2333）</p><p>如果原函数是在[a, b]而非[-l, l]上呈周期性，比方说，$x - [x]$，并不用有什么特殊的考虑！因为它在[-l, l]也是呈周期性的，$\int_a^b f(x) = \int_{-l}^l f(x)$。所以只要将积分区间换一换即可，答案不会有任何影响。</p><p>如果原函数不是周期函数，我们也可以截取我们想要的部分把它周期化。</p><p>//傅里叶展开的价值</p><p>//已知傅里叶级数求原函数？（或验证结果？）</p><h2 id="帕塞瓦尔等式"><a href="#帕塞瓦尔等式" class="headerlink" title="帕塞瓦尔等式"></a>帕塞瓦尔等式</h2><p>我们可以用它来巩固我们对于级数乘法还有（三角正交）的概念。证明的话也有两种思路，一种是直接拆开，一种是只拆一个f(x)。虽然后者在思想上与前者等价，但它在形式上要简洁得多。</p><p>例题：f(x)可被傅里叶展开，求卷积函数$F(x) = \int_{- \pi}^\pi f(t) \cdot f(t+x) dx$的傅里叶级数。（key：$A_0 = a_0^2 / 2, A_n = a_n^2 + b_n^2, B_n = 0$）</p><h1 id="综合题"><a href="#综合题" class="headerlink" title="综合题"></a>综合题</h1><p>例题1：求级数$\sum \dfrac{(n+1)^2}{n!}$的和。（$key: 5e$）</p><p>例题3：设$0 &lt; P_1 &lt; P_2 &lt; … $，试证$\sum \dfrac{1}{P_n}$收敛$\Rightarrow$$\sum \dfrac{n}{P_1 + P_2 + … + P_n}$收敛。</p><p>例题4：设正项级数$\{ a_n \}$单调增加有上界，证明级数$\sum (1- \dfrac{a_n}{a_{n+1}})$收敛。</p><p>书上未整理的题：2、5、7、13、14</p><p><strong>借级数包装微分中值定理的题</strong></p><p>例题4：设f(x)在x=0的某一邻域内具有二阶连续导数，且$\lim\limits_{x \to 0} \dfrac{f(x)}{x}=0$，证明级数$\sum f(\dfrac{1}{n})$收敛。</p><p>例题5：设偶函数f(x)在x=0处存在二阶导数，且$f(0)=1$，证明级数$\sum [f(\dfrac{1}{n})-1]$收敛。</p><p>//过程待补充</p>]]></content>
      
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 数学_分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学之美】微积分下-苏德矿版：第一章 矢量代数与空间解析几何</title>
      <link href="/2019/04/27/Calculus_Vol2-CH01/"/>
      <url>/2019/04/27/Calculus_Vol2-CH01/</url>
      
        <content type="html"><![CDATA[<p>用代数的方法研究几何问题，在三维的坐标系中。</p><a id="more"></a><h1 id="概要及注意"><a href="#概要及注意" class="headerlink" title="概要及注意"></a>概要及注意</h1><p>注意：在讨论解析几何的时候很多情况下要做特判，特判重合、等于零，等等。但出于懒惰与大意还有其他原因，并非每一处需要特判的地方我都有指出，请读者自行注意特殊情况。</p><h1 id="矢量"><a href="#矢量" class="headerlink" title="矢量"></a>矢量</h1><p>要素：大小与方向。矢量起点不固定，故称自由矢量。这为证明提供了一些方便。</p><p>模与零矢量，零矢量的方向，平行的非传递性。</p><p>矢量加法的平行四边形法则，加法交换律与结合律，减法。</p><p>线性组合与分解，线性相关与共面的一致性，尤其是二维与三维情况下。</p><p>用矢量证明三角形三垂线交于一点</p><h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><p>右手系，卦限。</p><p>单位矢量用以表示方向，基</p><p>投影，方向角与方向余弦。</p><p><strong>Caution：求单位向量时不可忘记$\pm$！！</strong></p><p>距离（推导办法：化归+勾股定理）</p><p>方向余弦满足：$\sum cos^2 = 1, \vec{e} = cos \alpha \vec{i} + cos \beta \vec{j} + cos \gamma \vec{k}$。</p><p>$\dfrac{m}{n}$定比分点公式（比$\lambda$定比分点公式要更容易记，可用于求质心坐标）</p><h1 id="矢量运算"><a href="#矢量运算" class="headerlink" title="矢量运算"></a>矢量运算</h1><h2 id="数乘"><a href="#数乘" class="headerlink" title="数乘"></a>数乘</h2><p>独立于矢量，可将数分离。</p><p>结合律、分配律</p><h2 id="点乘"><a href="#点乘" class="headerlink" title="点乘"></a>点乘</h2><p>投影，和投影与投影和</p><p>渊源，基本运算定律，垂直</p><p>从矢量到模的转化</p><p>点乘坐标表达式</p><p>证明余弦定理</p><h2 id="叉乘"><a href="#叉乘" class="headerlink" title="叉乘"></a>叉乘</h2><p>规则，不满足交换律。</p><p>平行（在坐标表达式中也有所体现）</p><p>坐标表达式</p><p>求面积（二维情形与三维情形），求垂直的矢量</p><p>关于面积，代数上的推导自然方便，但感觉上缺少了几何的古典之美，以下是m67的几何推导（二维情形）：</p><p><a href="http://www.matrix67.com/blog/archives/6217" target="_blank" rel="noopener">http://www.matrix67.com/blog/archives/6217</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>混合积</p><p><strong>形式</strong>：$a \cdot (b \times c)$，其展开就是把$b \times c$最上面一行换成$a_1, a_2, a_3$。</p><p><strong>性质</strong>：三向量共面 $\Leftrightarrow$ 混合积 = 0</p><p><strong>几何意义</strong>：以a、b、c为棱的平行六面体体积。（也可以算四面体等）</p><p>二重矢积：$a \times (b \times c) = (a \cdot c)b - (a \cdot b)c$</p><h1 id="平面与直线方程"><a href="#平面与直线方程" class="headerlink" title="平面与直线方程"></a>平面与直线方程</h1><h2 id="平面方程"><a href="#平面方程" class="headerlink" title="平面方程"></a>平面方程</h2><p>先来回忆一下如何确定一个平面。这又很多种方法，其中一种是通过已知一点还有平面的法向量。通过简单的推导，我们能够得到平面的点法式方程：$A(x - x_0) + B(y - y_0) + C(z - z_0) = 0$。（注意推导顺序：已知方程并不好推出为何它表示了点法式）</p><p>将点法式方程进行简单的变式，就得到了平面的一般方程：$Ax + By + Cz + D = 0$。</p><p>平面的一般方程与点法式方程实则相差无几，都是通过法向量来刻画平面的”方向”的，再以常数调整平面的位置。这是非常巧妙的做法，将较难描述的平面通过我们已学过的向量来描述。</p><p>一般方程是一次的，通过一一对应，我们又能够推出平面方程即一次方程，前者是几何概念，后者是代数概念。</p><p>以下是特殊情况：①D = 0；②A = 0；③A = B = 0……</p><p>有了点法式方程我们能处理什么样的问题了呢？一种变式是过三点的平面（三点可得两向量，叉乘得法线）。</p><p>还有“垂直于两平面”这种条件，也可转化为法向量。</p><p>平面的截距式方程，画图比较方便，还有啥用途我就不知道了。</p><p>谈到平面方程，我们还需要考虑平面间的关系：两平面夹角、点到平面距离……点到平面的距离的公式较为美观，但笔者尚不不明白其特殊意义。</p><h2 id="直线方程"><a href="#直线方程" class="headerlink" title="直线方程"></a>直线方程</h2><h3 id="直线的两种方程"><a href="#直线的两种方程" class="headerlink" title="直线的两种方程"></a>直线的两种方程</h3><p>在二维的情况中直线很容易表示，毕竟二维情况下x，y构成了一组映射。但在三维情况下呢？映射不能用了，我们可以选择参数式方程，或“推广”参数方程的思想，构造出点向式方程：$\dfrac{x - x_0}{a} = \dfrac{y - y_0}{b} = \dfrac{z - z_0}{c}$。</p><p>或者，我们可以“两点确定一条直线”，得到两点式方程。</p><p>再或者，我们也可以把直线看作是两个平面的交，这就得到了一般方程。</p><p>注意点向式方程的特殊情形：$a = 0, a = b = 0$的情形。</p><p>点向式虽然看上去只是“一个”方程，但它其实是两个映射的拼接：从x到y的映射与从x到z的映射。把这两个映射分别写出来，再稍加变形，我们可以实现从点向式方程到一般方程的转换。</p><p>一般方程看上去和点向式方程差异挺大，能否将一般方程转化为点向式方程呢？答案是肯定的：将两个平面的法向量作叉乘，即得到直线的方向向量。再任取两个平面的一公共点，如此便好啦。</p><p>其实两点式、参数式、点向式的中心思想都是一样的，不过它们的出发点不同，故使用起来有方便与不方便之分。笔者更为喜欢参数式方程，因为它在表示“直线上的点”上更为方便。看到直线与XXX的“交点”等表述，不妨考虑参数式方程。以下是例题：</p><p>1.证明直线$\dfrac{x+1}{2} = \dfrac{y+1}{-1} = \dfrac{z+3}{3}$落在平面$2x + y - z = 0$上。</p><p>2.求过点$P(-1, 2 ,-3)$且垂直于矢量$a = (6, -2, -3)$还与直线$\dfrac{x-1}{3} = \dfrac{y+1}{4} = \dfrac{z-3}{-5}$相交的直线方程。</p><p>例二可以通过构造过点$P$且以$a$为法向量的平面$\pi$，再来求交点的坐标。不过笔者认为使用参数式方程要容易一些，不光在思维难度上，也在运算上。</p><h3 id="点线面间的关系"><a href="#点线面间的关系" class="headerlink" title="点线面间的关系"></a>点线面间的关系</h3><p><strong>1.求点到直线的距离</strong></p><p>可以通过找到点在直线上的投影（即解$P’$使$P’P \perp M_0P’$，其中$M_0$为直线上任意一点，$M_0P’$即直线方向向量）。</p><p>也可以通过几何分析，确定$h = \dfrac{|PM_0 \times \vec{v}|}{|\vec{v}|}$，其中$M_0$为直线上任意一点，$v$即直线方向向量。</p><p><strong>2.求直线在平面上的投影直线方程</strong></p><p>容易想到的做法是在投影直线上求出两点，但这样要用两次高斯消元，复杂度略高，有无更好的解法呢？</p><p>考虑直线的一般方程。所谓投影直线，必然在给定平面上。而且，它也必然在本身与给定直线形成的平面上。如何确定这个平面呢？考虑其法向量$n$，$n$与原直线垂直，也与给定平面的法向量垂直，故一个叉乘即可得$n$。至此问题的思路便清晰了。</p><p><strong>3.求异面直线间的距离</strong></p><p>求线和线的距离不容易，但是求线到与之平行的面的距离则并不困难，能够将前者转化为后者呢？</p><p>在这样的思路下，我们过直线$L_1$作与$L_2$平行的平面，问题便迎刃而解了。因将得到的线与面的距离平移，就得到两直线间的距离。经整理，得$h = \dfrac{|M_1M_2 \cdot (v_1 \times v_2)|}{|(v_1 \times v_2)|}$。其中$M_1, M_2$一者为直线上的点，一者为构造出的平面上的点（为方便起见，$M_1, M_2$分别可取两直线上的点），$v$是直线方向向量。</p><p>还有线面角、线线角等，就不加赘述了。</p><h3 id="平面束方程"><a href="#平面束方程" class="headerlink" title="平面束方程"></a>平面束方程</h3><p>直线的方程并非唯一的。点向式固然不唯一：点可以任选，方向向量的大小也是任意的，但这些都是小问题。一般方程的不唯一就有意思了：因为任意两个过该直线的互异平面均可得到同一直线，直线可由无穷多对平面定义。那么，能否通过直线找到所有经过它的平面呢？</p><p>先给出结论吧：若记直线的一般方程为$A_1x + B_1y + C_1z + D_1 = 0$ &amp;&amp; $A_2x + B_2y + C_2z + D_2 = 0$，则其经过该直线的平面必可表示为$\lambda(A_1x + B_1y + C_1z + D_1) + \mu(A_2x + B_2y + C_2z + D_2) = A_3x + B_3y + C_3z + D_3$。</p><p>至于为什么这个式子成立，我们可从法向量的角度来看。$\lambda(A_1x + B_1y + C_1z) + \mu(A_2x + B_2y + C_2z)$表示了垂直于直线的平面上的一切向量。又$A_3x + B_3y + C_3z + D_3 = 0$过直线，故其取遍了一切过直线的平面。</p><p>以上的平面束方程中有两个变元，但实际运算时往往取$\lambda = 1$还有$\lambda = 0$以减少未知量个数。</p><p>平面束方程在求解“过直线且满足一定性质”的平面上较为有效。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>问题：我们学到这里能解决哪些问题了呢？</p><p>1.求过一点且垂直于已知直线的直线</p><p>2.……（待补充）</p><h1 id="曲面方程"><a href="#曲面方程" class="headerlink" title="曲面方程"></a>曲面方程</h1><p>面：满足$F(x, y, z) = 0$的点的集合。</p><p>先从球面方程$x^2 + y^2 + z^2 = 1$直观地感受一下曲面方程吧，它类似于二位情况下的曲线方程。</p><h2 id="柱面方程"><a href="#柱面方程" class="headerlink" title="柱面方程"></a>柱面方程</h2><p>啥是柱面呢？可以联想一下“圆柱”：一个圆，沿着一条直线划出的轨迹。这样便引出柱面的定义了：一条直线$L$绕着曲线$\Gamma$运动所形成的轨迹。$L$叫母线，$\Gamma$叫准线。</p><p>在空间中，$F(x, y) = 0$便表示以z轴为母线的柱面方程。这样我们就可以写出“正常的”圆柱的方程啦！</p><p>如果母线不是z轴，而是复杂的情况，如$\vec{v} = a\vec{i} + b\vec{j} + c\vec{k}$，该怎么办咧？先考虑简单的情况：准线在$xOy$上。那么，所得柱面便是将准线沿“斜着的”方向平移即可，对于不在$xOy$平面上的点，可以通过母线将其转换到$xOy$平面上。通过推导，我们得到这样的曲面方程即$F(x - \dfrac{a}{c}z, y - \dfrac{b}{c}z) = 0$。</p><p>平面上的曲线方程放到空间中，都能“进化”成柱面方程，如双曲柱面、抛物柱面、椭圆柱面等等。</p><p>//讲得还不清楚，待补充</p><h2 id="锥面方程"><a href="#锥面方程" class="headerlink" title="锥面方程"></a>锥面方程</h2><p>柱面方程是直线平动产生的，那么直线转动会产生什么呢？类似于柱面的定义，一条直线$L$固定一点绕着曲线$\Gamma$转动所形成的轨迹，这便是锥面。</p><p>如果$\Gamma$在平面$z = h$上，那么锥面方程便是$F(\dfrac{h}{z} x, \dfrac{h}{z} y) = 0$。</p><p>锥面方程的一个例子是椭圆锥面：以$z = c$平面上的椭圆$\dfrac{x^2}{a^2} + \dfrac{y^2}{b^2} = 1$为准线而以原点为顶点的锥面方程，写出来就是$\dfrac{x^2}{a^2} + \dfrac{y^2}{b^2} - \dfrac{z^2}{c^2} = 0$。</p><h2 id="旋转曲面方程"><a href="#旋转曲面方程" class="headerlink" title="旋转曲面方程"></a>旋转曲面方程</h2><p>上一种情况中是直线绕固定点转动，若是直线绕固定轴转动，得到的就是旋转曲面了，这可以很形象地画出来。</p><p>考虑$yOz$平面上的曲线$\Gamma$，其方程为$F(y, z) = 0$。$\Gamma$绕z轴转动得到的旋转曲面方程如何求解呢？考虑$z = c$平面上的$\Gamma$上的一点与旋转后的曲面上的一点，我们要做的便是将后者化归到前者。由观察知，这两点到z轴的距离都相等。于是乎，可得旋转曲面方程$F(\pm \sqrt{x^2 + y^2}, z) = 0$。</p><p>以上是绕一个坐标轴旋转的情况，换为其他坐标轴，解法也大同小异。</p><p>通过旋转曲面我们又能得到一些经典的曲面：单叶双曲面、双叶双曲面。前者可由$x^2 - y^2 = 1$绕y轴得到，后者可由其绕x轴得到。</p><p>旋转曲面方程求解的中心思想便是$\pm \sqrt{x^2 + y^2}$转化为$y$。记住这点，我们可以求一些稍微偏僻一点的题目：如直线$\dfrac{x - 1}{1} = \dfrac{y}{1} = \dfrac{z}{2}$绕z轴旋转所形成的曲面的方程。</p><h1 id="曲线方程"><a href="#曲线方程" class="headerlink" title="曲线方程"></a>曲线方程</h1><p>同理于直线方程的定义，曲线可以通过两个面的交得到，无论是平面还是曲面。特殊地，柱面和准线所在平面的交就能得到准线。（有趣的是，之前我们是用更易描述的曲线得到较难描述的柱面的，现在我们又用约束较少的柱面来解约束更多的曲线了）</p><p>曲线可以用参数方程表示，一个经典的例子便是螺旋线。</p><p>曲线在平面上的投影也是一个重要的课题，其算法是容易接受的，但理解起来并不那么容易。我们先看个简单的例子：</p><p>曲线为$x^2 + y^2 + z^2 = 2, z = 1$，求其于$xOy$平面上的投影。</p><p>算法的第一步是消去z，但这意味着什么呢？其实便是将z=1平面中的形状给拓展成柱面。然后取z=0，就是取柱面的一个截面。总之，就是将z=1平面上的形状投影到z=0上面了。</p><p>理解了上面的例子，再来看一般的情况吧：$F_1(x, y, z) = 0, F_2(x, y, z) = 0$，解得$z = G(x, y)$。对具体的$z = z_0$，$F_1(x_0, y_0, z_0) = F_1(x_0, y_0, G(x_0, y_0)) = F’(x_0, y_0)$，也就是$z = z_0$平面上的曲线。所有这样的曲线形成的柱面的并也就是$F_1(x, y, G(x, y)) = F’(x, y)$。取$z = z_0$，即得其在xOy平面上的投影。</p><p>有面的投影，也可以有体的投影。体的可以通过面的“围成”得到。故在曲面的方程中将等号更为不等号，体的投影便可得到。</p><h1 id="二次曲面"><a href="#二次曲面" class="headerlink" title="二次曲面"></a>二次曲面</h1><p>接触到曲面以后，我们不免要问，基本的曲面有哪些呢？考虑到次数越高往往越麻烦，而一次方程只能够产生平面，我们探索的主要方向是二次曲面。三个变元三种指数（0，1，2）正负两种情况，能够出现多少种组合呢？这里有很多约束条件，要考虑对称，要考虑常数项，比较麻烦。</p><p>//还不会讨论</p><p>书中给出了六类情况：其中“纯二次”的有椭球面、二次锥面、单叶双曲线还有双叶双曲线；含一次项的有椭圆抛物面还有双曲抛物面（马鞍面）。</p><p>了解了这些情况，我们如何从给定的方程中确定形状呢？这是由曲线出发得到曲面的逆过程，并不符合正常的思维规律。故而我们可以逆向思维，考虑什么样的曲线能凑出这个方程，然后再通过“一一对应”确定唯一性。以$\dfrac{x^2}{a^2} + \dfrac{y^2}{b^2} - \dfrac{z^2}{c^2} = -1$为例。将坐标轴做伸缩变换，得到$\dfrac{x^2 + y^2}{b^2}  - \dfrac{z^2}{c^2} = -1$。而这个方程能通过$\dfrac{x^2}{b^2} - \dfrac{z^2}{c^2} = -1$绕z轴旋转得到。通过简单的图象，能够确定这是有两瓣的双曲线旋转成的图形。那么，它就是双叶双曲线了。</p><p>然而，也有不这么好确定的情况：$z = - \dfrac{x^2}{a^2} + \dfrac{y^2}{b^2}$。刚才的方法就不适用啦！这时候可以采取“平面截割法”，比如，用$z = 0, 1, 2, …$割给定的方程，看它在那个平面上的投影如何。再积部分为整体。分别用平行于三个坐标轴的平面割上述曲面，可以形象地感受到“马鞍面”这一名称的名副其实。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 数学_分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学之美】微积分下-苏德矿版：第二章 多元函数微分学</title>
      <link href="/2019/04/27/Calculus_Vol2-CH02/"/>
      <url>/2019/04/27/Calculus_Vol2-CH02/</url>
      
        <content type="html"><![CDATA[<p>我们为什么要学习多元函数的微分学？</p><a id="more"></a><h1 id="极限与连续"><a href="#极限与连续" class="headerlink" title="极限与连续"></a>极限与连续</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>多元函数：一种特殊的映射。比如，$R^2 \rightarrow R$的映射，这里又用到了笛卡尔积！</p><p>关注定义域（二位情况下为一平面）</p><h2 id="平面点集"><a href="#平面点集" class="headerlink" title="平面点集"></a>平面点集</h2><p>邻域（依据距离描述，事实上一维情况中也是用距离描述的）</p><p>点的类别：内点外点与界点，通过邻域来描述</p><p>集的类别：开集与闭集（关注描述方式）</p><p>连通性（通过折线描述）与开区域</p><p>对于上述概念，我们能够发现，开集与闭集（集的类别）是通过内点外点（点的类别）刻画的，而连通性也是由点的相连刻画的。然而，点本身则是依据其他点（邻域）刻画的。在这里，点本身并不重要，重要的是点与点之间的联系。</p><h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><p>二重极限：由任意路径逼近都趋于极限值，方有二重极限。</p><p>累次极限：先x后y或先y后x的趋近极限值，两种算法可能不一，本质是一元极限。</p><p>二重极限中的“任意”难以直接确定，但否定只需找出反例即可。故若有函数满足在两条路径下趋向某点的极限值不一，函数在该点没有二重极限。</p><p>举个例子：$f(x, y) = \dfrac{2xy}{x^2 + y^2}$。取$y = kx$，可说明其在$(0, 0)$处无极限。</p><p>虽说二重极限似乎比累次极限更“苛刻”更“强”一些，但事实并非如此，$f(x, y) = xsin \dfrac{1}{y} + y sin \dfrac{1}{x}$便是一个非常好的例子。</p><p>有定理：若两累次极限与二重极限均存在，则三者相等。</p><p>该定理的推论为：若两累次极限存在但不相等，则二重极限不存在。</p><p>在用定义求二重极限时，通过不等式（如基本不等式）还有齐次化的方法有时能够在一定程度上简化问题。</p><h2 id="连续"><a href="#连续" class="headerlink" title="连续"></a>连续</h2><p>//二元函数的连续性较之一元更为难以判断，是否有判断连续的方法？</p><p>二元函数中的连续继承了一元函数中的一些方法：最值、介值、一致连续……</p><h1 id="偏导数与全微分"><a href="#偏导数与全微分" class="headerlink" title="偏导数与全微分"></a>偏导数与全微分</h1><p>介绍偏导数前，先介绍的是“增量”的概念。</p><p>所谓偏导数，理解起来相当容易，不论是在代数上还是几何上。</p><p>值得注意的是：$\dfrac{\partial f(x, y)}{\partial x \partial y} = \dfrac{\partial f(x, y)}{\partial y \partial x}$，当$f_{xy}^{‘’}(x, y)$与$f_{yx}^{‘’}(x, y)$在给定点均连续时。（至于证明，先考虑如何得到二阶导数？可以通过两次一元的中值定理，而这需要构造出一个四元的F，再“算两次”即可）</p><p>至于偏导数的计算，主要有两种策略：先代入另一变量再套公式，或者先套公式再代入，计算复杂度不一。</p><p>全微分，和一元的情况很像，写出来是$df(x, y) = A(x)dx + B(y)dy + o(\rho)$</p><p>关键在于全微分与偏导数的关系：$df(x, y) = \dfrac{\partial f(x, y)}{\partial x}dx + \dfrac{\partial f(x, y)}{\partial y}dy + o(\rho)$，此即全增量公式（这个式子是先假定全微分存在，再令$\Delta y = 0$，则可得到$A = \dfrac{\partial f(x, y)}{\partial x}$，非常奇妙的思路）</p><p>也正和一元的情况一样，可微强于连续：可微必然连续，连续不一定可微。另外，可微还能推出偏导存在。反过来不成立，反例：$f(x, y) = ((x, y) == (0, 0) ? \dfrac{2xy}{\sqrt{x^2 + y^2}} : 0)$。（这一反例与前面的例子略有差异）</p><p>但是偏导函数连续（作为二元函数的连续）能够推出可微（证明也是用的两次一元中值定理），这是判断函数可微的重要方法。</p><p>概念的话，关系比较错综复杂，大致有连续、可导、可微、偏导连续这几项。</p><h1 id="复合函数微分法"><a href="#复合函数微分法" class="headerlink" title="复合函数微分法"></a>复合函数微分法</h1><h2 id="求偏导"><a href="#求偏导" class="headerlink" title="求偏导"></a>求偏导</h2><p>证明（直接代入$\Delta z = (A + \epsilon_1) \Delta u + (B + \epsilon_2) \Delta v, \Delta u = …$）</p><p>算法（类似dfs的算法，变量间的关系是树状结构的，方向是从高层到低层，此之谓链式法则）</p><p>应试中需要关注当变元只有一个的时候，$\partial$得换成d。</p><p>//微分恒等式是如何构造出来的？</p><p>//变换方程的一般算法？</p><h2 id="全微分"><a href="#全微分" class="headerlink" title="全微分"></a>全微分</h2><p>一阶微分形式不变性//二阶情形？联系一元？普遍适用性？</p><h1 id="隐函数微分法"><a href="#隐函数微分法" class="headerlink" title="隐函数微分法"></a>隐函数微分法</h1><p>计算方法：用求导，抑或是用全微分//例子，及全微分在解题时的优越性？</p><p>//自由变量？自变量与因变量？</p><h2 id="隐函数组"><a href="#隐函数组" class="headerlink" title="隐函数组"></a>隐函数组</h2><p>一元情形下并没有这个东西，但多元就有了，为啥捏？因为变量间的关系更加错综复杂了。可以一个方程刻画一个隐函数，也可以两个方程刻画两个隐函数（f、g），故而有了隐函数组的概念。</p><p>求解隐函数组其实很简单，把所有方程都对同一变量求偏导，然后解方程就行了。归纳起来便是雅可比行列式。</p><p>//记号问题</p><h1 id="方向导数与梯度"><a href="#方向导数与梯度" class="headerlink" title="方向导数与梯度"></a>方向导数与梯度</h1><h2 id="方向导数"><a href="#方向导数" class="headerlink" title="方向导数"></a>方向导数</h2><p>方向导数的本质：将两个自由变量化为一个自由变量，即坐标系的一维化</p><p>可微则方向导数必存在，其公式也比较简单。但是这里因为有了新的概念引入，概念间的关系又更复杂了：①可微是方向导数存在的充分而非必要条件；②……</p><p>例子：蚂蚁旅行//这个例子的本质？</p><h2 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h2><p>梯度用于刻画$\dfrac{\partial u}{\partial l}$的最值</p><h1 id="多元函数近似运算"><a href="#多元函数近似运算" class="headerlink" title="多元函数近似运算"></a>多元函数近似运算</h1><h2 id="多元函数泰勒公式"><a href="#多元函数泰勒公式" class="headerlink" title="多元函数泰勒公式"></a>多元函数泰勒公式</h2><p>用“多项式”刻画多元函数。</p><p>n阶泰勒公式（证明：构造新的函数，将多元转化为一元，先配出公式，再考虑余项），关注记号。</p><p>注意：因为偏导连续，故而$\dfrac{\partial^2 f}{\partial x \partial y}= \dfrac{\partial^2 f}{\partial y \partial x} $。</p><p>二元函数拉格朗日中值公式及其推论（偏导为零，函数值不变）</p><h2 id="多元函数的极值"><a href="#多元函数的极值" class="headerlink" title="多元函数的极值"></a>多元函数的极值</h2><h3 id="多元函数极值概念"><a href="#多元函数极值概念" class="headerlink" title="多元函数极值概念"></a>多元函数极值概念</h3><p>极值点能够推出偏导不存在，或是存在而为零（证明前者：利用拉格朗日中值定理，$f(x_0 + h, y_0) - f(x_0, y_0) = hf’(x_0 + \theta h, y_0)$，再加个保号性）</p><p>如何判定驻点是极值点呢？记$A = f^{‘’}_{11}(x_0, y_0), B = f^{‘’}_{12}(x_0, y_0), C = f^{‘’}_{22}(x_0, y_0)$，则</p><p>—————$B^2 - AC &gt; 0$：驻点非极值点</p><p>—————$B^2 - AC &lt; 0$：驻点为(A &gt; 0 ? “极小值” : “极大值”)（A不会为0哒）</p><p>—————$B^2 - AC = 0$：得特判</p><p>证明的话依旧是拉格朗日中值定理：$f(P) - f(P_0) = \dfrac{1}{2!}[f^{‘’}_{11}(x_0 + \theta h, y_0 + \theta k) h^2 + …]$，而$f^{‘’}_{11}(x_0 + \theta h, y_0 + \theta k) = f^{‘’}_{11}(x_0, y_0) + \epsilon_1$，然后后者在$h \rightarrow 0, k \rightarrow 0$时为无穷小量，可以忽略。所以考虑二次函数$Ah^2 + 2Bhk + k^2$，判断一下$\Delta$就能得出$\Delta \not = 0$时候的结论啦（因为$\dfrac{h}{k}$可以任意取值，所以要看在全部区间上二次函数是否同号）。//书上为何在$\Delta &lt; 0$时用了其他方法？</p><p>但是这样还有一个疑问：$\Delta = 0$的时候为什么需要特判呢？这些是佐证需要特判的例子：$f_1(x, y) = x^2 + y^4, f_2(x, y) = -f_1(x, y), f_3(x, y) = x^2 + y^3$在(0, 0)点处。<del>下面我不会了</del></p><h3 id="多元函数的最值"><a href="#多元函数的最值" class="headerlink" title="多元函数的最值"></a>多元函数的最值</h3><p>比之极值，还要考虑边界点（不同于一元的情形，边界点有无穷个）</p><h3 id="条件极值"><a href="#条件极值" class="headerlink" title="条件极值"></a>条件极值</h3><p>还记得以前的线性规划么？这里约束条件也来了，不过不一定是线性的……</p><p>条件极值的简单情形如是：$G(x, y, z) = 0$，求$f(x, y, z)$的最大值。</p><p>传统的做法是消元法，但是当z为x、y的隐函数时消元可能做不了。这样还有什么算法呢？拉格朗日乘数法。</p><p>//拉格朗日乘数法的可靠性</p><p>//拉格朗日乘数法的优越性</p>]]></content>
      
      
      
        <tags>
            
            <tag> 课程笔记 </tag>
            
            <tag> 数学_分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图灵之路】常用快捷键与常见命令</title>
      <link href="/2019/04/27/Other-Hot_Keys/"/>
      <url>/2019/04/27/Other-Hot_Keys/</url>
      
        <content type="html"><![CDATA[<p>熟练地掌握快捷键，在很大程度上能够提高使用计算机（不仅仅是编程）的效率。</p><a id="more"></a><p>熟练地掌握快捷键，在很大程度上能够提高使用计算机（不仅仅是编程）的效率。</p><h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><h2 id="常被忽视的按键"><a href="#常被忽视的按键" class="headerlink" title="常被忽视的按键"></a>常被忽视的按键</h2><p>F1：显示帮助</p><p>F2：重命名</p><p>F3：搜索（文本编辑器中、文件夹中、浏览器中）</p><p>F4：显示最近浏览目录（文件夹中）</p><p>home/end：回到行首/行末</p><p>page up/down：向上/下翻一页</p><h2 id="按键组和"><a href="#按键组和" class="headerlink" title="按键组和"></a>按键组和</h2><h3 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h3><p>alt+tab：切换窗口</p><p>ctrl+tab：切换标签页</p><h3 id="选区"><a href="#选区" class="headerlink" title="选区"></a>选区</h3><p>shift+home/end：选中一行</p><p>shift+page up/down：选中一页</p><p>ctrl+shift+home/end：选到文章开头/结尾</p><p>ctrl+shift+arrow：选择下一个单词</p><p>ctrl+L：选中一行（删除时用）</p><h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><p>ctrl+home/end：回到文章开头/结尾</p><p>ctrl+arrow：光标移到下一个单词</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>alt+2（资源管理器中）：创建新文件夹</p><p>win+V：剪切板</p><p>win+R：运行cmd、注册表等</p><p>win+D：显示桌面</p><p>win+shift+S：截屏</p><p>ctrl+Z：撤销</p><p>ctrl+X/C/V：剪切/复制/粘贴</p><p>ctrl+S：保存</p><p>ctrl+‘+’/‘-’：页面放大/缩小</p><p>ctrl+F/H：查找/替换，另外“全部替换”和“下一个”在不同文本编辑器/IDE/浏览器中可能不一</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>fc：用以比较两个文件的差异，对拍的时候很好用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【简牍提要】卡尔维诺：看不见的城市</title>
      <link href="/2019/04/27/Calvino-Invisible_City/"/>
      <url>/2019/04/27/Calvino-Invisible_City/</url>
      
        <content type="html"><![CDATA[<p>黄昏的御花园，暮年的蒙古大帝忽必烈凝神倾听来自威尼斯的青年旅者马可·波罗讲述他旅途中的城市，那些记忆的城市、欲望的城市、符号的城市、轻盈的城市、连绵的城市、所有疆土上亦真亦幻的城市、看不见的城市……</p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="看不见的城市"><a href="#看不见的城市" class="headerlink" title="看不见的城市"></a>看不见的城市</h2><p>书中描写了虚幻而典型的城市，每个城市都是通过场景表述的，是一个横断面，相当凝炼。在这个意义上，所谓“中心思想”应当是不存在的，故每个城市都无法概括。每一篇兼有短篇小说与诗的特点，也都是另一个视角下的生活本身。</p><p>前面的部分看上去还是比较“写实”的：记忆的城市、欲望的城市……但到后面虚构就很明显了：轻盈的城市、连绵的城市……至于人物的对话，这从一开始都是虚的，一切物件：皇宫、地图，也都是虚的，没有马可波罗也没有忽必烈，叙述者就是我们。</p><p>当然，也可以把二人的对话的背景放在未来城市消亡之后，这样他们对于时间的相当“绕”的看法就比较合理了，因为随着变化逐渐消失，时间的概念也趋于消失。消亡的不仅是城市，更确切地说，是生活本身。</p><h2 id="为什么是城市"><a href="#为什么是城市" class="headerlink" title="为什么是城市"></a>为什么是城市</h2><p>因为城市是整体性的，事物，它是文化、生活的集合，是思想、货物交换的地点，是社会的基本单元，是欲望与记忆的归属，是美的一种独特形态。</p><p>它瑰丽而又深邃，吸引着一代一代人在其中，工作、研究、贸易……</p><p>究竟是人们选择了城市，还是城市吸引了人们？</p><h1 id="特色-待补充"><a href="#特色-待补充" class="headerlink" title="特色[待补充]"></a>特色[待补充]</h1><p>①空灵（语言特点）</p><p>②丰富（内容上；语言上）</p><p>③细节（内容特点）</p><p>……</p><h1 id="考究-待补充"><a href="#考究-待补充" class="headerlink" title="考究[待补充]"></a>考究[待补充]</h1><p>并不是严肃的考究，只是简单的联系，不尽严谨，有待交流。</p><p>多罗泰亚——平遥</p><h1 id="集锦"><a href="#集锦" class="headerlink" title="集锦"></a>集锦</h1><p>关于生活的虚无感：</p><blockquote><p>在帝王的生活中，总有某个时刻，在为征服的疆域宽广辽阔而得意自豪之后，帝王又会因为意识到自己将很快放弃对这些地域的认识和了解而感到忧伤和宽慰；会有一种空虚的感觉，在黄昏时分袭来，带着雨后大象的气味，以及火盆里渐冷的檀香木灰烬的味道；会有一阵眩晕，使眼前绘在地球平面图上的山脉与河流，在黄褐色的曲线上震颤不已；又将报告敌方残余势力节节溃败的战报卷起来，打开从未听人提过姓名的国王递来的求和书的蜡封，他们甘愿年年进贡金银、皮革和玳瑁，以换取帝国军队的保护：这个时候的他，会发现我们一直看得珍奇无比的帝国，只不过是一个既无止境又无形状的废墟，其腐败的坏疽已经扩散到远非权杖所能救治的程度。只有马可·波罗的报告能让忽必烈汗穿越注定坍塌的城墙和塔楼，依稀看到那幸免于白蚁蛀蚀的精雕细刻的窗格。</p></blockquote><p>记忆的城市，迪奥米拉：</p><blockquote><p>倘若九月的黄昏来到此地，白昼渐短，你将看到炸食店门口同时亮起多彩的灯光，听见某处凉台上传来女人的叫声。</p></blockquote><p>梦中的城市，伊西多拉：</p><blockquote><p>这里的建筑都有镶满海螺贝壳的螺旋形楼梯，这里的人能精工细作地制造望远镜和小提琴，这里的外来人每当在两个女性面前犹豫不决时总会邂逅第三个，这里的斗鸡会导致赌徒之间的流血争斗。</p></blockquote><p>繁荣的城市，多罗泰亚：</p><blockquote><p>“我很年轻时来到这里，那天早上，许多人匆匆赶往集市，女人都长着一口漂亮的牙齿，直率地望着我的眼睛，三个士兵在高台上吹着小号，到处是车轮滚滚，到处是彩旗飘飘。在那之前，我只知道荒漠和商队车路，而那个多罗泰亚的早上使我觉得今生今世没有比这更美好的感觉。”</p></blockquote><p>繁荣的城市，多罗泰亚：</p><blockquote><p>城墙上高耸着四座铝质塔楼，七个城门口装有弹簧控制的吊桥跨越护城河，河水流进四条绿色的运河，把城市纵横划分为九个区，每个区有三百所房屋和七百个烟囱。每个区的婚龄少女都要嫁给其他区的小伙子，双方父母要交换各自专有的商品——香柠檬、鲟鱼子、紫水晶——以此为基础，就能推导出整个城市的过去、现在和将来。</p></blockquote><p>符号中的城市，塔马拉：</p><blockquote><p>旅途终于把你带到了塔马拉。你沿着两边墙上挂满招牌的街巷走进城市，眼中所见的不是物品，而是意味着其他事物的物品的形象：牙钳表示牙科诊所，陶罐代表酒馆，戟代表卫队营地，天平代表蔬菜水果铺……</p><p>如若一座城市没有招牌或什么形象标志，那它的形式本身和在城里的位置就足以说明它的职能：王宫、监狱、铸币厂、学校、妓院。就连商贩在货摊上陈放的商品的价值也不在于其自身，而在于作为符号代表其他什么东西：绣花的护额带代表典雅，镀金的轿子代表权力，阿威罗伊的书卷代表学识，脚镯代表淫逸。</p><p>你放眼打量结项，就像翻阅写满字迹的纸页：城市告诉你所有应该思索的东西，让你重复她的话，而你虽以为在游览塔马拉，却不过是记录下她为自己和她的各部分所定下的名称。</p></blockquote><p>关于记忆：</p><blockquote><p>但只有一点不同。在梦中的城市里，他正值青春，而到达伊西多拉城时，他已年老。广场上有一堵墙，老人们倚坐在那里看着过往的年轻人；他和这些老人并坐在一起。当初的欲望已是记忆。</p><p>在后来的岁月里，我的目光又回头审视荒漠和商路车队；而我现在知道，这只是那个早上让我走进多罗泰亚的许多道路中的一条。</p></blockquote><p>关于欲望：</p><blockquote><p>阿纳斯塔西亚，诡谲的城市，拥有时而恶毒时而善良的力量：你若是每天八个小时切割玛瑙、石华和绿玉髓，你的辛苦就会为欲望塑造出形态，而你的欲望也会为你的劳动塑造出形态；你以为自己在享受整个阿纳斯塔西亚，其实你只不过是她的奴隶。</p></blockquote><h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><p>郝景芳《看不见的星球》</p><p>刘宇昆《宇宙智慧生命制作书籍掠影》</p><p>（未完待续）</p><hr><p>写于2019.04.27</p>]]></content>
      
      
      
        <tags>
            
            <tag> 文学_后现代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【简牍提要】信息简史：地球的神经系统</title>
      <link href="/2019/04/26/Reading-The_Information-CH05/"/>
      <url>/2019/04/26/Reading-The_Information-CH05/</url>
      
        <content type="html"><![CDATA[<p>将一个难解之谜比作另一个难解之谜……</p><a id="more"></a><h1 id="电气时代与通信"><a href="#电气时代与通信" class="headerlink" title="电气时代与通信"></a>电气时代与通信</h1><p>电流在传播距离上未被发现存在限制，这为远距离通信带来了福音。</p><p>然而福音离降临还面临两类实际问题，一类是工程学领域上的：制造电线、封装电线、储存电流、测量电流……</p><p>还有一类则更像是个逻辑问题而非技术问题：如何将电流转换成字词？</p><p>通信领域的先驱们在面对这个问题时，可能会重新审视曾经的通信技术，它也叫telegraph。</p><h1 id="曾经的Telegraph"><a href="#曾经的Telegraph" class="headerlink" title="曾经的Telegraph"></a>曾经的Telegraph</h1><p>克洛德·沙普在法国大革命时期提出了这个词，意为“远距离书写”。</p><p>他的设计，如同之后提出的许多设计一样，非常精巧，有着机械的精密与美感。</p><p>借助的是视觉信号，所用的器物是沙普信号塔。</p><p>无法传递较长的信息，塔的成本也使得只能telegraph只能在政治、军事而非民事上使用，另中继信号塔的数量对讯息内容也存在影响（联系传话游戏）。</p><p>1793年有法国的议员在报告中呼吁关注信号塔，而1859年，美国的发明家在旅游时为信号塔的宏大、精妙与突如其来的衰亡震撼。</p><blockquote><p>这些信号塔如今陷入了沉默，再不见指示的动作。它们默默矗立在搞出，很快将屈服于时间的侵蚀之手。而电线，尽管外观没有那么雄伟，却遍布整个帝国，用燃烧的火焰将君主的意志传递给在四散在他广袤领土上的六千六百万民众。</p></blockquote><h1 id="电报出世"><a href="#电报出世" class="headerlink" title="电报出世"></a>电报出世</h1><h2 id="社会需求"><a href="#社会需求" class="headerlink" title="社会需求"></a>社会需求</h2><blockquote><p>“远距离传讯是权力和秩序的基本要素。”</p></blockquote><p>而在这个时代，资本家也希望通过远距离通讯获益。他们较政府更有推动力。</p><h2 id="最初的方案"><a href="#最初的方案" class="headerlink" title="最初的方案"></a>最初的方案</h2><p>如何将字词转换成电线中的律动？以字母表作为中间层。</p><p>发明家们的创意设计。（很有意思，高斯和韦伯也合作设计了一种方案）</p><p>在美国，起初发明家和科学家是分离的，前者自行摸索着科学的奥秘，但其对前言科学的发展的无知与无组织性也造成了电报的“重复发明”，合作关系混乱，专利纠纷激烈。有的也有操作过于麻烦等问题，效率不高。</p><h2 id="摩尔斯的方案"><a href="#摩尔斯的方案" class="headerlink" title="摩尔斯的方案"></a>摩尔斯的方案</h2><blockquote><p>“我们国家的邮政信函太慢了……闪电的效果会更好。”</p><p>“构造一种<strong>信号系统</strong>，通过它情报可以得到瞬间传递，这并不困难。”</p><p>虽然对木髓球、气泡或石蕊试纸一无所知，但他意识到信号可以用更简单、更基础、不那么有形的办法来产生，那就是最简单的电路的通和断。</p></blockquote><p>以上是摩尔斯的洞见，他的思想很漂亮，但他缺乏做出能精简地拟合这样思想的机械。韦尔帮助了他，设计了经典的模型：电报“键”，一根控制通断的杠杆。此之谓键式电报。</p><p>键式电报的一段是杠杆，另一端是电磁铁。之后发明家又将电磁铁和杠杆连接起来，这便是“中继器”（relay）。它不止能将衰弱的电流放大，还能够组和多路信号为复合信号。不过这是后话了。</p><h2 id="电报出世以后"><a href="#电报出世以后" class="headerlink" title="电报出世以后"></a>电报出世以后</h2><p>最初的电报讯息并非军事或政治讯息，而是普通的民事讯息。电报的普及也是“自下而上”的，从好玩的公民，到社会各个阶层。</p><p>人们初次收到电报的兴奋：</p><blockquote><p>随着静止的针突然抖动，刺耳的警报声响起，新闻的第一部分传了过来。我们一边兴奋地紧盯着我们朋友向来沉默寡言的面孔以及那神秘的字母盘，一边快速在我们的笔记本记下从大约一百四十多公里外传来的话语。</p></blockquote><p>也有人担心电报对传统报业的冲击，但事实上报业迫不及待地用此项技术来创造价值：因为“电报报道”为新闻贴上了紧急、兴奋等标签。而电报与报纸最终维持了共生的关系，二者互相为彼此提供正反馈。</p><p>电报的流行远远超出了人们的预期，仅过了几年它便跨越了英吉利海峡，当时的《纽约时报》对其高度评价：</p><blockquote><p>这个成果是如此实用，又是如此不可思议……预示着人类未来充满希望的前景……它是人类智力进化过程中一座壮丽的里程碑。而这项成就的实质是什么呢？是思想的传播，物质的生命冲力。</p></blockquote><p>电报给人们带来的振奋普及全球，但它的具体效用体现在当地。</p><p>讯息的传输速度迎来了数量级上的提升，它带来了完全超出人们意料的社会影响。</p><blockquote><p>这就如同一道先前完全不为人知的大坝突然决堤，洪流顿时滚滚而出一般。</p></blockquote><p>比如“天气预报”因电报而成为可能，“电”成了水银的侍女。</p><p>人们的时空观也发生了变化，讯息在传输过程中时间几乎可以忽略不计（但交易成本还是在的），时间从单一的地方时演变为标准时与地方时两套系统，这使得铁路的时间安排成为可行。</p><p>思维上，人们开始能够知道“此时”他地发生了何事。（在此之前，他地发生的事件仅有完成时）</p><p>历史及记录历史的方式也发生了变化，生活的细节得到了保留，这样大量信息的存储可谓史无前例。</p><p>新的生活方式使得新的词语出现，一些旧的词语也被赋予了新意。书中提到了两个笑话：</p><blockquote><p>有位德国妇女带着一盘泡菜走进了卡尔斯鲁厄的电报局，想要“发送”给她在拉施塔特的儿子。</p><p>有位男士带着一份“讯息”来到缅因州班戈区的电报局。操作员在电报键上操作完毕后，就把写有讯息的纸条摁到了钩子上。不了，这位客户投诉说，讯息根本没有被发送除去，因为他明明看到它还挂在钩子上。</p><p>讯息在过去一直被视为指一种有形之物，但这其实从来都是一种假象。</p></blockquote><p>电线在物理上也改变了都市乡间的景观，成为一种怪异的装饰。</p><blockquote><p>人们看到这些电线，不由想到它们所传递的重要的无形货物。使仁罗伯特·弗罗斯特写道：“他们在苍穹下架设线路，字词不论是敲出来还是说出来/在上面奔走时都将如思绪般静寂无声。”</p></blockquote><p>电线在建筑中找不到相似之物，在自然界中也难寻类比。苦心寻找比喻的作家们想到了蛛网以及迷宫。于是新的词语出现了：网络（net-work）。就如同人类的神经网络一样。</p><h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><blockquote><p>在多种意义上，使用电报就意味着用编码(code)书写。</p></blockquote><h2 id="何谓编码"><a href="#何谓编码" class="headerlink" title="何谓编码"></a>何谓编码</h2><p>曾经的人们视莫尔斯电码为一种字母表，但后来人们意识到了它与字母表的不同。它并非是用符号（字母）表示声音，而是用符号（点与划）表示符号（字母）。</p><p>用一种抽象表示另一种抽象，这就是编码。而这，也是数学的本质所在，将意义从一种抽象转换为另一种抽象。</p><h2 id="电报时代的编码"><a href="#电报时代的编码" class="headerlink" title="电报时代的编码"></a>电报时代的编码</h2><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><blockquote><p>使用编码书写出于两种密切相关的动机：为了保密以及为了简明。</p></blockquote><p>前一种需求自古以来便存在，尤其在政治上，“凯撒密码”的渊源便是一个很好的例子。后一个例子则可能是经济社会的发展带来的。电报的成本同文本量成正相关这一特点，迫使人们想出应对的方案。当时，出现了被称为“电报体”的新文风。（网络时代也天天有新文风出现，不过原因则大大不同了）</p><blockquote><p>电报体让任何形式的礼貌说法都无容身之地。“May I ask you to do me the favour”这么一句话，传输五十英里的距离就要六便士。这个可怜的人要把类似温文尔雅的形容词无情地砍掉多少，才能将他的信函开支降到一个合理的水平呢？</p></blockquote><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>信息压缩与加密，正如它们今后将紧密联结在一起，在当时也是同时为人们所采用的。</p><blockquote><p>一套典型的编码系统是用词典中的字词指代整个短语，并将它们按语义和字母的顺序加以排列。比如，所有以B开头的词汇事关面粉市场：baal表示“今日交易量小于昨日”；babble代表“市场景气”；baby代表“西部市场稳定，国内和出口需求中等”；如此等等。当然，这就有必要让发送方和接收方使用同一个词典。</p></blockquote><p>这些方案既非常有趣，也能带来实实在在的经济效益。它们使得密码学，在一定程度上，成为人民群众所喜闻乐见的事物。（可不是嘛，今天也是这样）各式各样的码本层现叠出，显示出编码的生命活力。</p><blockquote><p>密码学一度是，一门隐秘的技术，其奥秘通过私人手稿的方式传播，就和炼金术一样。但如今，编码制作通过印刷术被放到了光天化日之下，激起大众无尽的想象。</p></blockquote><p>这些码本有哪些类型呢？上面提到的“词面变换”是一种，还有“凯撒密码加强版”，“首字母哈希”（将“my health is improving”简写为“mhii”，学生群体常常以这种编码来加密同学名字）。当然，随便的加密还不足以使得成本最小化，而要做到这点，则需要更专门的分析，从数学上，从语言学中，这吸引了许多痴迷数据的人们。</p><blockquote><p>对于编目员、分类员、文字高手、数字命理学者，以及各种各样的收集癖者来说，电报为他们提供了广阔的用武之地。</p></blockquote><p>比如，威廉·克劳森·图厄在其《通用商业电报编码基础》中对短语进行了分组，通过关键词。这不仅是词典编纂学上的奇特成果，也成为了解当时社会的别样史料，同时也能够成为写作的素材来源。</p><h3 id="缺漏"><a href="#缺漏" class="headerlink" title="缺漏"></a>缺漏</h3><p>然而，编码并不总是好的，它虽然简洁且高效，但对冗余的抹除也使得其几乎没有容错性。一个拼写的错误，就可能使整句话的意义截然不同。</p><h2 id="密码学与信息论"><a href="#密码学与信息论" class="headerlink" title="密码学与信息论"></a>密码学与信息论</h2><p>密码的历史相当久远，并不仅限于信息领域，它也可以通过化学方式制造。在信息领域，古典密码学的经典例子有凯撒加密、栅栏加密。</p><p>近代以来，约翰·威尔金斯在一本小册子中，从思辨与数学的角度对密码学，对编码展开了一些思考。他使用有限的符号集来表示整个字母表，通过组合的方式。在书中，他最后引入了一个二元编码：A对应于aaaaa，B对应于aaaab，C对应于aaaba……“两个符号，五个一组，会产生三十二种<strong>差异</strong>”。</p><blockquote><p>任何的差异都是一种二元选择，而任何的二元选择都可以拿来表达思想。在这里，在这份1641年不为人知的匿名专著中，信息论的核心思想浮出了人类思维的表面，却像土拨鼠一样看见了自己的影子，于是又沉没下去，消失长达三百多年。</p></blockquote><h2 id="当时密码学相关人物"><a href="#当时密码学相关人物" class="headerlink" title="当时密码学相关人物"></a>当时密码学相关人物</h2><p>首先是爱伦·坡，他热爱秘密，喜欢神秘，“心灵就是一个密码；它所提供的密文越短，破解起来就越艰难”。</p><blockquote><p>对于爱伦·坡来说，密码制作并不仅是一种对历史或技术的热情，而是一种执着，反映了他对人类是如何与世界交流的认识。</p><p>对他而言，密码是科学和神秘学之间、理性头脑和智者之间的桥梁。密码分析要求具备敏锐的头脑和特殊的精神力量，完全可登大雅之堂，值得在学院中传授。</p></blockquote><p>当然，维多利亚时代最为杰出的密码分析者还是Charles Babbage，他指出：“解密艺术最奇特的一个特性就是，每个人都坚信，自己可以构造出一种无人能解的密码。我也注意到，一个人越聪明，他的这种信念植根就越深。”他破解了当时被誉为“不可破译的密码”——维吉尼亚密码。“如他在其他工作中所做的，他在其中也应用了代数方法，以方程的形式表达密码分析过程。”</p><h2 id="形式逻辑-待补充"><a href="#形式逻辑-待补充" class="headerlink" title="形式逻辑[待补充]"></a>形式逻辑[待补充]</h2><p>为什么在编码的部分提形式逻辑呢？</p><hr><p>开始于2019.04.26</p><p>完稿于2019.05.01</p>]]></content>
      
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【简牍提要】信息简史：将思想的力量注入齿轮机械</title>
      <link href="/2019/04/26/Reading-The_Information-CH04/"/>
      <url>/2019/04/26/Reading-The_Information-CH04/</url>
      
        <content type="html"><![CDATA[<p>Charles Babbage与Ada Byron，在蒸汽时代瞥见计算机的才子佳人。</p><a id="more"></a><h2 id="时代背景：数表"><a href="#时代背景：数表" class="headerlink" title="时代背景：数表"></a>时代背景：数表</h2><blockquote><p>埃利·德容古在1762年曾写道：“喔，欣喜若狂的算数家啊！他那么容易满足，既不求锦衣华服，也不求香车宝马。”</p></blockquote><p>德容古本人则以异于常人的热情编纂了三角形数的数表，其以计算准确、精细而臻于完美而为人所称道。</p><p>除去这些“纯粹”的作品，数表也曾有过广泛而实用的实际用途：三角函数表、平方表、立方表、平方根表、倒数表、星历表、利息表……哥伦布就曾因星历表成功脱险。</p><p>虽然大部分数表实际只需要一些公式，但编写数表有着巨大的经济价值。预先计算加上数据存储加上数据检索的成本往往比临时计算的成本来得低。而在当时，“计算员”是个特殊的职业，显示了计算的成本之高。</p><p>17世纪，对数的发明（其发明者是纳皮尔）大大降低了乘法的复杂度，它将乘法转换为加法，给黑暗世界中的计算员们带来了福音。书中对于这项伟大的发明做出了精辟的论述：</p><blockquote><p>在纳皮尔的观念中，存在着一种类比：差之于比，就如同加法至于乘法。这样他的思考从一个维度跨越到了另一个维度，从空间关系跨越到了纯粹的数的关系。通过将这些刻度并排放置，他为计算者找到了一种将乘法转变为加法的实用方法——实质上，这是把一项困难的人物调低为更容易的任务。在某种意义上，这是一种翻译，或一种编码。计算者通过查检对数表，将自然数编码成了对数，而对数表就是码本。在这种新的语言中，计算变得容易了：加法代替了乘法，乘法则代替了求幂。计算完成之后，需要再把结果译回自然数的语言。当然，纳皮尔当时不可能从编码的角度来考虑这个问题。</p></blockquote><p>对数应用广泛，它使得利率的计算成为可能，它也让开普勒凭借更为精确的数据提出了新的观念，从而推动了天文学的发展。</p><h2 id="Charles-Babbage"><a href="#Charles-Babbage" class="headerlink" title="Charles Babbage"></a>Charles Babbage</h2><h3 id="总体印象"><a href="#总体印象" class="headerlink" title="总体印象"></a>总体印象</h3><p>Babbage是个非常难下定义的人，他聪敏过人，有着各个方面的才干，但这些才干很难归到具体的门类中。他绝对称得上是怪才，也是个有趣的人。</p><p>Babbage的兴趣爱好（不完全）：破解密码，开锁，设计灯塔信号系统，观察树木年轮，改善邮政，观察火车，制造大头针……</p><blockquote><p>一个美国人赞颂道：“对于任何会引起其孩童般纯真好奇心的事物，他都渴望探求其中的原理，他甚至会将各种玩具大卸八块以搞清它们如何运作。”</p></blockquote><p>Babbage对数有着狂热的喜爱，他汇编过动物常数表，四处统计家畜的呼吸及心跳，统计了各种语言中双写字母出现的频率，甚至为平面玻璃窗的破裂区分了四百多种原因……他自己也说：</p><blockquote><p>“数有诸多迷人之处，俗人的眼睛无法看见，只有那些可敬的、孜孜以求的艺术之子才能发现。”</p></blockquote><p>虽说Babbage自身有着独到的人格魅力，但他最为世人所知的还是他的差分机。它曾被遗忘，如今又被从历史的遗迹种重拾。差分机，一如Babbage的狂热爱好，和数字息息相关。</p><blockquote><p>之后，Babbage的机器渐渐被人遗忘，在发明史上湮灭无闻。再到后来，它才又被重新发现，其重要意义得到了追认，犹如灯塔在历史长河中熠熠生辉。</p></blockquote><h3 id="青年时代"><a href="#青年时代" class="headerlink" title="青年时代"></a>青年时代</h3><p>除去对机械的爱好外，Babbage亦热爱数学，而在三一学院中失望地发现导师不如自己。在英法交战的拿破仑时代，剑桥的数学相较欧洲大陆已落后不少。尤其牛顿的巨大影响力成了学生们挥之不去的阴影。</p><blockquote><p>然而他们（牛顿、莱布尼茨）各自提出了互不兼容的符号系统，也就是不同的数学语言。而在实际工作中，这种表面上的差异会比实质上的共性更为紧要，毕竟符号和算子才是数学家们天天要面对的。</p></blockquote><p>Babbage也常被语言吸引过去，他也曾尝试发明一种通用语言，但无可避免地受到巨大的阻力而失败了。（因为存储和取值的问题？）</p><blockquote><p>尽管如此，他仍然认为语言是一种人类可以发明出来的东西。在理想情况下，语言应该加以理性化，成为可预测的和机械的，就如同齿轮必须啮合。</p></blockquote><p>Babbage身边多是能与之开怀畅饮或是打惠斯特牌赌每分六便士的朋友。他还搞了个灵异俱乐部，搞了个“精神健全”俱乐部，当然，也有正经的“在身后留下一个更美好的世界”的解析社。</p><p>据Babbage自己的说法，正是在解析社中面对对数表之时，他想到了差分机的可能性。</p><h3 id="差分机"><a href="#差分机" class="headerlink" title="差分机"></a>差分机</h3><p>蒸汽时代驱动力的强大，与计算对数表的繁琐相比，二者简直不是在同一个世纪。为将人类从枯燥中解救出来，Babbage希望将强大的蒸汽之力应用到思考之上。</p><blockquote><p>这时，数就是原料，之后支架滑行、齿轮转动，大脑的工作就这样完成了。</p></blockquote><p>在没有“输入”也没有“输出”概念的时代，已经有了帕斯卡和莱布尼茨的算盘，但它们只是一种被动型的寄存器，而非计算机，不符合Babbage心目中的“自动化”观念。</p><p>当时，鼠标中存在着一些小小的瑕疵，于是出现了勘误，出现了勘误的勘误，又出现了勘误的勘误的勘误，“混乱雪上加霜”。这些都暗示了计算员的不可靠，与“自动化”计算的必要性。</p><p>于是，Babbage设计了差分机，通过差分来程序化且简单地计算高阶的多项式。这在系协商也较容易模拟，但考虑到进位，计算时间就是个不得不纳入考量范围的问题。这里头又有着很多很复杂的东西得考虑。</p><p>不管如何，因为他的个人魅力，因为他广博的学识与深邃的思想，也由于他传奇的经历和有趣的性格，他在人们中取得了信任也取得了肯定（不过主要不是肯定其学术思想）。于是，Babbage在英国的财政大臣中成功圈到了第一桶金。</p><blockquote><p>到了1823年，英国财政部和财政大臣终于也开始对这个发明产生了兴趣。他曾承诺“对数表将如同马铃薯一样便宜，”这样的诱惑他们如何能抵挡？对数表可是能够挽救船只的。就这样，财政部的首脑批准了第一笔一千五百英镑的拨款。</p></blockquote><p>就这样，差分机的工程开始了。但它不可控地变得无比庞大而复杂，要求的拨款也越来越多。与Babbage在社交场上的如鱼得水正相反，差分机进展的举步维艰既使Babbage也是政府人员失去了信心。不过，尽管差分机已被叫停，Babbage的梦想并未终止，因为它早已转变方向，上升到了新的高度。</p><h3 id="分析机"><a href="#分析机" class="headerlink" title="分析机"></a>分析机</h3><p>所谓分析机，实则是一种通用的数学计算机，相较差分机，它的应用范围要广得多。</p><p>在欧洲大陆着手于分析机的工作时，Babbage与Ada展开了密切的合作。在这段合作中，Ada是真正的主导者，尽管她还年轻，尽管Babbage才是社会名流。Ada强调分析机应做的是运算而非计算（形式逻辑？？），她给出了诗意的描述，也设想了实际的应用：计算伯努利数。</p><p>在当时，Ada就提出了<strong>递归</strong>的算法，他们也看到了<strong>变量</strong>的重要性。在当时，他们的语言是store，mill，后来它们变成了内存与cpu。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><blockquote><p>的确，Babbage的兴趣广泛，似乎偏离数学甚远。但其实他的诸多兴趣之下还是隐藏着一条主线，只是他的同时代人甚至他自己都没有察觉。他的种种追求无法归入任何一个范畴，更准确地说，任何一个当时已有的范畴。他真正的研究主题是信息，是信息的通信、编码、处理等。</p></blockquote><p>在这条主线下，Babbage通过构造词典来破解密码，从树木年轮上看到自然对历史的编码，看到了“通话管”的未来，也在乘蒸汽机车时意识到通信速度慢于移动速度的危险……</p><p>分析机无疑是个失败的发明，被人们所遗忘，而又成为重新发现的宝藏，予人以时代错位的感觉。</p><blockquote><p>Babbage的机器的初衷是生成数表，但到头来，其现代形式反而导致数表被废弃。Babbage可曾预计到这一点呢？不过，他的确曾好奇未来的人们将会如何利用他的远见。按他的猜测，至少还要再过半个世纪，才会有人再次尝试构造一台通用计算机器。而事实上，过了将近一个世纪，这项工作所必要的技术基础才准备就绪。</p></blockquote><p>Babbage相较Ada更“谦逊”一些也更“好玩”一些。他从字面上理解“知识就是力量”，相信未来的科学将转向更为无形的电力，相信计算科学在未来将大踏步地前进。他也这样写给后人：</p><blockquote><p>如果有人在未被告诫以我的前车之鉴的情况下试图尝试这项了无指望的工作，并通过完全不同的原理或更简化的机械手段而成功实现了一台可与整个数学分析部分相当的机器，那么我不怕把自己的名誉托付给他，因为他肯定会完全理解我当年努力的性质及其成果的价值。</p></blockquote><p>让我们以这句话结束这一节。</p><blockquote><p>在他去世前几年，他曾对一个朋友说，他乐意放弃剩下不管多少可活的时日，只愿能在五个世纪后的未来生活三天。</p></blockquote><h2 id="Ada-Byron"><a href="#Ada-Byron" class="headerlink" title="Ada Byron"></a>Ada Byron</h2><p>Ada是”爱的结晶，——尽管她生于苦难，长于动乱“，他的父亲这样写道。</p><blockquote><p>Ada是个神童，在数学方面天资聪慧，并受到了家庭教师的鼓励。她在绘画和音乐方面也有天赋，极具创造力，但在内心也极为孤独。在十二岁时，她开始着手发明一种飞行工具……</p></blockquote><p>Ada在17岁时与Babbage相识，在差分机试验品的展览会上。</p><blockquote><p>“她对于数学之美和抽象的热情，尽管过去在历任家庭教师那里得到了零星的满足，在这时却变得更加不可抑制。然而，她的热情却无处释放。”</p></blockquote><p>Ada在19岁时嫁给了一位通情达理而前途无量的贵族William King，并在不久后成为伯爵夫人。平日里，她练习竖琴，参加舞会，感受着上流社会的气息还有科技的日新月异。她时常情绪低落，也时常受疾病缠身。她崇拜自己的丈夫，但也将精神生活的一部分分给了Charles Babbage。</p><p>Ada有着近乎狂傲的绝对的自我肯定，她也有着与之相称的不屈的意志与超群的能力。她的函授教师是De Morgan，后者认为Ada的“这般能力”足以使之成为“原创性的数学研究者”。</p><blockquote><p>（以下摘自Ada写给Babbage的信件）</p><p>我的学习方式异于常人，因此我觉得只有一个异于常人的人才能教会我。</p><p>我希望你能记住我，我是指我对于数学的兴趣。</p><p>你知道，我生来就有点哲学家的气质，并且天生是个非常卓越的思考者。</p><p>（以下是分析机时代的信件）</p><p>我的头脑不是凡间之物，这一点时间将会证明。</p><p>没人知道我那瘦小的系统中潜藏着多少尚未被开发但几乎让人惊叹的能量和力量……</p><p>我觉得，你的先见之明和预见所有可能情况（而不论其可能性大小）的能力不及我的一般……</p><p>我不认为，我父亲作为诗人（事实上或原本可能达到）的成就可以与我将要作为分析师（以及玄学家——这两者在我身上并行不悖）的成就相提并论。</p></blockquote><p>Ada所感兴趣的不只是数学。她也会迷上游戏，并思考其通解。她肯定自己无与伦比的想象力，也圣徒般地相信自己肩负着一种莫名的神圣的使命。她的一些洞见独具只眼，而从这些论述来看，她确实称得上一名哲学家。（科学哲学？）</p><blockquote><p>关于想象力，我们已经谈了很多。我们谈论诗人的想象力、艺术家的想象力，诸如此类；但我倾向于认为，总体而言，我们并不十分明白我们究竟在谈论什么……</p><p>我相信自己拥有一套非常独特的特质组和，恰好让我适合成为一名非凡的发现者，去揭示自然隐秘的真相……这个信念很久以来就一直挥之不去，而慢慢地我也已经接受了这一点。</p></blockquote><p>Ada后来成了一名家庭教师，独自研究欧几里得。不过她还是忘怀不了Babbage与他那“所有机器当中的珍宝”。</p><p>Ada最终死于子宫癌，较Babbage更早过世，她被葬于自己父亲的身边。在她知晓自己时日不多后，她这番向母亲写道：</p><blockquote><p>人们常说“<strong>将来之事会提前投下其阴影</strong>，可是它们有时不也会提前投下其<strong>光芒</strong>吗？”</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【简牍提要】边缘人偶记</title>
      <link href="/2019/04/25/Reading-Biography_Of_Xu_Guoqi/"/>
      <url>/2019/04/25/Reading-Biography_Of_Xu_Guoqi/</url>
      
        <content type="html"><![CDATA[<p>之前zwk说他清代文化史的助教很是推崇这本《边缘人偶记》，我便对其也有了一番兴致。不过扫了一眼评论，看到“利己”“精英”一类的词，顿时兴趣大减，觉得作者的三观可能和我有所抵牾。再来，这标题看着不是很怎么样。然而近来又陷入了“有书不想读”的困境，便想着换换口味。恰巧zwk又把他们助教的强烈推荐讲了一遍。草草翻完，总体感觉还是很不错的，虽然里头的不足相当多。</p><a id="more"></a><h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a><strong>缘起</strong></h1><p>之前zwk说他清代文化史的助教很是推崇这本《边缘人偶记》，我便对其也有了一番兴致。不过扫了一眼评论，看到“利己”“精英”一类的词，顿时兴趣大减，觉得作者的三观可能和我有所抵牾。再来，这标题看着不是很怎么样。然而近来又陷入了“有书不想读”的困境，便想着换换口味。恰巧zwk又把他们助教的强烈推荐讲了一遍。草草翻完，总体感觉还是很不错的，虽然里头的不足相当多。</p><h1 id="边缘记"><a href="#边缘记" class="headerlink" title="边缘记"></a><strong>边缘记</strong></h1><p>看到“边缘人偶记”这个题目的时候，我的第一感觉是“边缘/<strong>人偶</strong>/记”，侧重点在“人偶”上，即一种不自由的、难以承受的、为他人所左右的地狱般的生存状态。看着看着才明白，是“<strong>边缘人</strong>/偶记”，作者给自己贴上了边缘人——在国别的边缘、文化的边缘，研究着“边缘化”的课题等等，这样的标签，虽然说得过去，但不是很符合“边缘人”的语义——它强调的是一种无法融入的、孤独无依的状态。</p><p>但孤独的边缘在作者的语境中占的比重非常小。徐国琦并非没有依托，他只是认为自己没有归属，或者说自己对于文化认同有着疑惑。他”自认“国际公民，能接受各样的饮食文化，在各类地方呆过，研究着“边缘”的学问。这里的“边缘”，更多有一种“交集”的意味。在这层意义上，作者站在了一个相当跨越相当融合相当有高度的位置。</p><h1 id="读书记"><a href="#读书记" class="headerlink" title="读书记"></a><strong>读书记</strong></h1><p>这本书的第一部分，于我看来，相当的乏味。作者对于赤贫的、愚昧的农村中自己的童年生活怀有强烈的反感与不满，也正是这强烈的不满驱使他努力求学，以走向外面的世界。尤其是在记读初中、读高中、读本科的部分中，作者的利己色彩与对精英主义的肯定表现得很明显（不过往好了说，这也算是“毫不做作吧”），这看得我十分的难受。（事实上，可能是先入为主的影响吧，第二次看这章对作者的好感多了很多，不过一个作者能通过作品让原本不喜欢自己的人喜欢自己，还是很厉害的）</p><p>但是到了做研究的部分，我又有了眼前一亮的感觉：徐国琦的学术观点相当犀利，他对他人作品的见解很多也都是一阵见血。徐国琦的著作确是可以称得上“边缘”的——它们都是另辟蹊径而能有所发现的作品。而在追寻“文化认同”还有“共有历史”的角度看，其著作的思想也是处于“边缘”的。</p><p>出的五本书，三本讲一战，但角度分别是从华工、整个中国以及亚洲分别切入的；两本讲中国，讲中国和美国的共有历史，讲中国和奥运会的历史。这些研究的角度都偏向国际化而非坚持东西方中心论。这些专著虽然我并未看过，但从其描述看来似乎值得一读。</p><h1 id="人物记"><a href="#人物记" class="headerlink" title="人物记"></a><strong>人物记</strong></h1><p>”师友记“记的是作者身边的学者朋友或是老师，讲了非常多自己的所闻所感，很是生动。（王玉华那章除外）</p><p>“人物记”记的是一些传奇性的而与作者之间来往的前辈。通过其描述，对费正清、霍布斯鲍姆、许地山并不熟悉的读者能够对其传奇人生有一些感性的认识。</p><p>费正清：在学术界有着无与伦比的历史地位，单枪匹马地建立了一个学科，站在改善两国关系的潮头上。</p><p>霍布斯鲍姆：坚定的马克思主义信仰者，长于叙述，在三流学校一鸣惊人。</p><p>许地山：宗教研究者，文学家，其作品对人们在思想上有影响。为港大招揽了人才。</p><h1 id="内自省"><a href="#内自省" class="headerlink" title="内自省"></a><strong>内自省</strong></h1><p>①这本书非常口语化，文章的水平似乎没有徐国琦自己讲的那么好。尤其是评价人物的语段，还有称颂，特别单一。（感觉不是特别有诚意）</p><p>②教书记竟然不讲自己的教学，搞什么呢！结果风格还是和其他章节一样吗。</p><p>③书中穿插着许多对于世事的评议，尤其在关于国内学术风气的方面，还是比较中肯的。但也比较零散。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【浮生掠影】设计思维讨论课 发散思维工作坊</title>
      <link href="/2019/04/18/Design-Workshop-Divergent_Thinking/"/>
      <url>/2019/04/18/Design-Workshop-Divergent_Thinking/</url>
      
        <content type="html"><![CDATA[<p>回形针有多少种用途？</p><a id="more"></a><p><strong>试问：回形针有多少种用途？</strong></p><p>政治：作为外交赠品（工业文明的代表产物，国家现代化进程中的重要见证），联系“回形针外交”</p><p>经济：一般等价物；磨成粉作保健品</p><p>历史：第一手资料</p><p>地理：模拟等高线</p><p>信息：编码，联系“回形针码”和“回语言”</p><p>卫生：掏耳朵、扣指甲</p><p>造型艺术：装饰；摆成其他形状</p><p>音乐：敲击</p><p>军事：戳人眼球（恐怖游戏里可以搞搞这种套路，效果可能比剪刀要好一些）</p><p>物理：油罐车防静电；降温；水果电池</p><p>化学：（铁）湿法炼铜，置换氢气，催化剂，等等</p><p>……</p><hr><p>从回形针本身性质出发，更能得到的是下面若干项；</p><p>而从“用途”出发，联系不同的学科，则可得到上面的若干项，至少我感觉更有趣一些。</p><p>这里可以采取双向的思路。</p><p>具体到一个在一个小领域中回形针有何用途，这也是一个思维发散的过程，可以递归地重复上面的步骤，直至得到“原子化”的难以再细分下去的概念，这时候就可以开始收敛思维了。（dfs到最后一层而后返回）</p><p>但还有很多清奇的思路并不好归类，如给轮胎放气、做书签等。正因其难以穷举，能够产生富于创造性的结果，思维发散才这样的有趣。</p><hr><p>2019年3月28日。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【浮生掠影】2019 浙大校赛 BY NESS @ hash</title>
      <link href="/2019/04/14/Competition-TuSimple_1/"/>
      <url>/2019/04/14/Competition-TuSimple_1/</url>
      
        <content type="html"><![CDATA[<p>这是今年打的第一场比赛，成绩咱就不管了，总体玩的还是比较开心的。感觉光阴没有虚度，感觉前方还有着希望，而这就够了。</p><p>作为一次经历，一次体验，打比赛在生命中自然是有其价值的，它是一个节点，串起了过往无数日夜的辛劳准备与或狂喜或迷惘的期望。它不一定是结果，也不代表旅程的结束，以我当前的追求来看。它只是一个中点，是生活的增味剂，是另一种形式的酒与诗歌。无用，然而有趣。</p><p>说起比赛，首先想到的还是以往略显单调但也有滋有味的高中生活。想起以前翘课出去打NOIP，参加清华的不知什么考试，还有寒暑假在杭州在上海在环中的日日夜夜。关键并不在成就与从中得到的对自我的肯定，虽说这也是较重要的一环。我更喜欢的是合法翘课的感觉，喜欢的是纯粹出去玩这样一种心境。有一种逃离的快感，叛逆的甜蜜。而我所逃离的是什么呢？是日常？是普通？抑或无趣？在这层意义上，今天我仍然生活在高中时代的心理状态中。</p><a id="more"></a><h1 id="随想"><a href="#随想" class="headerlink" title="随想"></a><strong>随想</strong></h1><p>这是今年打的第一场比赛，成绩咱就不管了，总体玩的还是比较开心的。感觉光阴没有虚度，感觉前方还有着希望，而这就够了。</p><p>作为一次经历，一次体验，打比赛在生命中自然是有其价值的，它是一个节点，串起了过往无数日夜的辛劳准备与或狂喜或迷惘的期望。它不一定是结果，也不代表旅程的结束，以我当前的追求来看。它只是一个中点，是生活的增味剂，是另一种形式的酒与诗歌。无用，然而有趣。</p><p>说起比赛，首先想到的还是以往略显单调但也有滋有味的高中生活。想起以前翘课出去打NOIP，参加清华的不知什么考试，还有寒暑假在杭州在上海在环中的日日夜夜。关键并不在成就与从中得到的对自我的肯定，虽说这也是较重要的一环。我更喜欢的是合法翘课的感觉，喜欢的是纯粹出去玩这样一种心境。有一种逃离的快感，叛逆的甜蜜。而我所逃离的是什么呢？是日常？是普通？抑或无趣？<strong>在这层意义上，今天我仍然生活在高中时代的心理状态中。</strong></p><h1 id="热身赛"><a href="#热身赛" class="headerlink" title="热身赛"></a><strong>热身赛</strong></h1><p>日程的话，早上有个热身赛，九点半开始。在此之前七点半至九点是所谓检录。下午一点正式开赛，打四个小时，直至五点。这样看下来，大半天都被打掉了。晚上其实也主要在想这回事，会有“如果这题做出来就没有遗憾啦”，诸如此类的想法。于是这约莫就是这一天的主旋律了。原先zc嫌时间太久想翘掉的，但见xn没翘也就没翘了。谢天谢地，如果他们两位翘掉了估计我就只能<del>对着屏幕两行泪了</del>跟着翘了。</p><p>虽说这是校赛，但我们对待得真挺随便。没碰代码一个月的我也就随便搞了点板子，没碰代码一个月的zc赛前一天开始调环境。赛前一个月基本完全没准备。赛前一天才开始和xn交流板子行不行。有些过于娱乐了？毕竟经验过少，但毫不慌张并调好心态或许比瞎准备一通发现自己方向错了来得有益，于我看来。</p><p>早上的热身赛真的挺热身，zc花了一大半时间在配环境：sublime、visual studio、code，一个个都试过去了，花了好长时间嘞。还下了大数的模板，也测试了一下。然而下午居然重启电脑了，题目也收回去了！<del>我妹子还没认全呢555</del></p><p>里面有个C题很好玩。就是有十二张图片（ACG作品中的<del>妹子</del>人物），二十四个名字，把名字和图片对应，输出，没有输入。名字都是假名表示的，图片也都是同人画师的作品，搜图难度不小。估计是颜色的问题，不管什么百度搜图谷歌搜图效果都不能看。在p站上查画师效率也不是很高，于是只得慢慢搜名字（<del>一个一个妹子认识过去</del>）。有点烦的一点就是有些名字搜不到，不管在萌百上还是其他网站上，这就会让人比较泄气，怀疑是否漏了谁，从而对答案正确性与自己的努力产生怀疑。搜了一些名字，发现自己御宅指数还真是低，敏感性也比较差，看到”Tohsaka Rin“时脑海中完全没有图象。东方的人物我也认不全。这可能还跟接触的体系有关系吧，我是没啃过生肉的，知道的东西也都很表层，在欣赏ACG作品缺乏联系观，也缺乏对<del>妹子萌点</del>人物特征的宏观认识，对于作画等等的认识也实在是肤浅。想想自己只是个假的肥宅，有些假的难受。</p><p>A题的话，让你判断一个数列是不是peak sequence，简单模拟即可。但我忘掉了和peak sequence相关的知识欸。我好弱啊。</p><p>D题是顺序买书，已知书的总数、每本书的价格和买的本数，买书的策略是贪心，求最大携带的钱数。一开始想能否二分答案，但想想不行，具体哪里不行就讲不清了……之后想到贪心的思路：把前k本都买下来，剩下的钱再不足买剩下任何一本书，那么这个钱数是符合要求的，而且超过它就不符合要求了，可行！就是不知道这个思路该置于知识网络的哪个位置。我对于算法的认识，在微观层面，还是非常容易搞混且相当想当然的，这是一个得改的毛病。</p><p>B题是给出一个括号序列，给出了一套生成序列的规则，让你求第k个序列从第l项到第r项有个多少‘(’。这题当时没人提交（估计都在查C题吧），我初步想法是这样的：序列是无穷的，故要在一个周期内界定它，而后面的序列和前面的序列又可以通过set判重来得到”序列的周期“（二维的概念啊，有意思）。总之就是有点恶心的模拟了，加上模乱搞不知行不行得通……无法实践验证想法，就不细想了。</p><h1 id="比赛本身"><a href="#比赛本身" class="headerlink" title="比赛本身"></a><strong>比赛本身</strong></h1><p>想做题的话，戳<a href="http://acm.zju.edu.cn/onlinejudge/searchProblem.do?contestId=1&amp;titlefrom=0&amp;authorfrom=0&amp;sourcefrom=0&amp;query=The+19th+Zhejiang+University+Programming+Contest+Sponsored+by+TuSimple" target="_blank" rel="noopener">这里</a>qwq。</p><p>比赛开始时还是有些紧张的，中午睡得也不咋样，总之不是特别有状态。开赛后首先看的是B题，而xn在看A题，zc在配环境。B题定义了一类“偶素数”，还有“偶合数”，让求给定的“偶阶乘”最多能拆分为多少个“偶素数”，本质上应该是$2^s || n!, s = \sum\limits_{i = 1}^ \infty \lfloor \dfrac{n}{2^i} \rfloor$的变形。但是数据量级是$10^{1000}$，不写大数不行。于是zc和xn讨论G的时候，我一直在打板子。这个板子是半年前的，记得当时减法没搞，就没管，不想除法里需用到减法，一下就慌起来了。还有大数比较等等也都没有写，心情就比较地烦躁。中间想到用java写，或者写二进制的大数，但都碰上了问题。临结束时瞎写了一通，不知哪儿出问题了。这题也便不了了之了。想来还是有些遗憾。</p><p>除去B题，我第二个看的是J题，当时已有队伍提交了。这题讲的是给定正数n，让找满足$x + n = y$的一组合数x，y，任意输出一组即可。我当时拍脑袋想想x=2n，y=3n不是满足条件嘛，但觉得这样过于简单了。和xn交流后也没发现问题，但交上去就是一个明亮的WA。为什么呢？是流输入的问题么？总之不会是数据范围的问题吧。搁了一会儿后，xn测试时候来了个“1”，输出“2 3”。很明显，错掉了。于是我只能尴尬地换成x=8n，y=9n，这才搞定。此时已经过去45分钟了。</p><p>不光J题开始没过去，E题一开始也卡在这了。背景就不讲了，总之水题一道，但水水的我们过也过不去，就比较烦。zc花了一些力气把dev调教对，然后测试了自己构造的数据没发现什么问题。此前有交流，此后有深思，卡了好一会儿呢。最后又是xndl敏锐地察觉到虽然输入是在$10^9$，即int范围内的，然而我们有用求和，之后规模可能会超，得换long long。果不其然，改了数据类型后顺利拿到了一血。</p><p>后面我看的题是I，涉及到逆元、平均数、方差、选子集，极端数据还达到了恐怖如$2^{40}$的规模。想来不推结论肯定TLE的，但有何结论呢？从没做过跟方差有关的题，对于子集也不知如何高效处理，只能是对着题干空着急，发呆。简单化简了一下方差，搞出来一个线代课上好像曾见过的矩阵，忽然又想道”正定二次型“这个名词，可又死活不知道接下去怎么办了。这题也就弃了。</p><p>其他题我基本没看了，状态很糟。zc主要是搞C，xn主要在搞A。C和A我都没看，听他们说前者是简单模拟，后者用搜索或许可以。然而都TLE掉了。于是zc又给C剪枝，剪一会，交一遍，TLE，然后略有所思又想出来一个剪枝，我打一会儿大数就得起来一下给大佬让座，很是有趣~xn的A也优化了一遍又一遍，最后想试试卡时，在语法上又折腾了老半天，可最后还是没弄出WA。我差不多在两个小时后就没有认真打的念头了。看看人家碗里的气球，互膜互黑，倒也不错。</p><p>于是只能凄凉地拎着三个气球回来了，其中一个被吹走了，一个气放掉了，还有个踩爆了。看着人家手中气球满得都溢出了，不由得感叹自己菜得就像被人家踩爆的气球，何其可怜，多么无助。</p><p>早上刷名单的时候发现wyh也参赛了，寻思人家肯定是solo的。最后在榜上果然赫赫有名，着实是厉害。膜了人家一波，好不愉快。</p><h1 id="现场赛与网络赛"><a href="#现场赛与网络赛" class="headerlink" title="现场赛与网络赛"></a><strong>现场赛与网络赛</strong></h1><p>比赛的形式在很大程度上对发挥会有影响。一直都不喜欢去机房，因为那边的环境，因为那里的键盘。对于这些我都很不习惯。讨厌配环境，讨厌看见稀奇古怪的错误，讨厌程序正确却跑不起来的无力感。<strong>在这类问题上，我一直不愿意走出自己的舒适区。</strong></p><p>此外，现场赛有很多额外的限制，比如不能查东西。查询一般只在对事物有一定认识时才会奏效。查算法一般都是无效的举动。查语法更频繁些，因为这些东西我记不住，而且我觉得它没啥思维深度。查到原题查到相关算法还是少数，是值得高兴的事情，比如之前的趣味C，比如寒假的网络赛中那个让我告别0AC的组合数取模的板子。</p><p>回来今天来。中间，大数的板子搞不出来，zc想用java试一试，但是在语法上就碰到问题了。连大数初始化都搞不起来，更不用谈运算了。事后这些东西一查便知，但当时就是搞不起来。最后xn想卡时，但#include<time.h>之后还是懵了好一会儿，直到在书上查到其用法。（虽然最后还是没有WAhhh）</time.h></p><p>开卷虽然看上去比闭卷更为轻松，但若是对知识体系没有明确的认识，往往只能又慌又无助地乱翻书，效率非常低下。故，在这样的限制下我们当怎么做呢？首先还是要搞清楚自己受了什么样的限制，提前做好准备，有所对策，才不至于在事后后悔。虽然在本次比赛我们也没有可以后悔的理由。</p><p>机房的键盘，真心是叫人难受，敲起来又慢，还没有快感。不过即便是如此，我也还是有需要反省的地方。打字容易出错，快捷键用得还不顺（尤其ctrl不会用），等等。这些相对思维是外部的事物，但做好了能起增益效果。一来是需要有提升的意识，意识到自己和键盘和自然语言间的羁绊还不够深；二来是要有科学的方法，归纳出哪些快捷键是能够提升效率的，归纳出自己在打什么词的时候特别容易出错，在此基础上有所提升。</p><p>最后是环境，这个东西真心无聊，我尤其讨厌。但这是很常见的问题，尽管我并不“喜欢”它，我仍然“需要”解决问题的能力。环境不光是指机器上编译、链接、运行等步骤，还关乎对于软件的熟悉程度。视图、快捷键，等等。一个视图没调出来，尤其对状态有一定影响，因为它将原本连贯的思路与预期切断了。不喜欢用dev，VC++，看着那些复杂的条条框框看得很难受，这些软件有做到以人为本么？作为普通用户（然而，它们本就不是为普通用户设计的），我觉得开发者，是有所不足的。（但是，今天仍有许多学校和教师鼓励使用这些老旧的产品，他们是否需要反思呢？）可既然大环境如此，我也便只能熟悉其架构而无法奢谈转变。如何熟悉呢？或许我需要在机房找找答案。</p><h1 id="合作与对抗"><a href="#合作与对抗" class="headerlink" title="合作与对抗"></a><strong>合作与对抗</strong></h1><p>程序设计的竞赛大抵有两类，一类时段较长，如各类开发比赛，动辄几个月的。另一类时段很短，ICPC是一个，还有像黑客马拉松呀，Game Jam啊，它们关注的是爆发力，竞技性更强些。zc说前者更能体现与赛者的能力，不过后者往往更加紧张刺激一些，打得有趣，看榜也有趣<del>，看别人满桌子气球的样子更有趣</del>。</p><p>而且往往来说呢，第一类比赛的“合作性”会更强些，而后一类的“对抗性”则占了上风。作为一名蒟蒻，我一向是喜欢“通力合作”的，高中时候每回数竞的模拟考都会参与大家的讨论。记得打NOIP前报了个不知什么网络赛，然后就和蒋哥一起合作了。题目今天不记得了，当时感觉和自己的能力还是在一个数量级内的，做得比较有成就感。和蒋哥分享看法，给他看自己的代码然后收到肯定的信号，一起感叹最后一个有多毒瘤。真的很好玩，很有意思，很开心。今天想来，还是宝贵的记忆呢。</p><p>NOIP倒是合作不了了，也就考完后简单谈了谈感受，谈了谈这个输出格式之恶心，谈了谈试卷对于ds之偏爱，其实其他“有意思”的考试考完也是这样的。坐着大巴，背着待会语文考试的答案，拖着辘辘饥肠，等待着原应是KFC结果是“江西小炒”的晚饭，回到期中考的轨道中。<strong>没有若有所失的感觉，只是在平静中，一个阶段已经结束了。</strong></p><p>ICPC倒是在对抗中也体现着合作的。有幸我们还能够交流，能够发现一些隐蔽的问题，也能得到更广的视野，在一定程度上。但是，交流也并不是件简单的事情，它甚至并不“自然”。不过，这些已经是下个标题的主题了。</p><h1 id="沉默与交流"><a href="#沉默与交流" class="headerlink" title="沉默与交流"></a><strong>沉默与交流</strong></h1><p>debug，往往来说，都是件孤独的事情，甚至可以说是反人性的。但是开题并不是孤独的，它代表着希望，虽然希望时常会转化为绝望。为了让希望成为希望，我们需要更全面更深入而非想当然的思考，在一定程度上，交流能做到这点。可交流本身也并不容易。先回顾一下当时吧。</p><p>我们开始的策略还是得当的，不同的人开不同的题，但之后的步骤，我认为我做得并不好。我有B题的思路，但我完全无法将其表述给队友，为什么？在向xn介绍J题的思路时，我用的语气是较为肯定的，绝对的，“2n肯定是合数”，这样的交流有效吗？后来xn开了A题，zc开了C题，我只“大致地”听了听他们的思路，而未对细节有深入的思考。非常失败。</p><p>交流的一方面是传递自己的想法，在这个过程中要尽量避免隐蔽的想当然的想法；另一方面，交流是关于聆听的，而非“听见”：对方的思路是如何展开的？他有什么可能的错误？他没提到什么？</p><p>在交流时，不应是你一句我一句并且交谈没有中心。二或三人交谈时，一方当作为领导者，把握着对话的小主题、中心问题。其他人需要发散思维的广度。提出尽可能多的解决方案，并对其做出一定深度的拓展。然后是围绕可行的方案收敛思维。如是反复。</p><p>对这个话题想的还不多，也没什么条理，先放着吧。</p><h1 id="补题时间"><a href="#补题时间" class="headerlink" title="补题时间"></a><strong>补题时间</strong></h1><p>弱鸡的我的代码在<a href="https://github.com/NessOffice/Sync_Code/tree/master/history/zju2019_SchoolMatch" target="_blank" rel="noopener">这里</a>QAQ，仅供参考。</p><h2 id="A"><a href="#A" class="headerlink" title="A"></a><strong>A</strong></h2><p>比赛时一直被数学题搞得状态不佳，A和C都没看。结果A是2019.04.21AC的，而C是2019.04.20AC的，放了好几天嘞。</p><p>A的大意就是给定一组男人一组女人，每个人都有身高和偏好，其中身高各不相同，偏好为0表示只和比ta矮的人匹配，偏好为1表示只和比ta高的人匹配。问什么样的匹配方案能使总配对数最高。</p><p>看上去有点像什么二分图匹配，也好像可以搜索解决，于是我就不大想做……认真看了看，感觉贪心可以搞，那就试试贪心吧！</p><p>先把所有人按身高排序，然后顺序检索。每时每刻检索到人都是“可匹配的人”中最矮的，如果ta的偏好是0，就可以把ta跳过了；如果ta偏好是1，看看后面第一个和ta匹配的人，配对之。（容易证明，这样的贪心保证了全局最优性，证明的话，考虑如果不是贪心的策略，就替换吧）这里用last[0]与last[1]分别维护上次贪心得到的男/女性的位置，即可保证检索与匹配的复杂度是O(n)，加上排序，O(nlogn)，可行。</p><p>但是自己写的时候有点想当然，last只开了一个。题目里的数据又特别小，没出问题，于是百WA不得其解，之后将自己的思路表述出来才发现这一问题，从中可见有效交流的重要性。</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a><strong>B</strong></h2><p>在4月的16号早上，我开始调整自己的大数模板。先是写了个python的数据生成器，并加了些自己构造的数据，然后是用python调出用以对拍的程序，再是重构（debug_fc.bat，整合了debug_BigNum_py.py等），使这个板子的结构更加清晰。之后加减乘除均通过了测试。在此之后，开始上B的代码，碰到段错误，之后是TLE。</p><p>看了看别人用python写的程序，可谓如梦初醒！我的思路是{ans += n / two;two *= 2;}，但是{n /= 2;ans += n;}完全能实现等价的操作。在数学上，二者是等价的；可是两者在计算上的复杂度并不等价！尤其我的大数除大数中用减法模拟取模或许会占掉很长的时间，而我局限在前一种想法中，没有拓宽思路，这十足是个教训了！另外，我没有在纸上继续推结论，而只是在脑袋里想想，这或许也是个不好但也难改的习惯吧。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a><strong>C</strong></h2><p>题意的话，是给定机器人的行为模式还有房间的结构，求机器人运行k步后捡了多少垃圾。具体不表。</p><p>初看似乎是模拟题，但是k可以高达10e18次，所以复杂度要么是min(f(n, m), k)，要么是O(k^1/3)这类。后者貌似在组和题里更有可能出现，我们就考虑前者吧，由剪枝降低复杂度。但是这个枝怎么减呢？</p><p>题目中的x由中间及其周边五点的值唯一确定，故这五点值若不改变而机器人停留在原位（即机器人什么都没做），它必将循环地无所作为。直接模拟k = 10e18的话，很大一部分时间都是耗在这上面的，所以这种枝一定得剪。</p><p>但光剪徘徊在原地的枝还不够。原地徘徊是一种自环，其他的路径也可能成环（比如，(2, 2) -&gt; (2, 3) -&gt; (2, 2)），要把这些也剪掉。怎么判断走的确实是环（即后面的路径与前面的循环）呢？只要看再走到同一点时ans有无改变即可：若无，则机器人从该点返回该点的路径中没有捡垃圾，也就是它接下来走的路将与此前完全相同。这样，剪枝就分析好了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(vis, <span class="number">-1</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">while</span>(k--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[a][b] == ans) <span class="keyword">break</span>;</span><br><span class="line">    vis[a][b] = ans;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（但是这么漂亮的东西并不是自己想的而是抄来的QAQ）我一开始是用set判a, b, cmd的三元组，发现不对，之后换成map加上经过一点的次数。zc的方法是在捡垃圾里面加上{vis[a] [b] = vis[a-1] [b] = … = 0;}，都WA了。看到一排的WA心情就会发生微妙的改变，要么是变佛，要么是不搞出来不睡觉这样。我是挺佛的，看看人家的剪枝这么优雅就把自己的给丢了，谁知道哪个神仙地方出了bug，这题也不好拿数据对拍。今天想想，光看“该点”的状态还是不够的，因为在路径中间捡完垃圾回到原点，后面仍可能走新的路径，故而要用更“全局”的东西来记录状态，我们应当是错在这点上。</p><p>这题的复杂度我还不会分析。若n、m取最大值，机器人至多在多少步后退出？我还没有想明白。</p><p>下面是D题，题干就不念了，没有输入，要求给出足够好的机器人捡垃圾策略。AC条件为在给定步数内，给定多组随机数据，平均捡垃圾率足够高。</p><p>随便分析了一下，看三进制下算出来的x的值。首位不会为1，所以1打头的都可以填I（同理01111这些也是不可能的）；首位为2的时候yy一下，都填P。然后首位为0时开始转移，依据旁边的点的结构，旁边的点会呈现出什么样的结构呢？</p><p>然后我就不知道了，就咕咕咕啦。</p><h2 id="G"><a href="#G" class="headerlink" title="G"></a><strong>G</strong></h2><p>题目本身比较简单，关键点在于将正负分开来考虑，然后每次贪心即可，详情参考代码。</p><p>问题是为什么会想到将正负分开来考虑呢？</p><h2 id="I"><a href="#I" class="headerlink" title="I"></a><strong>I</strong></h2><p>题意：给定n个点及其权w，给定m组约束关系（即有m对点不能同时选取），令x为$\prod w_i, i \in S$，S为n个点中任选若干点的满足约束关系的子集。问所有x的方差对1e9+7取模的结果。</p><p>题目中n最高达40。这个数量级下直接模拟（2^40）稳超时的。如何压缩时间呢？我一开始是觉得这里头会有什么微妙的数学结论的，就随便推了推，也就把方差展开了一下，结果并没有什么用。</p><p><del>康了康网友的题解</del>意外地发现并查集可以用来解决选子集的问题！考虑这样的数据，n=3，m=0。这时候共有8种选取方式。而8=2^3，我们可以用这样的代码来计算所有x的和及所有的选取方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    sum_x = sum_x * w[i] % MOD;</span><br><span class="line">    num_total = num_total * <span class="number">2</span> % MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的思路像不像生成函数？$\sum x = \prod(1 + w[i])$。”正常“的dfs是把右式中每一项列出来计算，而这里我们是注意到了这个式子本身，从而将右边的式子逐项计算，大大减少了计算复杂度！从O(2^n)到O(n)，这是怎样的突破呀！</p><p>上面的例子是m=0的，如果有约束条件呢？我们就用并查集，看看哪些项可能存在关联，把他们放到一个集子里（这样，集子与集子之间就是相互独立的，可以像前面一样运用乘法法则啦！），前面的方法也要改写成这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(LL i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[i].size() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    temp_x = temp_num = <span class="number">0</span>;</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    sum_x = sum_x * temp_x % MOD;</span><br><span class="line">    num_total = num_total * temp_num % MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tree[i]储存”可能存在关联“的元素，tree[i].size() == 0就表示这个元素被并到其他集子里去所以不需要检索了。dfs是暴力搜索在一个集子里的x的总和和可能的子集数，记作temp_x与temp_num。说到这里，核心的元素应该都阐释清楚了，具体部分可以看代码。最后的ans的计算公式是将方差化简所得到的，此处不表。dfs选子集是通过位运算进行的，此处也不表。模运算中的技巧如求逆元等同样不表。</p><p>这样的代码能应付这题了，下面我们来看看复杂度吧：上面我们对复杂度的认识还只是较为粗浅的，只考虑了一种情况。但并查集真的能在任意情况下对算法起到优化作用吗？考虑下面这组数据：n=4，m=3，约束关系为(1, 2)，(1, 3)，(1, 4)。把它推广下去，则算法的复杂度还是O(2^n)！</p><p>聪明的读者想必注意到了：在并查集内部，其他数都还是没有关联的，能否将之分配到新的集子中呢？若行，则这样的迭代要如何进行呢？对此我尚未想明白，读者诸君若有想法，欢迎联系，共同探讨。</p><p>总结一下经验教训吧：</p><p>①没有想到在模的意义下处理ave、ans（我真傻，真的，我单知道有理数运算可行；我不知道在模的意义下更方便处理），从而无处着手。</p><p>②没有想到存储sum_x2，sum_x来直接得到ans的值，但这应该是小问题，反映的更多是我的经验不足。</p><p>③MOD的处理，对每一个运算都要想是否需要取模，是否为负，特别是读入的时候。</p><p>④1和1ll不是同一个东西！这谁debug出来呀！</p><h2 id="J"><a href="#J" class="headerlink" title="J"></a><strong>J</strong></h2><p>观察了一下其他队伍的情况，相当多的队都是直接AC或是WA一发后在2-5分钟后就能调AC的，少量队伍调了30分钟乃至3小时。相比之下我们的20分钟（中间还放了一放）还是相对顺利的。但是对于边界数据，我的觉察程度还不够敏锐。</p><p>其他题还没补，先放放好了。</p><hr><p>初写于2019.04.14</p><p>完稿于2019.04.25</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【简牍提要】信息简史：两本字典</title>
      <link href="/2019/03/28/Reading-The_Information-CH03/"/>
      <url>/2019/03/28/Reading-The_Information-CH03/</url>
      
        <content type="html"><![CDATA[<p>这章字面上讲的是具体的字典，但实际也是在讲抽象的词汇，故本章和上一章在逻辑上的关联是比较强的。从口语到书面语，文字量出现了可观的增长，故而为其做出划分是有必要的。词典将文字做了尽可能完备的记录，以便能确定语言的“标准”。</p><p>词典为文字的持久性提供了正式认定，它表明一个字词的意义来自于其他的字词。这意味着所有的字词聚集到了一起而形成了一种互相关联的结构（图），它们相互定义。</p><p>然而，文字也是时刻在发生着改变，如何从这不确定性中确定权威，这是词典编纂者的一大难处。</p><a id="more"></a><p>副标题：我们文字的<strong>不确定性</strong>及我们拼写的<strong>随意性</strong></p><p>这章字面上讲的是具体的字典，但实际也是在讲抽象的词汇，故本章和上一章在逻辑上的关联是比较强的。从口语到书面语，文字量出现了可观的增长，故而为其做出划分是有必要的。词典将文字做了尽可能完备的记录，以便能确定语言的“标准”。</p><p>词典为文字的持久性提供了正式认定，它表明一个字词的意义来自于其他的字词。这意味着所有的字词聚集到了一起而形成了一种互相关联的结构（图），它们相互定义。</p><p>然而，文字也是时刻在发生着改变，如何从这不确定性中确定权威，这是词典编纂者的一大难处。</p><h2 id="字典诞生的条件"><a href="#字典诞生的条件" class="headerlink" title="字典诞生的条件"></a><strong>字典诞生的条件</strong></h2><p>印刷业、商业、交通、语言等等方面的快速发展，呼唤着语言的“标准化”。这种需求是词典诞生的原因。</p><h3 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h3><p>考德里的《字母排表》是信息史上的一座里程碑，但遗憾的是人们对于作者几乎一无所知，甚至连名字都拼不对。关于拼写这件事，书中提到：</p><blockquote><p>随着印刷书的出现和普及，人们逐渐产生了这样一种感觉，即单词的书写形式<strong>理应是</strong>确定的。</p></blockquote><h3 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h3><p>（英语）字典诞生的另一个原因和英语本身的特点相关。</p><p>英语是当时的世界上已是多变，多态而多源的。日耳曼民族、基督教传教士、法国对英语的影响接踵而至。很明显的例子就是日耳曼语中的cow，pig，ox与法语中的beef，pork，mutton。中世纪以来英语特点更是如此，对此也有知识分子持不满态度。</p><blockquote><p>而随着知识分子开始有意识地从拉丁语和希腊语中借用单词来表达英语中原先没有的概念，外来词的数量越来越多。考德里对这种做法感到不悦，他抱怨道：“有些人对于外国化的英语趋之若鹜，却把他们母亲的语言丢到九霄云外。”</p></blockquote><h3 id="人物"><a href="#人物" class="headerlink" title="人物"></a>人物</h3><p>谈及考德里，一下是他的个人简介。</p><p>同情清教的牧师，宣扬平等思想，受教会的排挤。他长期致力于搜集单词，曾出版过指南性著作，在1604年出版了他的简明词汇表。</p><p>致力于维护英语的简洁性到了顽固的地步，重视对常见词的运用，以便受教者能听懂，同时反对英语的外国化。</p><h2 id="字典使用的排序"><a href="#字典使用的排序" class="headerlink" title="字典使用的排序"></a><strong>字典使用的排序</strong></h2><h3 id="字典序"><a href="#字典序" class="headerlink" title="字典序"></a>字典序</h3><p>关于字典序，这种古老而现代的排序方式，书中有这样的论述：</p><blockquote><p>但即便在当时，这种机制在人们看来是不自然的，因为它迫使读者将信息从单词的意义中剥离出来，将单词严格地是为字符串，集中精力于单词的字母组合上。</p></blockquote><p>但当人们接受这种排序方式之后，情况便不一样了。</p><blockquote><p>这样做的效率惊人，因为这种机制可以很容易地扩展到任意规模，并且宏观结构和微观结构一模一样。一个人只要掌握了字母表顺序，就可以丝毫不差地在包含了无论是一千个还是一百万个单词的列表中定位到任意条目，而且在查找过程中无需了解有关单词的意义。</p></blockquote><p>书中还有个巧妙的类比。</p><blockquote><p>从按字母表顺序排列的角度看，单词无非就是一枚枚硬币，可以将其分别投入不同的投币口。</p></blockquote><p>事实上，首份按照字母表编排的目录直至1613年才被制作出来。（但我对印刷的历史并无概念所以不知道这意味着什么）</p><h3 id="“本质序”"><a href="#“本质序”" class="headerlink" title="“本质序”"></a>“本质序”</h3><p>性质接近字典的《尔雅》按照意义将其条目归为不同的主题，埃及人与阿拉伯人则将单词按哲学或教育原则加以组织，对此，作者有言：</p><blockquote><p>这些列表组织的其实不是单词本身，而是整个世界，也就是单词所代表的事物。</p></blockquote><p>莱布尼茨明确区分了这两种排列方式：前者从词到物，而后者从物到词。</p><h2 id="字典面临的难题：意义"><a href="#字典面临的难题：意义" class="headerlink" title="字典面临的难题：意义"></a><strong>字典面临的难题：意义</strong></h2><h3 id="字典释义"><a href="#字典释义" class="headerlink" title="字典释义"></a>字典释义</h3><p>为语言解释意义并不总是件容易的事情，因为这件事本身也要借助语言。</p><blockquote><p>双语词典的目的比单语词典的更为明确，毕竟将拉丁语转化成英语有其价值，而将英语翻译成英语似乎就难以理解了。然而在这里，释义是关键所在。</p><p>我们可以明显看出，他（考德里）在着手编写释义时时心怀警惕的，对于这些释义的可靠性他也并不十分确信。意义甚至比拼写更善变。</p></blockquote><p>简单的释义如同义或是从属关系（a kind of），但有的词的意思很复杂，如vapor，需要运用“三角定义法”。</p><blockquote><p>但仅仅用一个词解释另一个词，不论是同一关系还是种属关系，对于词典编纂者来说，还远远不够。一种词语中单词之间的关系错综复杂(chaos)，这种线性的解释方法根本无法完全应付。</p></blockquote><p>还有其他的难点：抽象单词。</p><blockquote><p>而对于其他表示概念和抽象的单词，因其与感性认识距离更远，考德里需要另寻别的解释方法。他逐渐摸索出了一种方法，即以平实而尽量精炼的语言描述给他的读者。我们可以从中看到他的为难之处，一方面他既要理解某些单词，另一方面还要将他的理解表达出来。</p></blockquote><p>最为棘手的可能是科学中的技术名词。（即便在今日，对它们的解释仍是相当困难的，因为涉及的是不同的语言体系）</p><p>其他的问题也很多，不仅限于单词本身。</p><blockquote><p>不仅是单词，知识也在不断变化，而语言也在时刻进行自我反思。因此，即便在考德里从库特和托马斯哪里照抄东西的时候，从根本上说，他还是在孤军奋战，并没有任何权威可供他咨询。</p></blockquote><p>词典与逻辑也存在着密切的关系：</p><blockquote><p>这时字词必须被当作字词来看待，不同于所代表的事物，代表的只能是其他字词。在20世纪，随着逻辑学的深入发展，这种循环定义的潜在可能性就可谓了一个问题。维特根斯坦就抱怨道……这呼应了三个世纪前牛顿的不满，只是现在的问题更为复杂。</p></blockquote><h3 id="其他释义"><a href="#其他释义" class="headerlink" title="其他释义"></a>其他释义</h3><p>除去编纂字典需要确认意义，推动科学的发展同样需要将单词与意义连接起来。</p><blockquote><p>在当时，科学作为一种探寻自然界及其规律的社会制度还尚未出现，但这时的自然哲学家们已经开始产生对于字句的本质及其意义的特殊兴趣。他们需要比已有字词更贴切的用语。</p></blockquote><p>伽利略发现太阳黑子后首先意识到这里存在一个语言问题（人们一直以来称太阳为“最纯净最清澈之物”），名实不符对思想的冲击。（今天的很多历史遗留也都是错误的，如“阿拉伯数字”这个名头）</p><p>牛顿在开始建筑力学大厦的时候则是使用了障眼法：不去定义时间、空间这些“众所周知”的概念，然而定义它们是他的目的所在。选择“质量”这个词也费了一番功夫，正如书中所说：</p><blockquote><p>可见，没有一个恰当的用语，他就寸步难行。</p></blockquote><h2 id="字典编纂与其中的难题"><a href="#字典编纂与其中的难题" class="headerlink" title="字典编纂与其中的难题"></a><strong>字典编纂与其中的难题</strong></h2><h3 id="早先的字典"><a href="#早先的字典" class="headerlink" title="早先的字典"></a>早先的字典</h3><p>从1613年的考德里，到1616年的布洛卡（他出版了《英语释讲》，较《字母排表》词汇更多），到1656年的布朗特，编写者的认识在不断深化。</p><blockquote><p>他（布朗特）好像已经意识到，自己瞄准的是个活动靶。他在前言中写道，词典编纂者的“工作没有尽头，因为我们的英语具有每天都在变的特性”。布朗特给出的释义比起考德里的要详尽得多，并且他还试图提供词源信息。</p></blockquote><p>虽然开拓者的工作可能有些稚嫩，但这却是有重大意义的。</p><blockquote><p>在最伟大的词典《牛津英语词典》（<em>OED</em>）出版之际，第一版的编辑们却向他那本“薄薄的小册子”致以了敬意。他们称之为“最初的橡籽”，<em>OED</em>这课参天橡树正是从这粒种子成长而来的。</p></blockquote><h3 id="网络时代的OED"><a href="#网络时代的OED" class="headerlink" title="网络时代的OED"></a>网络时代的OED</h3><p>谈到Pluto被除名行星一事对字典的影响，书中的这句话可以和第十四章关于wiki中namespace的论述相映成趣。</p><blockquote><p>从命名的角度看，天上已经快拥挤不堪了。</p></blockquote><p>回到正题。随着网络的发展，传统的字典不能不受到影响。</p><blockquote><p>在他（辛普森，牛津字典编纂组成员）的书桌上，除了单词卡片以外，还有着一根连入英语神经系统的导线。通过这根导线，它可以即时连接上由遍布全球的业余词典编纂者的网络……当词典遇上了互联网，两者都将面貌一新。无论辛普森多么热爱<em>OED</em>的渊源和遗产，也不论他愿意与否，他都正在引领一场革命，改变着<em>OED</em>——它是什么，知道什么，视野如何。考德里是孤军奋战，辛普森则是处于网络之中。</p></blockquote><p><em>OED</em>的目的，一在竭力捕捉语言的流变，二在担负起固化语言的任务。这是非常困难的任务，从丰富多样的拼写，到来源单一的“罕用”词。这期间编辑们反复强调自己只是选择了“当代最常用的拼法”，但仍避免不了武断的决定。</p><p>书中还提到了<em>OED</em>在收录新词等方面的一些历程，这些是趣味性的历史事实，和我们今日的生活也有着千丝万缕的联系，中心思想是关于编辑们对完备性与多样性的追求还有对随意性的否定。</p><h3 id="搜集单词的困难"><a href="#搜集单词的困难" class="headerlink" title="搜集单词的困难"></a>搜集单词的困难</h3><p>从无意识到有意识，初期的词典编纂者充满了雄心壮志。</p><blockquote><p>在考德里，词典是一种历史快照，他的视野无法超出他当时所在的历史阶段。塞缪尔·约翰逊则更为自觉地意识到词典的历史维度，并以此作为理由之一为自己雄心勃勃的计划进行辩护。</p></blockquote><p>Samuel Johnson认为语言曾经是“不受约束”的，故他要把它从无穷无尽的流变中解放出来。</p><blockquote><p>“它（语言）在每一种文学体裁的成长过程中都不可或缺，但它自身却一直以来遭到忽视。它苦于传播过程中的放任自流，以致变得极其纷繁复杂，对于时间和时尚的暴虐也只能逆来顺受，而且还要忍受无知的腐蚀和创新的心血来潮。”</p></blockquote><p>但是，这是非常困难的过程。</p><blockquote><p>直到<em>OED</em>，词典编纂者们才开始试图揭示语言的历史全貌，因而<em>OED</em>成为了一幅历史全景图。进入电子时代后，这项事业的意义愈加彰显无疑。</p></blockquote><p>编纂者开始工作的第一步是寻找单词，并追溯其历史演化。最初的编辑们认为声望卓越而品质出众的书籍是词汇不言而喻的来源，他们征集读者将曾经的作品阅读完毕以将单词一网打尽。他们认为这片领域虽然辽阔，但还是有疆界的，故而有着一一梳理的勇气。</p><blockquote><p>但到了现在，它似乎不再是有限的了。词典编纂者们开始接受语言是无界的事实。他们熟知默里的一句名言：“英语之圆有清晰明确的中心，但没有可以辨识的圆周。”在中心的是那些无人不知的单词。而在边缘，默里认为是俚语、黑话、科学术语以及外来词，对此每个人的认识都各不相同，并且没有一个人的认知可以被认作“标准”。</p></blockquote><p>遗憾的是，默里认为“清晰明确的”中心地带实则也存在着无限性和模糊性。认识到这一点的Samuel Johnson采取的是投降的策略。</p><blockquote><p>但人类的语言世界总会有与世隔绝的地方。一个山谷里讲的语言与相邻山谷里的多少有所差别。而现在尽管山谷之间已经不像以前那样封闭，但山谷的数目却比以往要多。</p><p>如果词典编纂者用以监听语言的耳朵的灵敏度真的有一个极限，那么现在人们也没有找到这个极限所在。</p></blockquote><h3 id="网络时代的词汇"><a href="#网络时代的词汇" class="headerlink" title="网络时代的词汇"></a>网络时代的词汇</h3><p>词汇的增长常常是爆炸式的，科技等领域的发展就是一个明显的原因。词汇的发展源于需求的增长，而一些需求是细胞分裂式的，而另一些则比较微妙。Mondegreen（与网络用于“空耳”有相似）一词就有其历史的缘由：这是一份相当古老的经验，但直至歌曲普及开来以前都不会进入词典（是的，这也是meme）。其他的共同经验，大抵也是如此。（故而语言的未来，在我看来，是非常难以预判的）</p><p>词汇增长的复杂度并非是多项式程度的，也没有很好的计量方式。即便是编纂者不断提高新词入选的门槛，这仍然是一项复杂得可怕的工作。</p><blockquote><p>词汇是对共同经验的一种量度，而后者始于互连通性。在四个世纪里，说英语的人从五百万激增至十亿，但更重要的动力来自这些使用者之间以及当中存在的连接数量。数学家会说，信息不是以几何方式增长，而是以组和方式增长，后者的增长速度远快于前者。</p></blockquote><p>关于词汇，让我们以对它的分析结束这一章吧。</p><blockquote><p>全体单词的集合，也就是词汇，构成了语言的一个符号集。一方面，这是个基础性的符号集，因为按此对于任何一门语言来说，都是可识别的最小的意义单元，而且得到了该语言使用者的普遍认同。但另一方面，它又远不是基础性的，因为随着传播技术的发展，语言中的讯息可以采用比其小得多的符号集加以分解、编码和传输，比如字母、点和划、鼓声的高和低等。这些符号集是离散的，而词汇不是，它更加无序，而且在不断膨胀。事实上，词典编纂被证明是一门不适合精确计量的科学。据说英语这门最庞大、最普遍使用的语言，粗略估计拥有将近一百万个意义单元，但语言学家自己没有什么专门的标尺，将他们试图量化新单词出现的速率时，他们也倾向于向词典寻求帮助。然而，即使是最好的词典也试图逃避这样的责任，毕竟词与非词之间的边界总是模糊的，从中无法划出一条清晰的界线。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h2><p>章节中的一些部分可以和前面的章节或是后面的章节结合起来阅读，此处仅就“两本字典”作结。</p><h3 id="考德里的字典"><a href="#考德里的字典" class="headerlink" title="考德里的字典"></a>考德里的字典</h3><p>①主要是自发的，受社会条件支配</p><p>②在“确认意义”这方面做出了一些尝试</p><p>③采用字典序这一有力的排序方式</p><h3 id="约翰逊字典与OED"><a href="#约翰逊字典与OED" class="headerlink" title="约翰逊字典与OED"></a>约翰逊字典与OED</h3><p>①主要是自觉的，认识到了规范语言的必要性</p><p>②认识到了规范与记录语言的困难之大，采取了不同的对策，达到了不同的效果</p><h3 id="其他论述"><a href="#其他论述" class="headerlink" title="其他论述"></a>其他论述</h3><p>①网络时代词汇量的增长与社会条件相关，以组和方式增长</p><p>②语言并非一个足够离散足够基础的符号集，故编纂词典并不是门可精确计量的科学</p><p>③语言并非“有序”的，其中心同边界一样不确定而会膨胀</p><p>④科学的发展首先需要解决语言的问题（林奈的工作也可以看作这点的例证）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
