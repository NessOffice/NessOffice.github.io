<html>
  <head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  
    <link rel="icon" href="/images/logo.jpg">
  
  <title>Ness</title>
  <link rel="stylesheet" href="/css/styles.css">
  <script src="/lib/jquery.js"></script>
  <link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css">
  <script src="/js/common.js"></script>
  <script src="/lib/bootstrap/js/bootstrap.js"></script>
  <link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

  <body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><header class="header">
  <div class="color-bar">
    <ul>
      <li class="bar1"></li>
      <li class="bar2"></li>
      <li class="bar3"></li>
      <li class="bar4"></li>
      <li class="bar5"></li>
      <li class="bar6"></li>
    </ul>
  </div>
  <div class="header-wrapper">
    <div class="blog-title">
      
        <img class="logo" src="/images/logo.jpg" alt="logo">
      
      <a href="/" class="title">Ness</a>
    </div>
    <nav class="navbar navbar-menu">
      <div class="container-fluid">
        <div class="navbar-header">
          <button type="button" id="nav-btn" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
        </div>
      </div>
        <ul class="menu menu-pc">
          
            <li class="menu-item">
              <a href="/" class="menu-item-link"><i class="fa fa-home"></i><span>首页</span></a>
            </li>
          
            <li class="menu-item">
              <a href="/tags/" class="menu-item-link"><i class="fa fa-tags"></i><span>标签</span></a>
            </li>
          
            <li class="menu-item">
              <a href="/archives/" class="menu-item-link"><i class="fa fa-file"></i><span>归档</span></a>
            </li>
          
            <li class="menu-item">
              <a href="https://github.com/NessOffice" class="menu-item-link"><i class="fa fa-github"></i><span>GITHUB</span></a>
            </li>
          
        </ul>
    </nav>
  </div>
</header>
<div class="collapse nav-collapse" style="position:fixed;top:59px;" id="bs-example-navbar-collapse-1">
  <ul class="menu menu-mobile" style="list-style:none">
    
      <li class="menu-item">
        <a href="/" class="menu-item-link"><i class="fa fa-home"></i><span>首页</span></a>
      </li>
    
      <li class="menu-item">
        <a href="/tags/" class="menu-item-link"><i class="fa fa-tags"></i><span>标签</span></a>
      </li>
    
      <li class="menu-item">
        <a href="/archives/" class="menu-item-link"><i class="fa fa-file"></i><span>归档</span></a>
      </li>
    
      <li class="menu-item">
        <a href="https://github.com/NessOffice" class="menu-item-link"><i class="fa fa-github"></i><span>GITHUB</span></a>
      </li>
    
  </ul>
</div>

    <main class="main">
      <div class="content">
        
  <article class="post">
    <div class="post-title">
      <h2 class="title">【图灵之路】CF记-其四（2019-08-05更新）</h2>
	  <div style="margin: 0 10 20px;">
		<span class="post-count">
		  <span class="post-meta-item-icon">
			<i class="fa fa-keyboard-o"></i>
			<span class="post-meta-item-text">  字数统计: </span>
			<span class="post-count">2.3k字</span>
		  </span>
		</span>

		<span class="post-count">
		  &nbsp; | &nbsp;
		  <span class="post-meta-item-icon">
			<i class="fa fa-hourglass-half"></i>
			<span class="post-meta-item-text">  阅读时长: </span>
			<span class="post-count">9分</span>
		  </span>
		</span>
	  </div>
       
        <p>计算机</p>
      
    </div>
     <div class="post-meta">
      <span class="post-time">2019-08-05</span>
    </div>
    <div class="post-content">
      <h1 id="round-577-div2"><a href="#round-577-div2" class="headerlink" title="round #577 div2"></a>round #577 div2</h1><p>关键词：造数据，正确的思路与错误的程序，证明算法的正确性</p>
<p>休息了若干天重新捡起cf……<a href="https://codeforces.com/contest/1201" target="_blank" rel="noopener">这场</a>做得还是相对顺利的，ABC过得相对比较快。E是个毒瘤题没啥人做，所以决胜的关键就在D上了。</p>
<p>从时间的分配上看，我在对BC正确性不太确定的情况下在40min内搞出了BC，花了20min想出了D的突破点并写了伪代码。但还是花了40min才码完D，而且对初始情况的处理不是很到位，有一处地方还写错了，以至怎么改交上去都是WA。</p>
<p>这题，一如之前做到的一些题，码量稍大，程序略复杂，而我在这种情况下便容易出错。</p>
<p>如何解决码力低下的问题呢？首先是要提高思绪转化为程序时对细节的考虑，而我在这上面做得还比较模糊。</p>
<p>再来是造数据，虽然这题比较良心，样例指出了我的一些错误，但还是有错没被指出。</p>
<p>当然，这两种能力是比较软的，应结合具体题目，比如这次的B，D，在实践中提升自己的能力，而不能光说说而已呀。</p>
<h2 id="AC"><a href="#AC" class="headerlink" title="AC"></a>AC</h2><p>A题就排个序，C题扫一遍模拟（答案是二分验证的，但还是模拟来得快，虽然程序稍微复杂了点，而且要分类讨论可能会写错）。</p>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>题意：有n堆石子，每次可以选两堆（有石子的堆）使这两堆的石子数-1。问能否找到一种操作使全部堆在操作完后石子数均为0。</p>
<p>做的时候我是这么考虑的：操作中的一个不变量显然是石子数的奇偶性，那么先判一下sum的奇偶，只考虑石子数为偶数的情形。再来怎么考虑呢？先把所有石子排一下序好了，如果最高的那堆特别高，比剩下所有的加起来都高，这样的情况也是不行的。那么剩下的情况都可行吗？我随便造了点数据感受了一下，感觉实际的做法就是构造“等高堆”，先把最高的一堆夷到和第二高的那样平，然后再用这两堆来把剩下的堆夷平……（比如2 6 12 14的话，就可以先把14给夷成12，这样操作后是2 4 12 12。然后用两个12把4给夷成2，就是2 2 11 11，两两相等，可行）虽然我描述不出算法的细节，但直觉告诉我这样做是对的，而且这题作为B题不应该考虑那么多。试了一试，哎，AC。此时比赛过去约20min。</p>
<p>其实正确性的证明也便是和上面的步骤相似的：①用前面所有的堆来削最大的那堆直至它和第二大的堆等高。②这样削完之后，前面n-2堆（可能会少于n-2，因为有的堆没了）内部任意消化，③消化到不能再消化再用剩下两堆一起补，因为这两堆加起来比前面n-2堆高（这个结论我并不会证，但感受它还是较容易地。①中每次贪心地操作最高的堆，②中就有尽可能多的堆被消化。然后对于奇数堆的情形，比如2 2 2，我们是同时把他们变为0 0 0而不是变为0 0 2），而且前面n-2堆的和是整数，所以必然能够补完。④最后两堆相等，做完了。</p>
<p>个人感觉这个老哥的解释挺不错，放上来（作者是owneriekno1）：</p>
<blockquote>
<p>Here is another way to think about it.</p>
<p>Consider 2 cases:</p>
<p>①Base case: the largest element is equal to the sum of all the others:</p>
<p>Let’s  say that each element of the array represents the number of marbles of a  given color. We can take 2 bowls. On the 1st, we put all the marbles of  the largest number, while on the 2nd we put all the remaining ones. On  each operation, we can take one marble from both of them. As they  contain the same number of marbles, they will become empty at the same  time and we are finished!</p>
<p>②Second case: the sum is bigger than the largest element:</p>
<p>We  will try to reduce this to the above case! Again, we fill the bowls  with the same way. The difference is that now the 2nd bowl has more  marbles. To solve this, we can begin picking pairs from it until they  are equal! Note that, as the sum is an even number, the parity of the  number of marbles on each bowl is the same (ie. both odd or both even).  That guarantees us that we will 100% reach a point that they are equal!</p>
</blockquote>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>题意：你在一个n×m的棋盘上。棋盘的一些地方做了标记，你需要经过这些地方。开始你在(1, 1)处。往左右走没有限制，但你只能向上走而不能向下走，而且只能沿着一些column向上走。</p>
<p>既然左右走没有限制，那么可以把问题分层考虑。第一层很明显只有走到最右边的标记点这样一种路径。但之后该如何向第二层转移呢？从哪个safe column上去？上去之后又怎么向第三层走？这样看起来，问题似乎很复杂。</p>
<p>但我们要注意到，在每一层的最终位置，只可能是最左边的标记点，或是最右边的标记点。如此一来，我们便可以dp了。令$dp[i][0]$表示走到第i层最左边标记点所用的最短步数，$dp[i][1]$表示走到第i层最右边标记点所用的最短步数。</p>
<p>然后状态怎么转移呢？注意到，$dp[i][0]$只可能由$dp[i-1][0]$或是$dp[i-1][1]$转移而来。从$dp[i-1][0]$到$dp[i][0]$，这个转移的含义就是从第i-1层最左边，沿一条safe column到达第i层，先到第i层最右边，再到第i层最左边。</p>
<p>那么怎么找safe column才能使到最右边的步数最少呢？画个图就很清楚了，沿某一些safe column上去步数是等价的，而沿另一些safe column上去步数则会增加。经分析，我们需要记录第j列左边最右边的safe column：$lft \  col[j]$，还有它右边最左边的safe column。这样之后还要写个函数$fun(LL \  col1, LL \ col2)$计算从第col1列到第col2列在水平方向上所花费的最小步数。</p>
<p>这样就好了吗？并没有。如果有些层没有标记点怎么办？那么我们便跳过它。这样一来，我们可以维护一个$up$值，然后转移就是从第i层转移到第i+up层，中间的层都是没有标记的。</p>
<p>这样一来程序的大框架就有了。答案也便是$min(dp[n][0], dp[n][1])$（是的，即便第n层没有标记点答案也是这个）。我们要记录哪些数据呢？要记录每层最左/最右的标记点$lft[i]$还有$rgt[i]$；要记录$lft \  col[j]$还有$rgt \  col[j]$，而要记录这两项就要记录$safe \  col[maxn]$。除此之外也没什么要记录了，这题也可以做了。</p>
<p>下面记录一下坑点：首先如果第一行没有东西的话，$rgt[1]$要置为1。而且首先$lft[1]$要特殊处理，改成$rgt[1]$。我并没有关注太关注第一行的特殊处理，以致状态转移方程里面有这样一个隐蔽的错误。</p>
<p>还有是fun函数的处理，要关注column j左右有safe column，没有safe column的情形。画个图把情况罗列一下，思路更清晰。我这里又搞错掉了，对样例的时候发现。</p>
<p>然后$lft \  col[j]$是可能取到j的。我一开始设为不可能，以致跑样例都出错。</p>
<p>最后的最后！我的状态转移方程写错了！本应是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[now][<span class="number">0</span>] = dp[now][<span class="number">1</span>] = up + (rgt[i] - lft[i]);</span><br><span class="line">dp[now][<span class="number">0</span>] += min(dp[now^<span class="number">1</span>][<span class="number">0</span>] + fun(lft[i-up], rgt[i]), dp[now^<span class="number">1</span>][<span class="number">1</span>] + fun(rgt[i-up], rgt[i]));</span><br><span class="line">dp[now][<span class="number">1</span>] += min(dp[now^<span class="number">1</span>][<span class="number">0</span>] + fun(lft[i-up], lft[i]), dp[now^<span class="number">1</span>][<span class="number">1</span>] + fun(rgt[i-up], lft[i]));</span><br></pre></td></tr></table></figure>
<p>然后我写成了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[now][<span class="number">0</span>] = dp[now][<span class="number">1</span>] = up + (rgt[i] - lft[i]);</span><br><span class="line">dp[now][<span class="number">0</span>] += min(dp[now^<span class="number">1</span>][<span class="number">0</span>] + fun(lft[i-up], lft[i]), dp[now^<span class="number">1</span>][<span class="number">1</span>] + fun(rgt[i-up], lft[i]));</span><br><span class="line">dp[now][<span class="number">1</span>] += min(dp[now^<span class="number">1</span>][<span class="number">0</span>] + fun(lft[i-up], rgt[i]), dp[now^<span class="number">1</span>][<span class="number">1</span>] + fun(rgt[i-up], rgt[i]));</span><br></pre></td></tr></table></figure>
<p>对此样例就不能帮上忙了，因为样例中每层都只有一个。</p>
<p>所以我应该如何反思呢？一方面是要强化程序正确性上的证明，不能老写塑料算法（虽然这次BC两个塑料算法都对了），加强从思绪到程序上的转化，不能被传输错误坑。但这些，很难避免。较为容易做到的是造数据，造出更强的能够检验各个细节正确性的数据。虽然lft，rgt这个数据比较难造也比较难判断对错，但跟着它跑一遍还是必要的，因为这样可以发现很多问题。我在造数据上还是太懈怠了，没有分析哪些地方可能出错需要检验，否则怎么会没有妥善处理第一层的特判呢？</p>
<hr>
<p>初稿写于2019.06.04</p>
    </div>
  </article>
  <div class="post-nav">
    <div class="post-nav-next post-nav-item">
      
        <a href="/2019/08/03/Notes-Complex_Function-CH02/" rel="next" title="【数学之美】复变函数与拉普拉斯变换-金忆丹版：第二章 解析函数">
          <i class="fa fa-chevron-left"></i> 【数学之美】复变函数与拉普拉斯变换-金忆丹版：第二章 解析函数
        </a>
      
    </div>

    <span class="post-nav-divider"></span>

    <div class="post-nav-prev post-nav-item">
    
        <a href="/2019/08/07/Project-MenShenJuanGu/" rel="prev" title="【通天之塔】游戏设计5：记《门神眷顾》，及开发过程的的心路历程">
          【通天之塔】游戏设计5：记《门神眷顾》，及开发过程的的心路历程 <i class="fa fa-chevron-right"></i>
        </a>
      
    </div>
  </div>



      </div>
        <div class="footer">
  <div class="footer-wrapper">
    <div class="copyright">
      
      <span>&copy;</span>
      
      <span>2019</span>
      
      <span class="author"><i class="fa fa-user"></i>Ness</span>
    </div>
    
      <span>由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</span>
    
    
      <span>|</span> <span>主题 - <a href="https://github.com/littleee/corazon">Corazon</a></span>
      
        <span>v1.0.0</span>
      
    
  </div>
</div>

    </main>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
