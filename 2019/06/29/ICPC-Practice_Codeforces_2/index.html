<html>
  <head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  
    <link rel="icon" href="/images/logo.jpg">
  
  <title>Ness</title>
  <link rel="stylesheet" href="/css/styles.css">
  <script src="/lib/jquery.js"></script>
  <link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css">
  <script src="/js/common.js"></script>
  <script src="/lib/bootstrap/js/bootstrap.js"></script>
  <link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

  <body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><header class="header">
  <div class="color-bar">
    <ul>
      <li class="bar1"></li>
      <li class="bar2"></li>
      <li class="bar3"></li>
      <li class="bar4"></li>
      <li class="bar5"></li>
      <li class="bar6"></li>
    </ul>
  </div>
  <div class="header-wrapper">
    <div class="blog-title">
      
        <img class="logo" src="/images/logo.jpg" alt="logo">
      
      <a href="/" class="title">Ness</a>
    </div>
    <nav class="navbar navbar-menu">
      <div class="container-fluid">
        <div class="navbar-header">
          <button type="button" id="nav-btn" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
        </div>
      </div>
        <ul class="menu menu-pc">
          
            <li class="menu-item">
              <a href="/" class="menu-item-link"><i class="fa fa-home"></i><span>首页</span></a>
            </li>
          
            <li class="menu-item">
              <a href="/tags/" class="menu-item-link"><i class="fa fa-tags"></i><span>标签</span></a>
            </li>
          
            <li class="menu-item">
              <a href="/archives/" class="menu-item-link"><i class="fa fa-file"></i><span>归档</span></a>
            </li>
          
            <li class="menu-item">
              <a href="https://github.com/NessOffice" class="menu-item-link"><i class="fa fa-github"></i><span>GITHUB</span></a>
            </li>
          
        </ul>
    </nav>
  </div>
</header>
<div class="collapse nav-collapse" style="position:fixed;top:59px;" id="bs-example-navbar-collapse-1">
  <ul class="menu menu-mobile" style="list-style:none">
    
      <li class="menu-item">
        <a href="/" class="menu-item-link"><i class="fa fa-home"></i><span>首页</span></a>
      </li>
    
      <li class="menu-item">
        <a href="/tags/" class="menu-item-link"><i class="fa fa-tags"></i><span>标签</span></a>
      </li>
    
      <li class="menu-item">
        <a href="/archives/" class="menu-item-link"><i class="fa fa-file"></i><span>归档</span></a>
      </li>
    
      <li class="menu-item">
        <a href="https://github.com/NessOffice" class="menu-item-link"><i class="fa fa-github"></i><span>GITHUB</span></a>
      </li>
    
  </ul>
</div>

    <main class="main">
      <div class="content">
        
  <article class="post">
    <div class="post-title">
      <h2 class="title">【图灵之路】CF记-其二（2019-06-29更新）</h2>
	  <div style="margin: 0 10 20px;">
		<span class="post-count">
		  <span class="post-meta-item-icon">
			<i class="fa fa-keyboard-o"></i>
			<span class="post-meta-item-text">  字数统计: </span>
			<span class="post-count">5.5k字</span>
		  </span>
		</span>

		<span class="post-count">
		  &nbsp; | &nbsp;
		  <span class="post-meta-item-icon">
			<i class="fa fa-hourglass-half"></i>
			<span class="post-meta-item-text">  阅读时长: </span>
			<span class="post-count">22分</span>
		  </span>
		</span>
	  </div>
       
        <p>计算机</p>
      
    </div>
     <div class="post-meta">
      <span class="post-time">2019-06-29</span>
    </div>
    <div class="post-content">
      <h1 id="round-567-div2"><a href="#round-567-div2" class="headerlink" title="round #567 div2"></a>round #567 div2</h1><p><a href="https://codeforces.com/contest/1181" target="_blank" rel="noopener">戳我做题</a></p>
<p>（总算，分又升回来了。虽然还是刚进来的水平……）</p>
<p>A题是个还不错的签到题，让我想了一小会。对于第二问，在模的意义下思考可能更容易想。</p>
<p>B题……见着大数就烦。思路很简单，但是代码并不容易写。把数位的存储顺序弄乱了，捣鼓了半个多钟头。之后用python又写了一遍，还是python优雅呀。</p>
<p>C题当时看着有些烦，不过想了想感觉还是能做的。分析的思路就是从分析width=1的flag要满足什么条件，再到分析flag的width更长时答案怎么算。简单的预处理即可。</p>
<p>然后要注意这题的一个大坑点……预处理完一段颜色的len中，得到可能的flag中每段的长度为len1, len2, len3，注意构成flag的条件是len1==len2&amp;&amp;len3&gt;=len2而非len1==len2==len3！为什么？因为最后一段不需要完整。</p>
<p>（不会做，D题鸽）</p>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>这题的代码不难（easy version），但并不好想，或许可以锻炼思维能力吧。</p>
<p>思考一下题目中怎样能把两个territory merge在一起呢？就是它们要有一条公共边，横或纵。我们把只包含一个castle的territory或是由多个按上述规则merge而来的territory称为good。那么，如果一个大的territory能够通过一条横/纵的边分为两个good territory，则这个territory则good……</p>
<h1 id="round-568-div2"><a href="#round-568-div2" class="headerlink" title="round #568 div2"></a>round #568 div2</h1><p><a href="https://codeforces.com/contest/1185" target="_blank" rel="noopener">戳我做题</a></p>
<p>A排序一下，然后容易证明左右两点向外扩展能够得到最优解。</p>
<p>B的话原文中的一个字母可以得到若干位相同的字母，于是可以把同一类的原文划为一组……</p>
<p>C是贪心的思路，首先把占时长的人都筛掉。于是我一开始就维护了两个堆，一个大顶堆一个小顶堆，两个堆之间元素换来换去，于是就T了……连总时长大于M的情况都没筛。</p>
<p>但是根据此题的特点，$0 &lt; t_i \leq 100$，直接遍历即可，根本不需要维护堆。而且这样和桶排的思想也很类似，怪我没想到桶排咯……</p>
<p>D这题略恶心，因为有个干扰项，如何把这个干扰项去掉呢？我们关注公差d。如果d是a0，a1的距离，那么下面的判断就很方便了。如果不是，要么a0是干扰项，要么a1是干扰项，特判一下后面的距离是否均为d即可。</p>
<p>特判完后得到d为a0a1距离，怎么找出干扰项ak呢？注意到，$a_{k-1}a_k \not = d$，然后就好啦。注意一下细节。</p>
<h2 id="E-1"><a href="#E-1" class="headerlink" title="E"></a>E</h2><p>题意是给定一个矩阵，每次可以在上面画一条蛇，也就是任取一块$1 \times c$或是$r \times 1$的区域标上字母：a, b, c…画蛇是没有限制的，也就是可以在有字母的区域上标上新的字母。然后给定一张已经按照a, b, c…顺序画出蛇来的矩阵，问能否从中反推出每次画的蛇的坐标（r1, c1, r2, c2）。</p>
<p>考虑反推的思路，看矩阵中最大的元素，比如说，’d’。它必得连续地占据一行或是一列，如不然，矛盾。那么，如何判断它是否连续地占据了一行呢？首先，它必然只占了一列。于是，可以设col_occupied[maxn]和num_of_col_occupied来判断它占了几列，占了哪几列。如果它只占了一列，那么可以再遍历出它在这一列中row最小的行r1与row最大的行r2（这也正是所需输出的）。然后，从r1遍历至r2，即可判断’d’在此行中是否连续。</p>
<p>这样最大的元素可以确定了，那么第二大的元素，’c’怎么确定呢？不同于’d’在矩阵中出现的必然性（由’d’的最大性可得），’c’不一定会出现在矩阵中，因为它们可能都被’d’覆盖掉了，这样输出r1[‘c’] = r1[‘d’]即可。这是一种情况，至于’c’出现在矩阵中的情况，可以用类似判断’d’是否连续占据一行/一列的方法判断’c’是否只占据了一行/一列。</p>
<p>但是’c’不一定连续。因为比如’c’是横的，’d’是纵的，’d’可以覆盖部分的’c’。同时，我们在之前的操作中不能把’d’简单地替换为字母序更小的字母，这样很容易造成结果的错误。那么，如何处理呢？</p>
<p>比如说，’c’至占据了一列，其所出现的row最小的行行号r1，row最大的行行号r2。在[r1, r2]间出现了不是’c’的字母，有两种情况。第一种，无法从该矩阵中还原出蛇的画法。第二种，这个字母本来是’c’，但是被覆盖了。注意覆盖它的字母只能是字母序比它大的字母。</p>
<p>然后至于更小的字母，跟上面的处理方法是相似的。</p>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><p>考虑单个pizza，怎么判断它能否please多少人呢？比如ingredient为1，3，5，那么可以将这个pizza编码为一个price = price, bitinfo = 000010101, index = index的node，这样的node至多1&lt;&lt;9个，因为碰到bitinfo相同的pizza可以只取price更小的。bitinfo和pleasures的关系又如何呢？比如一个friend喜欢的ingredient可以编码为000000101。那么上面这个pizza就可以please他。两个pizza的话，考虑两个bitinfo取&amp;即可。</p>
<p>这样本来的枚举量是m^2，现在只是(1&lt;&lt;9)^2了，计算量少了好多呀！这都是bitinfo去重的功劳。虽然枚举量大大减小了，但怎么确定这种组和较另一种更优呢？首先是看pleasures的数目，这需要预处理每一种bitinfo所能please的人数，而这可以在读入每个人的时候处理</p>
<h1 id="round-569-div2-鸽"><a href="#round-569-div2-鸽" class="headerlink" title="round #569 div2(鸽)"></a>round #569 div2(鸽)</h1><p><a href="https://codeforces.com/contest/1180" target="_blank" rel="noopener">戳我做题</a></p>
<p>（第一套补完的题……留念）</p>
<p>A……嗯……很可爱，很纯真，在这样险恶的世界里是存活不了几分钟的……</p>
<p>B：给你一个数列{a}，可以把每位a[i]替换为-a[i]-1，问怎样替换能使得$\prod a_i$最大。</p>
<p>yy一下，负数的绝对值更大，所以负数越多越好。如果n为偶数，全部为负就好。n为奇数的话，至多保留一个正数，取绝对值最大的maxv还是最小的minv呢？（先把所有数都转为负数，方便讨论）把全部数乘一块，记作pi，把maxv转换为-maxv-1后|pi’| = |pi / maxv * (maxv-1)|，把这个式子和把minv转换的式子对比一下，带个值进去，就能发现转换maxv能得出更优解。</p>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>给定双端队列，给定操作：将首位元素与第二位元素出队，将较大元插在队首，较小元插在队尾。问k次操作后队首前两个元素。</p>
<p>显然，队首元素单调不减，而最大元被垒到队首之后，操作等价于在把后n-1个元素形成的队列中的队首放到队尾，可以用模运算模拟。前面模拟的步数不超过n，用链表实现复杂度为$O(n)$。</p>
<p>P.S.deque真快，还不用特判，爱了爱了。</p>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>给你n*m的矩阵，你一开始在(1, 1)这个位置，每次可以用(dx, dy)跳一跳，比如(dx = 2, dy = 3)，就能从(1, 1)跳到(3, 4)了。每个(dx, dy)跳了一次就不能再跳了，比如你不能一直(-1, 0)这么跳。问你能否跳过所有点一遍。</p>
<p>找规律试试？考虑1*m的矩阵，怎么跳呢？因为不能一路(0, 1)，我们需要找到有规律的跳法。考虑$(1, 1) \rightarrow (1, m) \rightarrow (1, 2) \rightarrow (1, m-1) \rightarrow …$，这种跳法是可行的，它好在哪里呢？它对于一些难以用到的(dx, dy)的利用率高，一开始的$(0, m-1)$显然只能用一次，后面的也一样（其实是化归到子问题了，把(1, m)这样一个问题化归到(1, m-1)了，只是翻折了一下）。</p>
<p>于是对于n*m的矩阵我们也能遵循类似的跳法：$(1, 1) \rightarrow (n, m) \rightarrow (1, 2) \rightarrow (n, m-1) \rightarrow …$。（不过这样的话，每一步无法化归到子问题，只有遍历完两行后才算是化归到子问题）注意对奇偶分类讨论。</p>
<h2 id="E-2"><a href="#E-2" class="headerlink" title="E"></a>E</h2><p>有一个食堂，里面有n道菜，每道价格不一样，每道只有一样。有m个学生，各有bi块钱。学生买菜的策略是，总是买他买得起的最贵的菜。然后题目有q次询问，每次可以改变一道菜的价格或者一个学生的金钱数。问改变之后所有学生买完菜后，剩下的最贵的菜的编号。</p>
<p>（什么鬼食堂，每道菜只有一样，菜的价格还能差个几千几千的。学生也挺牛逼，每次只买一样菜。这很不社会主义啊。）</p>
<p>首先，题目中提到了学生是排着队买的，但通过yy我们能够知道，不论学生的顺序如何，他们全体买的菜都是那几样（个体在调整顺序后买到的菜可能会发生变化）。我们想想能否二分答案：从0-maxn中，最贵的还没有买的菜的价格是多少？这样的区间查询要怎么进行呢？我们可以搞个线段树，第i棵树上搞个标记，学生有i块钱就-1，存在有i块钱的菜就+1。如果标记&gt;0，就说明有菜剩着。这样进行区间修改也比较方便。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, q, a[maxn], b[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span><span class="keyword">int</span> l, r, v, lazy;&#125;tree[<span class="number">4</span>*maxv];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[index].l = l;</span><br><span class="line">    tree[index].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    build(index &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    build((index &lt;&lt; <span class="number">1</span>)+<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> target, <span class="keyword">int</span> mark)</span> <span class="comment">// mark == 1 ? meal : pupil</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[index].r &lt;= target)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[index].v += mark;</span><br><span class="line">        tree[index].lazy += mark;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    down(index);</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[index].l + tree[index].r) / <span class="number">2</span>;</span><br><span class="line">    change(index &lt;&lt; <span class="number">1</span>, target, mark);</span><br><span class="line">    <span class="keyword">if</span>(target &gt; mid)</span><br><span class="line">        change((index &lt;&lt; <span class="number">1</span>)+<span class="number">1</span>, target, mark);</span><br><span class="line">    tree[index].v = max(tree[index&lt;&lt;<span class="number">1</span>].v, tree[(index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>].v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(tree[index].l != tree[index].r)</span><br><span class="line">    &#123;</span><br><span class="line">        down(index);</span><br><span class="line">        <span class="keyword">if</span>(tree[(index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>].v &gt; <span class="number">0</span>)</span><br><span class="line">            index = (index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            index &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (tree[index].v &gt; <span class="number">0</span>) ? tree[index].l : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, maxv<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a+i);</span><br><span class="line">        change(<span class="number">1</span>, a[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, b+i);</span><br><span class="line">        change(<span class="number">1</span>, b[i], <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cmd, i2, x, *c, mark;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;cmd, &amp;i2, &amp;x);</span><br><span class="line">        c = (cmd == <span class="number">1</span>) ? a : b;</span><br><span class="line">        mark = (cmd == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        change(<span class="number">1</span>, *(c+i2), -mark);</span><br><span class="line">        *(c+i2) = x;</span><br><span class="line">        change(<span class="number">1</span>, *(c+i2), mark);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ask());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[index].l == tree[index].r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[index].lazy == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[index].l + tree[index].r) / <span class="number">2</span>;</span><br><span class="line">    change(index &lt;&lt; <span class="number">1</span>, mid, tree[index].lazy);</span><br><span class="line">    change((index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>, tree[index].r, tree[index].lazy);</span><br><span class="line">    tree[index].lazy = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="round-570-div3-鸽"><a href="#round-570-div3-鸽" class="headerlink" title="round #570 div3(鸽)"></a>round #570 div3(鸽)</h1><p><a href="https://codeforces.com/contest/1183" target="_blank" rel="noopener">戳我做题</a></p>
<p>（水题好多，在细节上处理地不是很好以致没有一发ac。不知假如参加的话能不能把E/H苟出来）</p>
<p>A：计算比给定数大的，最小的，满足各数位上的数之和模4余0的数。</p>
<p>这题注意一下数据范围，无需特判，枚举即可……</p>
<p>B：给定一个数列{a}还有一个数k，问能否将所有a[i]替换为b使得$|a_i - b| \leq k$。</p>
<p>开始想的是二分，但之后发现检测一下上界取不取得到就好了……</p>
<p>C：你有n格电，每次可以消耗a格并爽一爽或者可以消耗b格但不能爽，已知有k个回合，问你最多能爽几爽。</p>
<p>贪心地把尽可能多的B换成A就好了，不过要注意数据范围！int的话中间可能会溢出，这是个隐蔽的坑点。</p>
<p>D：你有若干种糖，每个个数不一。然后你要送礼，每种糖的个数不能一样，问你最多能送出多少糖。</p>
<p>用个map处理一下，一波遍历，就好惹（但在G上栽了，细节没考虑全？不是很想补……）。</p>
<p>F：给你n个数，让你选1个或2个或3个，使得选出来的数两两不能整除，求这1/2/3个数的和的最大值。</p>
<p>莫得思路（对剪枝的复杂度不太明白就没写，网友的思路看不懂）。</p>
<h2 id="E-H"><a href="#E-H" class="headerlink" title="E/H"></a>E/H</h2><p>题意可以理解为给定字符串，让你求它的长为n, n-1, n-2…的subsequence（不要求连续，比如’acd’是’abcd’的合法子串）有多少个（其实不需要求出全部，求出长为n, n-1, …直至k的子串数目就行了，这里的k不同于题目中的k）。</p>
<p>枚举组和再判重复杂度看上去大得可怕，我们考虑dp。令$dp[length][char]$表示长度为length，末尾字符为char的子串的数目（这样无法表示空字串，所以要记得特判）。这样就能递推了：顺序遍历给定字符串，读到一个新的字符ch时，若它在第k位，枚举$length = k \rightarrow 1, char = a \rightarrow z$即可。记得length得倒序遍历。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LL ch_tail = str[i];</span><br><span class="line"><span class="keyword">for</span>(LL len = i<span class="number">-1</span>;len &gt;= <span class="number">1</span>;len--)</span><br><span class="line">&#123;</span><br><span class="line">	dp[len+<span class="number">1</span>][ch_tail] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(LL ch = <span class="number">0</span>;ch &lt; <span class="number">26</span>;ch++)</span><br><span class="line">		dp[len+<span class="number">1</span>][ch_tail] += dp[len][ch];</span><br><span class="line">&#125;</span><br><span class="line">dp[<span class="number">1</span>][ch_tail] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>需要说明的是，长为k的子串在数量级上与$C^k_n$较为接近，而题目中的n可大至100，这样k=50时dp不是会溢出吗？然而事实是上述代码能够ac。私以为，问题在于dp是通过加法递推得到的，可以看作计算机在运算时进行了模处理，这样中间虽然可能出现负数，但是在边界值上仍然是正确的。如果对此感到不放心，不妨对dp取模，这样更保险些。</p>
<h1 id="round-571-div2-鸽"><a href="#round-571-div2-鸽" class="headerlink" title="round #571 div2(鸽)"></a>round #571 div2(鸽)</h1><p><a href="https://codeforces.com/contest/1186" target="_blank" rel="noopener">戳我做题</a></p>
<p>（A是什么东西，现在签到题都这么送的吗？？？）</p>
<p>（B好像是个假题，把好多人坑惨了。幸好这场没打，复习雾理要紧。）</p>
<h2 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h2><p>给定bit string a与b，a比b长，问a有多少子串满足和b异或以后有偶数个1。（这里的子串必然是连续的，和b等长的。比如a = ‘001100’, b = ‘001’时a的子串仅有’001’, ‘011’, ‘110’, ‘100’四种，它们和b异或后分别为’001’, ‘010’, ‘111’, ‘101’，有偶数个1的仅有’101’一项。）</p>
<p>直接模拟的复杂度高达$O(n^2)$，稳超时。然后这个操作和线性反馈移位寄存器(LFRS)的操作好像有点像？我们考虑递推。比如a的子串从’001’变到’010’，第一个0变成0，和b第一位异或必然不变；第二位从0变到1，第三位从1变到0，异或后都发生改变。于是，从前一个状态变到后一个状态时异或和中1的个数的改变量即a的原子串满足，此位与下一位相异的位的位数。（有些抽象，拿上面的例子来看能更清晰地感受这种想法）于是可以通过前缀和记录从i位到i+len位中此一位与下一位相异的位的位数。O(n)。</p>
<p>（因为答案是询问模2余0的cnt个数，而非输出每个cnt，所以代码中的cnt只是与”真正的“cnt模2同余而非相等。）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> str1[maxn], str2[maxn];</span><br><span class="line"><span class="keyword">int</span> delta[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, str1, str2);</span><br><span class="line">    <span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(str1), len2 = <span class="built_in">strlen</span>(str2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len1;i++)</span><br><span class="line">        delta[i] = delta[i<span class="number">-1</span>] + (str1[i] != str1[i<span class="number">-1</span>] ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len2;i++)</span><br><span class="line">        <span class="keyword">if</span>(str1[i] != str2[i]) cnt++;</span><br><span class="line">    <span class="keyword">if</span>(cnt % <span class="number">2</span> == <span class="number">0</span>) ans++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len2;i &lt; len1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt += (delta[i] - delta[i-len2]);</span><br><span class="line">        <span class="keyword">if</span>(cnt % <span class="number">2</span> == <span class="number">0</span>) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过细节处理略麻烦：边界的处理，delta的意义（是第i位与i+1位的异同，还是第i位与第i-1位的异同？）。在手工演算的同时，可以通过调整input中的数据边界判断边界处理是否妥当。</p>
<h2 id="E-3"><a href="#E-3" class="headerlink" title="E"></a>E</h2><p>有点烦的题。给你一块地，比如说这样一块2×3的地：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">010</span><br><span class="line">110</span><br></pre></td></tr></table></figure>
<p>然后这块地可以拓展程这样一块(2×2)×(2×3)的地</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">010 101</span><br><span class="line">110 001</span><br><span class="line">101 010</span><br><span class="line">001 110</span><br></pre></td></tr></table></figure>
<p>如果把原来的地记作A，那么拓展后的地就可以记作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A  A&apos;</span><br><span class="line">A&apos; A</span><br></pre></td></tr></table></figure>
<p>其中A’由与A同行同列全为1的矩阵和A异或得到。</p>
<p>地可以无限拓展。题目问的给定这样一个子矩阵，知道其左上角坐标，知道其右下角坐标，问子矩阵中1的个数有多少。</p>
<p>怎么做呢？考虑二维dp。如果能求出(1, 1)到(x, y)这样一个矩阵中1的个数，那(x1, y1)到(x2, y2)的矩阵自然也不在话下。因为题目中x, y高达1e9，所以打表显然不现实。我们能求出来的也就只有$dp[n][m]$这个量级，再大的要怎么算呢？</p>
<p>注意到，很大的一块地中包含了许多小地。如果能求出小地中1的个数和小地的数目，那也很方便算。而注意到所有经过了一次拓展得到的2n×2m的地中1的个数都是相同的，我们就把这样一块地记为一个基本单元，B，其逆为B’。比如说，x = 6n, y = 4m，那么它包含了3×2个这样的基本单元，不管是B还是B’，里头1的数目都是一样的，这样算出来就是$dp[2n][2m] <em> (6n / 2n) </em> (4m / 2m)$。</p>
<p>但是大的地不一定都是上面那样规整的，比如，x = 6n + 2，这要怎么办？通过画图我们能得知，这样在竖直方向多出来了一点点，得把它补上。y = 4n + 3也这样处理。x、y都不规整还会多出来一个小矩阵。但多出来每一块的究竟是B还是B’的一部分呢？这可以通过递归得到。比如从左往右数第5个基本单元，它是由第1个基本单元，也就是B’异或得到的，所以它是B。如此。总之细节处理比较麻烦，结合图片理解更佳。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e3</span>+<span class="number">5</span>; <span class="comment">// caution! the basic unit is 2n*2m</span></span><br><span class="line">LL n, m, q;</span><br><span class="line">LL sum[<span class="number">2</span>][maxn][maxn]; <span class="comment">// 0 for original matrix while 1 for inversed matrix</span></span><br><span class="line"><span class="function">LL <span class="title">get_flag</span><span class="params">(LL c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">0</span> || c == <span class="number">1</span>) <span class="keyword">return</span> c;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>^get_flag(c-(c&amp;-c));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(LL r, LL c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    ans += ((c/m)*(r/n)*sum[<span class="number">0</span>][n][m]); <span class="comment">// part 1</span></span><br><span class="line">    LL dc = c % m, dr = r % n;</span><br><span class="line">    LL flag_r = get_flag(r/n), flag_c = get_flag(c/m); <span class="comment">// r/n for the number of fields in the row</span></span><br><span class="line">    ans += ((r/n+<span class="number">1</span>)/<span class="number">2</span>)*(sum[flag_c][n][dc]); <span class="comment">// part 2: the vertical</span></span><br><span class="line">    ans += (r/n/<span class="number">2</span>)*(sum[<span class="number">1</span>^flag_c][n][dc]);</span><br><span class="line">    ans += ((c/m+<span class="number">1</span>)/<span class="number">2</span>)*(sum[flag_r][dr][m]); <span class="comment">// part 3: the horizontal</span></span><br><span class="line">    ans += (c/m/<span class="number">2</span>)*(sum[<span class="number">1</span>^flag_r][dr][m]);</span><br><span class="line">    ans += sum[flag_r^flag_c][dr][dc]; <span class="comment">// part 4</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> grids[maxn];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, grids+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(LL j = <span class="number">1</span>;j &lt;= m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[<span class="number">0</span>][i][j] = sum[<span class="number">0</span>][i+n][j+m] = (grids[j] - <span class="string">'0'</span>);</span><br><span class="line">            sum[<span class="number">0</span>][i+n][j] = sum[<span class="number">0</span>][i][j+m] = <span class="number">1</span>^(grids[j] - <span class="string">'0'</span>);</span><br><span class="line">            sum[<span class="number">1</span>][i][j] = sum[<span class="number">1</span>][i+n][j+m] = <span class="number">1</span>^(grids[j] - <span class="string">'0'</span>);</span><br><span class="line">            sum[<span class="number">1</span>][i+n][j] = sum[<span class="number">1</span>][i][j+m] = (grids[j] - <span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n *= <span class="number">2</span>, m *= <span class="number">2</span>; <span class="comment">// basic unit: 2n*2m</span></span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    <span class="keyword">for</span>(LL j = <span class="number">1</span>;j &lt;= m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[<span class="number">0</span>][i][j] += (sum[<span class="number">0</span>][i<span class="number">-1</span>][j] + sum[<span class="number">0</span>][i][j<span class="number">-1</span>] - sum[<span class="number">0</span>][i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">        sum[<span class="number">1</span>][i][j] += (sum[<span class="number">1</span>][i<span class="number">-1</span>][j] + sum[<span class="number">1</span>][i][j<span class="number">-1</span>] - sum[<span class="number">1</span>][i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        LL r1, r2, c1, c2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>, &amp;r1, &amp;c1, &amp;r2, &amp;c2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, calc(r2, c2) + calc(r1<span class="number">-1</span>, c1<span class="number">-1</span>) - calc(r1<span class="number">-1</span>, c2) - calc(r2, c1<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="edu-round-67-div2"><a href="#edu-round-67-div2" class="headerlink" title="edu round #67 div2"></a>edu round #67 div2</h1><p><a href="https://codeforces.com/contest/1187" target="_blank" rel="noopener">戳我做题</a></p>
<p>A：给定n个gift，每个包含或者一个A，或者一个B，或者一个A+一个B。现给出n、A、B的数目。问至多要取多少个gift才能保证取到的gift中必然既包含A也包含B。</p>
<p>看到这题没啥思路……其实考虑最坏情形就好了：连着取到的都是只有A或者只有B的gift。设第一类有a个，第二类有b个，第三类c个。那么输出min(a, b)+1就好了。有点抽屉原理的思想？</p>
<p>B：给定一个字符串s，比如说是arrayhead。然后有q个查询，每个查询问的是某个字符串t，比如说’aaa’，要原字符串的从头开始的符合条件的子串的最短长度，这个子串包含了s中的所有字符（计数），比如’aaa’的例子答案为8，子串为’arrayhea’。</p>
<p>容易发现，t中字符的顺序是无关紧要的，重要的信息只有它各个字符出现的次数。于是，我们可以依据某字符频率在原字符串中进行查询，这样的话要先对原字符串进行预处理，得到一个$place[cnt][char]$表示这样的子串的最短长度，其能够匹配频率为cnt的字符char。于是代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> place[maxn][<span class="number">26</span>], occurence[<span class="number">26</span>], cnt[<span class="number">26</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[maxn];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ch = s[i] - <span class="string">'a'</span>;</span><br><span class="line">        place[++occurence[ch]][ch] = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, temp);</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="built_in">strlen</span>(temp)<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ch = temp[i] - <span class="string">'a'</span>;</span><br><span class="line">            cnt[ch]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">26</span>;j++)</span><br><span class="line">            ans = max(ans, place[cnt[j]][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>初稿写于2019.06.04</p>
    </div>
  </article>
  <div class="post-nav">
    <div class="post-nav-next post-nav-item">
      
        <a href="/2019/06/29/ICPC-Practice_Codeforces_1/" rel="next" title="【图灵之路】CF记-其一（2019-06-29更新）">
          <i class="fa fa-chevron-left"></i> 【图灵之路】CF记-其一（2019-06-29更新）
        </a>
      
    </div>

    <span class="post-nav-divider"></span>

    <div class="post-nav-prev post-nav-item">
    
        <a href="/2019/06/29/ICPC-Practice_Codeforces_3/" rel="prev" title="【图灵之路】CF记-其三（2019-07-18更新）">
          【图灵之路】CF记-其三（2019-07-18更新） <i class="fa fa-chevron-right"></i>
        </a>
      
    </div>
  </div>



      </div>
        <div class="footer">
  <div class="footer-wrapper">
    <div class="copyright">
      
      <span>&copy;</span>
      
      <span>2019</span>
      
      <span class="author"><i class="fa fa-user"></i>Ness</span>
    </div>
    
      <span>由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</span>
    
    
      <span>|</span> <span>主题 - <a href="https://github.com/littleee/corazon">Corazon</a></span>
      
        <span>v1.0.0</span>
      
    
  </div>
</div>

    </main>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
