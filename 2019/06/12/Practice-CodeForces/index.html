<html>
  <head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  
    <link rel="icon" href="/images/logo.jpg">
  
  <title>Ness</title>
  <link rel="stylesheet" href="/css/styles.css">
  <script src="/lib/jquery.js"></script>
  <link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css">
  <script src="/js/common.js"></script>
  <script src="/lib/bootstrap/js/bootstrap.js"></script>
  <link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

  <body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><header class="header">
  <div class="color-bar">
    <ul>
      <li class="bar1"></li>
      <li class="bar2"></li>
      <li class="bar3"></li>
      <li class="bar4"></li>
      <li class="bar5"></li>
      <li class="bar6"></li>
    </ul>
  </div>
  <div class="header-wrapper">
    <div class="blog-title">
      
        <img class="logo" src="/images/logo.jpg" alt="logo">
      
      <a href="/" class="title">Ness</a>
    </div>
    <nav class="navbar navbar-menu">
      <div class="container-fluid">
        <div class="navbar-header">
          <button type="button" id="nav-btn" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
        </div>
      </div>
        <ul class="menu menu-pc">
          
            <li class="menu-item">
              <a href="/" class="menu-item-link"><i class="fa fa-home"></i><span>首页</span></a>
            </li>
          
            <li class="menu-item">
              <a href="/tags/" class="menu-item-link"><i class="fa fa-tags"></i><span>标签</span></a>
            </li>
          
            <li class="menu-item">
              <a href="/archives/" class="menu-item-link"><i class="fa fa-file"></i><span>归档</span></a>
            </li>
          
            <li class="menu-item">
              <a href="https://github.com/NessOffice" class="menu-item-link"><i class="fa fa-github"></i><span>GITHUB</span></a>
            </li>
          
        </ul>
    </nav>
  </div>
</header>
<div class="collapse nav-collapse" style="position:fixed;top:59px;" id="bs-example-navbar-collapse-1">
  <ul class="menu menu-mobile" style="list-style:none">
    
      <li class="menu-item">
        <a href="/" class="menu-item-link"><i class="fa fa-home"></i><span>首页</span></a>
      </li>
    
      <li class="menu-item">
        <a href="/tags/" class="menu-item-link"><i class="fa fa-tags"></i><span>标签</span></a>
      </li>
    
      <li class="menu-item">
        <a href="/archives/" class="menu-item-link"><i class="fa fa-file"></i><span>归档</span></a>
      </li>
    
      <li class="menu-item">
        <a href="https://github.com/NessOffice" class="menu-item-link"><i class="fa fa-github"></i><span>GITHUB</span></a>
      </li>
    
  </ul>
</div>

    <main class="main">
      <div class="content">
        
  <article class="post">
    <div class="post-title">
      <h2 class="title">【图灵之路】CF记（2019-06-12更新）</h2>
	  <div style="margin: 0 10 20px;">
		<span class="post-count">
		  <span class="post-meta-item-icon">
			<i class="fa fa-keyboard-o"></i>
			<span class="post-meta-item-text">  字数统计: </span>
			<span class="post-count">6k字</span>
		  </span>
		</span>

		<span class="post-count">
		  &nbsp; | &nbsp;
		  <span class="post-meta-item-icon">
			<i class="fa fa-hourglass-half"></i>
			<span class="post-meta-item-text">  阅读时长: </span>
			<span class="post-count">23分</span>
		  </span>
		</span>
	  </div>
       
        <p>计算机</p>
      
    </div>
     <div class="post-meta">
      <span class="post-time">2019-06-12</span>
    </div>
    <div class="post-content">
      <h1 id="round-563-div2"><a href="#round-563-div2" class="headerlink" title="round #563 div2"></a>round #563 div2</h1><p>第一次玩CF……好紧张……这网站注册五个月了就没登进去过……</p>
<p>随便写写关于题解的随想吧……</p>
<p><a href="https://codeforces.com/blog/entry/67340" target="_blank" rel="noopener">戳我做题</a></p>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>（分析题，分析出关键的性质就能做了）</p>
<p>（一开始把题目看错了，看成是模2同余才能交换，心想这不就分奇偶排下序就好了嘛……码完代码就被测试数据piapia打脸）</p>
<p>不是很有想法。如果所有数奇偶性都相同这个情况是容易考虑的。可如果有奇数也有偶数呢？先考虑1奇n偶的情况吧。1奇1偶肯定能有序，1奇2偶呢？这个要分类讨论了，我的想法是把最小的数先移到最前面，之后化归到规模更小的情形。但是这样有个问题，就是如果最小数是那个奇数，比方说，输入数据为1, 6, 4，貌似会出问题……1, 6, 4能不能排成1, 4, 6呢？瞎搞了一下发现可以，于是乎，发现了一个奇妙的性质：只要序列中有奇数也有偶数，那么通过一个奇数（它的位置不会改变），任意两个偶数间也能交换位置。于是排序就是可行的了。sort之。</p>
<p>（可还是不知道这题在考什么<del>，群论？</del>）</p>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>（还是分析题……）</p>
<p>题目中说，任意两个互素的数，其f值不相等。这个条件初看比较别扭，也比较抽象，还是先把它具象化吧。</p>
<p>如果是素数的话，它的f值肯定不能和其他素数的f值相等。于是我们令f(2)=1, f(3)=2, …</p>
<p>至于合数呢？由题意，f的最大值不能过大，我们看看合数的f值能否和素数相等，可令f(合数)=f(该合数的某素因子)，为方便计算，不妨再令f(合数)=f(该合数的最小素因子)，即f(某数)=f(该数的最小素因子)。这样能否满足题意呢？</p>
<p>可以的！假如两数互素，它们的最小素因子必不同，而f是由一个数的最小素因子决定的。</p>
<p>这样分析完，上个欧拉筛就完事了。</p>
<p><del>其实令f(某数)=f(该数的最大素因子)更好算，直接埃氏筛就搞出来了，可是我没想到\cry\cry\cry</del></p>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>（前缀和呀前缀和，我怎么就把你忘了呢）</p>
<p>嗯……题意是让你求一个数列，使得其任意子列全部元素异或后不能和0或x相等，且数列长度尽量长，答案有多组，任意输出一组（还有个条件：所有元素均小于2^n）。比如，x=5时候{6, 1, 3}满足条件，因为它的子列有{6}{1}{3}{6, 1}{1, 3}{6, 1, 3}，异或后分别为6, 1, 3, 7, 2, 4，都不等于5。</p>
<p>当时被“子列”这个条件困扰了好久，也不知道怎么样让数列长度尽量长（我的想法是，任意新添加一个元素，都会引发矛盾，但是这样复杂度巨大……），一直在玄学思考子列能推出什么，发现如果在数组的中间取标记点，向两边扩展，能够完美匹配题目中的条件，但是这样在细节上很难处理……线性计算复杂度太高，二分也不见得简单。</p>
<p>看到题目中说前缀和（其实是前缀异或和，不过反正思想是这个思想，将二维的子列化为一维的数组，级数也是这个思想）后，恍然大悟：</p>
<p>$a_l \oplus a_{l+1} \oplus … \oplus a_r = b_{l-1} \oplus b_r$（$b_i = a_1 \oplus a_2 \oplus … \oplus a_i$，由异或运算的交换律和自反率知，该等式成立）</p>
<p>这样的话，就不用考虑$a_i$，考虑$b_i$所成的数列就好了呀，因为$a_i = b_{i-1} \oplus b_i$。那么$b_i$，要如何考虑呢？</p>
<p>由题意，$b_i \oplus b_j \not = 0$，这说明$b_i \not = b_j$（异或的逆元是且仅是本身），还有$b_i \oplus b_j \not = x$，只要保证$b_i \not = (x \oplus b_j)$就好了。于是可以设个vis数组，逐个确定$b_1, b_2, …$，比如$b_1$确定了，那么$vis[b_1] = vis[x \oplus b_1] = 1$，后面的$b_j$不能取$b_1$或是$x \oplus b_1$。</p>
<p>因为交换$b_i$和$b_j$不影响答案的正确性，所以$b_i$是可以任取的。为方便记，不妨从小到大遍历，发现$vis[k] = 0$则取$b_i = k$。从这个过程可以看出，算法的复杂度为$O(2^n)$。</p>
<p>从这里也可以看出{b}的长度了。把$i$和$x \oplus i$看作是一对，那么一对中只能取一个。所以$len(b)$=可用的数的数量/2。</p>
<p>但是还要注意一下细节，题目中的输入数据也提示了：$x \geq 2^n$的时候，无需把$i$和$x \oplus i$看作一对，因为后者根本取不到。这个情况下$len(b)$=可用的数数目。</p>
<p>（开始把题目的数据看错了，看到18，就想到long long在十进制下约为18位，于是感觉这样的vis开不下，没有进一步往下想。<del>开了vis又如何呢，还不是做不出来</del>）</p>
<p>手是生了啊。</p>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>（需要分析的，较为复杂的dp）</p>
<p>题意稍微有点绕，它提到了一个f(p)，定义略奇特，我们用直观的例子体会一下这个f是怎么算的。</p>
<p>比如给定排列{6, 2, 1, 3, 5, 7}，求它前i个数的最大公约数，排出来，就是{6, 2, 1, 1, 1, 1}。这里头有三个不同的数，于是$f(p)=3$。</p>
<p>{1, 2, 3, 4, 5, 6}除了上面那种排列外，还有其他排列，算出来的$f$不尽相同，但总归是有最大值的，记作$f_{max}$。题目问的就是，n-排列中，有多少种排列，算出来的$f$等于$f_{max}$呢？</p>
<p>我们来看看那个前缀最大公约数的数列，粗略一看，它似乎是单调不增的，这很好证明。再一看，发现$g_i$和$g_{i+1}$是有关系的（$g_i$即前缀最大公约数数组的第i项），就是$gcd(g_i, g_{i+1}) = g_{i+1}$。</p>
<p>要想$g_i$的取值尽可能多样，我们要让它减少地尽量缓慢。将排列的首项，$a_0$，素因子分解，我们发现，$f = \sum \alpha_i$（算数基本定理的简单应用）。所以$f_{max}$就是$\sum \alpha_i$最大时候的取值。这个是数论上的内容。结论如下：f取最大值时，$a_0 = 2^x \cdot 3^y$，且$y \leq 1$。</p>
<p>（证明的话，就是替换的思想。如果$a_0$中有其他素数，比如说，5，那么我们可以令$a^{‘}_0=2<em>2/5</em>a_0$，这样$a^{‘}_0$打头时候得出的f必然比$a_0$打头时候得出的要大。同理可以证明$a_0$中3的指数小于2）</p>
<p>发现了这个结论我们该怎么算答案呢……看看题，感觉要dp？那么怎么指定状态呢？<del>参考题解发现</del>令$dp[i][x][y]$表示排列到前i个数时，最大公约数为$2^x \cdot 3^y$这一状态可以让我们很方便地算出答案。因为每次添加一个数，所以都是$dp[i+1][][] = dp[i][][] + …$，而要取到$f_{max}$，x、y可以保持不变或是x—或是y—，总共三种状态转移的模式。在添加第i+1个数时候，要考虑只能添加取符合要求的数，不能取已经取到的数。归纳一下，也便如下（伪代码，不是AC代码；和$dp[i][x][y]$相乘的那个数就是符合条件的第i+1个数的个数了）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i+<span class="number">1</span>][x][y] = (dp[i+<span class="number">1</span>][x][y] + dp[i][x][y] * (cnt(x, y) - i));</span><br><span class="line">dp[i+<span class="number">1</span>][x<span class="number">-1</span>][y] = (dp[i+<span class="number">1</span>][x<span class="number">-1</span>][y] + dp[i][x][y] * (cnt(x<span class="number">-1</span>, y) - cnt(x, y)));</span><br><span class="line">dp[i+<span class="number">1</span>][x][y<span class="number">-1</span>] = (dp[i+<span class="number">1</span>][x][y<span class="number">-1</span>] + dp[i][x][y] * (cnt(x, y<span class="number">-1</span>) - cnt(x, y)));</span><br></pre></td></tr></table></figure>
<p>下面是本题的坑点了……</p>
<p>不能用long long保存数据，会MLE，要用int，但是这样运算时候有可能溢出，怎么办呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i+<span class="number">1</span>][x][y] = (dp[i+<span class="number">1</span>][x][y] + <span class="number">1L</span>L*dp[i][x][y] * (cnt(x, y) - i)) % MOD;</span><br></pre></td></tr></table></figure>
<p>注意那个1LL……上次校赛的题也是。</p>
<p>（最后交上去，2s的时限跑了1965ms，也太不好玩了吧！O(nlogn)不是很优雅了么！本来想用bfs稍微优化一下的，但还是懒得弄了……）</p>
<p>（又把数字看错了，2^18 &gt; 1e6我是怎么算出来的……）</p>
<p>F题还没补，先放放。（Idleness？）</p>
<h1 id="edu-round-66-div2"><a href="#edu-round-66-div2" class="headerlink" title="edu round #66 div2"></a>edu round #66 div2</h1><p>模拟题杀我……贪心杀我……</p>
<p>（为什么edu没有答案啊啊啊啊还有edu是什么意思它和div什么关系啊啊啊啊）</p>
<p><a href="https://codeforces.com/blog/entry/67340" target="_blank" rel="noopener">戳我做题</a></p>
<h2 id="B-1"><a href="#B-1" class="headerlink" title="B"></a>B</h2><p>复杂的模拟题……看着很烦，思绪很乱。感觉是对的结果交上去WA了，再改改又WA了。一天后突然想到自己是哪里没想明白，这才AC。</p>
<p>模拟题很烦，看上去不能够考察能力，但其实是能的。它能考察心态，考察对于问题的分析能力。这些，是我还不够好的。</p>
<p>先来读题。输出比较简单，那就看输出。输出分溢出与否两种情形。然后溢出也分两类，一类是小数加加加加爆了，还有是循环循出超级大的数然后一加就加爆了。这两类有何区别呢？区别在于，第一类可以直接模拟，而第二类不能直接模拟，需要记录是在哪一层会加爆，然后如果“ADD”出现在这层以上，就置flag=1。</p>
<p>大致想明白了输出要怎么处理，接下来是看输入了。输入有三类：“ADD”“FOR x”“END”，ADD用以模拟相加（还要看会不会出现上面的第二类情况），for和end共同构成一个循环。根据输入，我们可以设置一个loop[maxn]记录每层for的次数，设置一个looping_now记录当前需要ADD的值，同时记录一个depth_now记录当亲啊层数，设置一个depth_overflow记录加爆了的层数（超过此层，looping_now不再更新）。</p>
<p>于是我们可以写出这样的伪代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, cmd, &amp;x);</span><br><span class="line">    <span class="keyword">if</span>(cmd == <span class="string">"ADD"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(depth_now &gt; depth_overflow) <span class="comment">// case 2</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        ans += looping_now;</span><br><span class="line">        <span class="keyword">if</span>(overflow(ans)) <span class="comment">// case 1</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cmd == <span class="string">"FOR"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(overflow(looping_now * x + ans))</span><br><span class="line">            depth_overflow = depth_now;</span><br><span class="line">        <span class="keyword">if</span>(depth_now &lt; depth_overflow)</span><br><span class="line">            looping_now *= x;</span><br><span class="line">        loop[depth_now++] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cmd == <span class="string">"END"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        depth_now--;</span><br><span class="line">        <span class="keyword">if</span>(depth_now &gt;= depth_overflow)</span><br><span class="line">            looping_now /= loop[depth_now];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后便是处理细节了……</p>
<h2 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h2><p>是个思路题，问的是给定n个x轴上的不同位置的整点，让你找一个整点$p_0$，使得$p_0$到距$p_0$第k近的点的距离，比任意$p_{random}$到距$p_{random}$第k近的点的距离，来得小。k由题目给出。</p>
<p>简单想想，k=1或k=2的情况很容易考虑，但是如何将其推广到k更大的情况呢？我们注意到一个事实，即沿着一个点向左走，它所后经过的点一定远于它所先经过的点，向右亦然，但是左点的远近与右点的远近间没有关联。</p>
<p>那么，对$p_0$而言，如果距它第k近的点$p_k$在其右侧，则距它第k-1近的点$p_{k-1}$可以在左侧也可以在右侧。若在右侧，则可以把$p_0$向右移动一位，容易看出，此时$p_k$仍然为距$p_0$第k远的点（证明的话，反证）。于是我们可以重复此操作，直至$p_{k-1}$转移到$p_0$的左侧为止。</p>
<p>于是这样一来，我们得到$p_0$是被包围在$p_{k-1}$与$p_k$间的一点。让我们忽视$p_1, p_2, …, p_{k-1}$，因为既然它们同在这个“包围圈”中，那么$p_0$在这个“包围圈”中移动到$p_0^{‘}$位置时，这k-2个点的某个排列必然构成$p_1^{‘}, p_2^{‘}, …, p_{k-2}^{‘}$。</p>
<p>那么现在，问题就简化为：$p_0$在$p_{k-1}$和$p_k$之间，如何取$p_0^{‘}$使得它到两点中更远的点的距离最短？很显然，中点。（此时$p_{k-1}$和$p_k$都是形式上的记号，是固定的点，$|p_0^{‘} p_k|$不一定大于$|p_0^{‘} p_{k-1}|$。但这两点的排列必然构成$p_0$移动到$p_0^{‘}$位置时实际意义上的$p_{k-1}^{‘}, p_k^{‘}$。我们一开始选定的$p_0$是任取的。将此$p_0$进行移动所得到的最优的$p_0^{‘}$才是我们想要的答案）</p>
<p>然后上面得到的形式上的$p_{k-1}$和$p_k$要怎么确定呢？注意到只要中间包含了k-2个点的点对都可能符合要求，于是一波遍历就好了。</p>
<h2 id="D-1"><a href="#D-1" class="headerlink" title="D"></a>D</h2><p>给定一个n元数组，让你在其中放一些（k-1）隔板，使得从$\sum 从左往右第i个区块中所有数字的和 * i$最小。</p>
<p>看到一些数字的和，我们考虑前缀和（$s_i = \sum\limits_{j = 1}^i a_j$），设题目中的分点为$t_1, …, t_k$，则所求即$\sum\limits_{i = 1}^k (s_{t_i} - s_{t_{i-1}}) \cdot i$（$t_0 = 0, t_k = n$）。</p>
<p>这个式子可以写成$k \cdot (s_{t_k} - s_{t_{k-1}}) + (k - 1) \cdot (s_{t_{k-1}} - s_{t_{k-2}}) + … + 1 \cdot (s_1 - s_0)$。也即$k \cdot s_{t_k} - (s_{t_1} + s_{t_2} + … + s_{t_{k-1}})$。</p>
<p>其中$t_1, t_2, …, t_{k-1}$是我们选择的分点，$t_k = n$。所以把前缀和排个序就好了。（注意排序是sort(s+1, s+n)而不是sort(s+1, s+n+1)）。</p>
<p>下面是原思路……</p>
<p>给定的样例为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 2</span><br><span class="line">-1 -2 5 -4 8</span><br></pre></td></tr></table></figure>
<p>不难发现，将5，-4，8划分到第二组优于将8划分到第二组。为什么呢？因为5-4&gt;0。从8开始，我们向左找相加为正数的一个点，再找下一个点……这样的贪心思路。</p>
<p>（结合代码可能更容易理解我的思路，另外sum后缀和而非前缀和……）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LL a[maxn], sum[maxn], next_node[maxn];</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(LL n, LL k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += (sum[<span class="number">1</span>] - sum[n+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL n_next = n;</span><br><span class="line">    <span class="keyword">while</span>(next_node[n_next] &gt;= k)</span><br><span class="line">        n_next = next_node[n_next];</span><br><span class="line">    ans += k*(sum[n_next] - sum[n+<span class="number">1</span>]);</span><br><span class="line">    split(n_next<span class="number">-1</span>, k<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这里头的next_node数组，要如何确定呢？（为什么要设next_node数组？因为直接算的复杂度是$O(n)$）</p>
<h2 id="E-WA"><a href="#E-WA" class="headerlink" title="E(WA)"></a>E(WA)</h2><p>其实可以把问题做等价的转化，就是思考从x开始，它要经过多少个区间才能”跳“到y点。拿例子来说，比如已有[1, 3], [2, 4]两区间，那么(x, y) == (1, 2)时hop=1，因为经过[1, 3]区间即可，(x, y) == (1, 4)时则hop = 2：从1跳到3再跳到4，或是从1跳到2再跳到4，没有更短的路径。</p>
<p>在这个问题中，设询问区间的左端点为x，它通过一个区间能“跳”到$z_1, z_2, z_3, …, z_m$这些点（$z_1, z_2, z_3, …, z_m$呈升序）。不难发现，贪心的思路能帮助我们解决问题，即$x-&gt;z_m, z_m-&gt;y$这种跳法必然优于$x-&gt;z_k, z_k-&gt;y$（$1 \leq k \leq m$）。（画个图感受一下更好，证明的话反证即可）</p>
<p>想到了这点，我们再来想如何进一步地处理这个问题呢。储存所有可能的询问值么？这样复杂度在时间上是$O(n^2)$，空间上也会爆。为了降低复杂度，我们考虑倍增的思路，记录从每个点开始，跳1步，跳2步，跳4步……所能达到的最远点。这样也不难设计出针对每个查询的算法。</p>
<p>倍增首先要处理边界情形：跳1步所能达到的最远点。考虑将所给区间按$l$从小到大排序（$l$若相同，保留$r$最大的那个区间，其他舍去）。那么若一个点P在一个或多个区间内，选取包含它的$l$值最大的区间[$l_{max}$, $r_{max}$]，则该区间是所有包含点P的区间中$r$最大的（由之前的排序得到）。故P所能到达的最远点，即$r_{max}$。</p>
<p>（另外，题目中有一些不被任何区间包含的点，我们记它们跳任意距离都会到-1）</p>
<p>然后是写倍增了，这是较为容易的。（但不知道有没有地方写错了……也检查不出来）</p>
<p>对于每次查询，我们看x跳一步是否能到达y，如是，则所经路径数+1，返回答案。如否，则会有两种情况：1）x最终跳到了一个”不动点“（$f[x][i] == f[x][i+1]$）；2）存在$i \geq 0$使得$f[x][i] &lt; y \leq f[x][i+1]$。对于前一种情况，我们返回-1（因为这个不动点必然在y左侧，如果不是，那么x会从case 2中退出，或者x跳一步就到达y了）。对于后一种情况，我们把$f[x][i]$代回$x$，进行迭代。</p>
<p>（这个算法看上去是正确的？然而WA了……）</p>
<p>（测试数据规模较大故无法拿到。值得一提的是，有output=2而实际应为1的情况，也有output=-1而实际为正数的情况。）</p>
<h1 id="round-564-div2-鸽"><a href="#round-564-div2-鸽" class="headerlink" title="round #564 div2(鸽)"></a>round #564 div2(鸽)</h1><p>A注意特判。</p>
<p>B倒是挺有意思，找规律+假的数学归纳法可以得出一种可能的答案，但它为何而正确呢？（更代数的看）三角不等式。</p>
<p>C……毒瘤题。总归是贪心的思路，就看开始要浪费多少牌才能开始顺序打出所有牌了。而这可以通过枚举要把哪张牌垒到顶上来算。但是，为什么这样的策略是可行的呢？（我希望构造性的游戏方案，而不是非构造性地给个最优解）</p>
<p>D的话，我的关注点在“交叉”上，然后想着想着就想到麻烦的方向去了，想到图的结构如此的话该如何如何……而忽视了“树”这一条件。从根结点出发，可以发现，子树中的结点都是占据了“整一块”连续的圆弧的。在这个条件下，如果知道父母结点的位置，子树的个数，还有父母+孩子所占据的圆弧是既定的这一信息，就能列出所有可能的方案数了（$父母节点方案数=子树排列数 \cdot \prod 孩子节点方案数$）。虽然思想是dp，但算一算是能发现公式的，于是打表就好了。</p>
<h1 id="round-565-div3-鸽"><a href="#round-565-div3-鸽" class="headerlink" title="round #565 div3(鸽)"></a>round #565 div3(鸽)</h1><p>B又是贪心……数字的位置无关紧要，只有模三余n的数的个数是重要的信息。瞎匹配就好。我想如果把题目中“任意取两数”的条件改成“取相邻两数”，这道题该怎么做？</p>
<p>E的话我想想把这个图打成树，然后bfs二染色就好了……懒得写bfs就用了dfs，结果居然t了。这时才看到数据规模竟有$T \leq 2e5, n \leq 2e5$之大，这dfs个毛线啊？于是我在读入的时候直接随便染色，居然还是t。把memset去掉换成for，才a……（随便染色是怎么染呢？就那么染呗。如果当前读入的两个点都没染过，一个染0一个染1；如果都染过就跳过；如果一个染过一个没染，把没染的染和染了的染色相不同的染色。容易证明，这样下来符合题意。）</p>
<h2 id="D-2"><a href="#D-2" class="headerlink" title="D"></a>D</h2><p>“看到这个题，我有一种莫名的近乎落泪的感动。”</p>
<h2 id="F-WA"><a href="#F-WA" class="headerlink" title="F(WA)"></a>F(WA)</h2><h1 id="round-566-div2"><a href="#round-566-div2" class="headerlink" title="round #566 div2"></a>round #566 div2</h1><p>（掉分的感觉，真·爽的一批）</p>
<p>做A的时候，乘法法则加法法则傻傻分不清，我不仅现在离散没学好，高中组和数学也没学好……</p>
<p>做B的时候想能否边读入便判定，便先找center_c再找center_r，可这样不仅代码长，还要考虑特殊情况。直接通过center的性质找第一个符合条件的不就好了么！做得又慢，做完还错，讨厌模拟题，但又不能秒过它，这样的态度不行的啊。</p>
<p>做C的时候（读题读了好久……对关键点的挖掘还不够迅速而准确，我的阅读理解能力有待提高）贪心的思想是没问题了，结果在字符长度上出了篓子……这是ICPC不是CTF，毒瘤出题人总喜欢出毒瘤数据。对可变长数组的感觉还不够啊。$vector<char>$，或者$string$。</char></p>
<p>做E的时候看出它是个矩阵快速幂了，但是把这东西的细节都忘掉了……无奈在比赛结束后20分钟才过sample。不过当时如果做出来也过不了的吧，因为费马小定理的关系。</p>
<h2 id="C-2"><a href="#C-2" class="headerlink" title="C"></a>C</h2><p>题意：给你若干个单词，让你选四个配成一对。要求是第一个词和第三个词有相同的元音数，第二个词和第四个词有相同的元音数且它们最后一个元音一样（由题意，每个单词至少有一个元音，所以一行中的最后一个元音必然在后面的词上）。问最多能配出多少对。然后输出最多匹配时的任意一种方案。</p>
<p>题目里有效的信息是单词、元音数、最后的元音。于是我们可以用一个struct来存数据。然后怎么匹配呢？考虑到第二个词和第四个词间的关系更强，我们先匹配出这一类，然后再匹配有相同元音数但是末位元音不一的另一类。</p>
<p>二四类怎么匹配呢？考虑贪心的思路。按元音数-最后元音进行排序，i从1到n，考虑nodes[i]和nodes[i+1]能不能匹配，能就匹配它们了（同时设vis[i] = vis[i+1] = 1，以防一个单词被重复使用）。不能则说明nodes[i]不能和其它nodes匹配（易证）。这样遍历一遍就匹配出同时能取的最多的二四类了。</p>
<p>一三类的匹配比较常规，也是贪心的思路，就不谈了。</p>
<p>匹配完之后我们得到cnt_first个一三类的单词组，cnt_second个二四类的单词组。怎么输出呢？分类讨论呗。若是cnt_first &gt;= cnt_second，输出cnt_second组单词就好了。若是cnt_first &lt; cnt_second，考虑到二四类的单词比一三类强（也就是，二四类的单词可以兑换成一三类用），输出cnt_first + (cnt_second - cnt_first) / 2组单词就好了。细节不表。</p>
<h2 id="E-1"><a href="#E-1" class="headerlink" title="E"></a>E</h2><p>接近裸的递推关系。把$f_n$写成$c^{a(n)} \cdot f_1^{b(n)} \cdot f_2^{c(n)} \cdot f_3^{d(n)}$的形式，就可以发现递推方程啦。其中b, c, d都是同一形式的，只不过初始条件不同罢了。a要特殊点，因为你要把它在形式上做一些变换，这是高中的内容。</p>
<p>然后矩阵快速幂上板子。要注意的是，$MOD = 1e9+7$是个质数，故而$c^{p*(MOD-1) + q} \equiv c^{p + q}$（费马小定理）。在处理指数的递推关系时候，要模MOD-1；而在计算快速幂时，要模MOD。</p>
<p>写题目的时候碰到个坑点，记录如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n &gt;= <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    n -= <span class="number">3</span>;</span><br><span class="line">    LL ans = qpow_num(qpow_matrix(n) - n, c); <span class="comment">// qpow_num(expo, base)</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样是过不去的，为什么？因为上面把n改变了，所以在处理a的时候得小心一点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n &gt;= <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    n -= <span class="number">3</span>;</span><br><span class="line">    LL ans = qpow_num(qpow_matrix(n) - n - <span class="number">3</span>, c); <span class="comment">// caution!</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样有时候会t，为什么？因为前面算出来的qpow_matrix那个是模过MOD-1的，而n没有模过MOD-1，所以指数会出现负数的情形，这样子快速幂就跳不出来了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n &gt;= <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    n -= <span class="number">3</span>;</span><br><span class="line">    LL expo1 = qpow_matrix(n) - n - <span class="number">3</span>;</span><br><span class="line">    expo1 = ((expo1 % (MOD<span class="number">-1</span>)) + (MOD<span class="number">-1</span>)) % (MOD<span class="number">-1</span>); <span class="comment">// caution!</span></span><br><span class="line">    LL ans = qpow_num(expo1, c);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模过的数和没模过的数……变量在公式上的始终如一与在程序上的可变……这些都是坑点啊。尽管可能还会再犯，但希望下次能先把这些错误过一遍，有个印象总得。</p>
<hr>
<p>初稿写于2019.06.04</p>
    </div>
  </article>
  <div class="post-nav">
    <div class="post-nav-next post-nav-item">
      
        <a href="/2019/06/10/Programming_Pits/" rel="next" title="【图灵之路】踏过的坑（2019-06-10更新）">
          <i class="fa fa-chevron-left"></i> 【图灵之路】踏过的坑（2019-06-10更新）
        </a>
      
    </div>

    <span class="post-nav-divider"></span>

    <div class="post-nav-prev post-nav-item">
    
        <a href="/2019/06/16/Project-Tetris/" rel="prev" title="【图灵之路】管理的困境——记project-tetris开发的心路历程">
          【图灵之路】管理的困境——记project-tetris开发的心路历程 <i class="fa fa-chevron-right"></i>
        </a>
      
    </div>
  </div>



      </div>
        <div class="footer">
  <div class="footer-wrapper">
    <div class="copyright">
      
      <span>&copy;</span>
      
      <span>2019</span>
      
      <span class="author"><i class="fa fa-user"></i>Ness</span>
    </div>
    
      <span>由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</span>
    
    
      <span>|</span> <span>主题 - <a href="https://github.com/littleee/corazon">Corazon</a></span>
      
        <span>v1.0.0</span>
      
    
  </div>
</div>

    </main>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
